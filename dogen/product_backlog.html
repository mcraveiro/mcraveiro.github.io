<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-02-26 Fri 18:20 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Product Backlog</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/tufte.css" type="text/css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Product Backlog</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org31c387d">1. Product Vision</a>
<ul>
<li><a href="#org612e5c6">1.1. Vision Statement</a></li>
<li><a href="#org79b21d0">1.2. Vision Quotes</a></li>
</ul>
</li>
<li><a href="#org6642e14">2. Release Checklist</a>
<ul>
<li><a href="#org6b9eb2b">2.1. Close previous sprint</a></li>
<li><a href="#org0abbdd4">2.2. Open new sprint</a></li>
</ul>
</li>
<li><a href="#org036a8df">3. V2 Release</a>
<ul>
<li><a href="#orga4c6669">3.1. Core work</a>
<ul>
<li><a href="#orgfc6c0a1">3.1.1. Implement code mer</a></li>
<li><a href="#org20f85ed">3.1.2. "Inferred" models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge25e360">3.1.3. Add custom IDs to attributes in org model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge611c86">3.1.4. Artefacts do not belong in codec models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3aeaf0b">3.1.5. Add model name as title in PlantUML diagram&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga788ace">3.1.6. Create a "manual tests" stereotype with profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb09c635">3.1.7. Modeling of dogen models themselves&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga078fb9">3.1.8. Allow defaulting to target directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org27118a8">3.1.9. Missing PlantUML features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org54c8378">3.1.10. Deprecate managed directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4a9eb32">3.1.11. Add models directory to each component&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org666e1ac">3.1.12. Move hello world model from models directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5e7d38c">3.1.13. Consider handling "dia comments" in a general manner&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf39f0c8">3.1.14. Move wale templates to TS namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge6d6d0a">3.1.15. Implement M2T chains via code generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9392a84">3.1.16. Consider renaming <code>text</code> to <code>logical_physical</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0e20d3b">3.1.17. Validate no two artefacts have the same ID&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga3c01eb">3.1.18. Fix name of configuration tracing file&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org91041bc">3.1.19. Rename <code>name</code> to <code>codec</code> name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb977058">3.1.20. Add descriptions to PMM elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5504686">3.1.21. Create a physical ID in logical-physical space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgda2d4ed">3.1.22. Factor out duplication in stitch and wale templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orged95eea">3.1.23. Stitch templates should be bound to Dogen M2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfb9ca44">3.1.24. Name all transform exceptions consistently&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org64e7edd">3.1.25. Processing of boost tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1a5fc25">3.1.26. Model projections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga3fdfd8">3.1.27. Add references as links to org documents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1510cf3">3.1.28. Empty model generation produces no diffs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1fa901e">3.1.29. Generated CMakefiles do not take tests into account&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6a73b53">3.1.30. Consider creating a "combined" template&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org29b0b96">3.1.31. JSON models do not create containment structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org90af0e2">3.1.32. Running convert without parameters should work&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga4a021c">3.1.33. Reorganise dogen output&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfb7c968">3.1.34. Consider adding support for C++ container generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0e55c3e">3.1.35. Consider adding a codec meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8f612f7">3.1.36. Allow uses of "dictionaries" for invalid class names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge9d3c35">3.1.37. Technical space composition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge936d57">3.1.38. Add technical space version to element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org015aafb">3.1.39. Model functionality provided by assistant in the logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3f9fde9">3.1.40. Refactor the templating model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org42a9e6a">3.1.41. Remove annotations from stitch templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0251775">3.1.42. Move all stitch include dependencies to legacy transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5c4d062">3.1.43. Improve modeling of attribute properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd7db422">3.1.44. Prune non-generatable types from logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1f5f157">3.1.45. Feature initializer with no features does not compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga84ce1f">3.1.46. Create a patch for tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org042f454">3.1.47. Wale should throw on non-required keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org35752be">3.1.48. Remove wale instantiation from stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd7128c4">3.1.49. Decouple physical model from logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd2ee4a4">3.1.50. Replace meta-model naming with stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge81c425">3.1.51. Consider making technical spaces a core concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc53cf60">3.1.52. Move io code in types in C++ to io facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7fa091e">3.1.53. Analysis of MDE papers to read&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5d1d22c">3.1.54. Order of headers is hard-coded&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org97648a9">3.1.55. Create a de-normalised representation of archetype properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9d399c9">3.1.56. Move default constructor work from resolver&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org74c14a3">3.1.57. Create a technical space specific property for default functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6480ece">3.1.58. Default constructor incorrectly generated in C++ 98&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0fb95d7">3.1.59. Detect absence of configuration in bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgffa94af">3.1.60. Refactor streaming properties processing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd62dc49">3.1.61. Add method to check if string is valid enum&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7f0ac73">3.1.62. Split <code>utility</code> into multiple models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc113340">3.1.63. Add full and relative path processing to PM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5142483">3.1.64. Create a factory transform for parts and archetype kinds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org263c26d">3.1.65. Allow arbitrary physical containment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7211fa8">3.1.66. Rename <code>archetype_name_set</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga45dba5">3.1.67. Add dependencies to artefacts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga0f0642">3.1.68. Add instances of physical meta-model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org61bf14e">3.1.69. Improve support for references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org969db16">3.1.70. Replace <code>facet_default</code> with labels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2a1542f">3.1.71. Add dependency generation to PM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org517aefd">3.1.72. Add archetype ownership model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org40fe21a">3.1.73. Implement dependencies in terms of new physical types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2039070">3.1.74. Top-level "inclusion required" should be "tribool"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbb0e9d9">3.1.75. Implement meta-name validator correctly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1f724bd">3.1.76. Update archetype generator to handle decoration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgba3268e">3.1.77. Create a logical meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6bab357">3.1.78. Add file extensions to decoration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgccaac0e">3.1.79. Move decoration to <code>text</code> model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org330c117">3.1.80. Consider creating a label for generated files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org944fb51">3.1.81. Replace initialisers with facet-based initialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org54c4545">3.1.82. Injector types with regards to containment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4e218fa">3.1.83. Mine the build2 layout terminology&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdccaeb9">3.1.84. Make physical model name a qualified name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8d0b089">3.1.85. Add a PMM enablement satisfiability transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6ed1ab7">3.1.86. Add a PM enablement satisfiability transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge3a5ba0">3.1.87. KVPs with invalid field name still works&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0674ac5">3.1.88. Add a PM transform to prune disabled artefacts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org52c8f56">3.1.89. Add primitives to feature selector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb5b4bf4">3.1.90. Add the notion of a major and a minor technical space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgab722bb">3.1.91. Add documentation to archetypes headers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org08e7aa4">3.1.92. Associate git details with components&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org85af324">3.1.93. Consider modeling primitive value as attribute&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org100cb08">3.1.94. Add the ability to cast an enum to the underlying type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8c8b25a">3.1.95. Add <code>enum</code> size constant for all enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org61b38ce">3.1.96. Improve referencing status&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8c62d03">3.1.97. Consider renaming <code>wale</code> to <code>mustache</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a036a5">3.1.98. Merging of collections does not overwrite keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge11449a">3.1.99. Referability and logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org646b28e">3.1.100. Remove empty tracing directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2b1ad41">3.1.101. Split enablement features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2fe00d6">3.1.102. Dimension vs view vs perspective&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org56852f7">3.1.103. Private and public includes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org08e3dea">3.1.104. Associate includes with model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7dcca98">3.1.105. Simplify the get for optional features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8d1dfe0">3.1.106. Enable logging in unit tests from the environment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org09cb4ac">3.1.107. Name clashes between generated code and non-generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcd9167b">3.1.108. Conversion does not validate missing options&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org10f6a0d">3.1.109. Cross-compilation for all targets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaa6e04e">3.1.110. Merge visitor with object&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6474b1d">3.1.111. Consider creating meta-types for transform, chain and context&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org72abbdd">3.1.112. Consider creating a container for profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org17df1e3">3.1.113. Consider creating a container for features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org87b87f3">3.1.114. Allow convert output to <code>std_out</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd547428">3.1.115. Consider creating a org-mode based tracing format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5da5f35">3.1.116. Consider allowing representation of namespaces in file names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5a13d0e">3.1.117. Handling of model name is incorrect&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga9b13de">3.1.118. Product family projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8fc755a">3.1.119. Add enablement test in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org80fbc6a">3.1.120. Investigate goxygen's functionality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0bcb66b">3.1.121. Throw on invalid stereotypes for all model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga71b154">3.1.122. Consider adding valgrind suppressions to PDMs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfa2e38b">3.1.123. Configuration binds to element types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf600ca3">3.1.124. Consider adding cartridge M2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf4f0e63">3.1.125. Consider making a separation between userspace and masd space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga4ef38a">3.1.126. Integration of configuration and variability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgedfd59a">3.1.127. Rename main Dogen package in Debian&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9624e6d">3.1.128. Rename facets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7658a99">3.1.129. Add merging code generation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org1123746">3.1.130. Consider renaming profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org068c301">3.1.131. Consider renaming feature bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgeb88e84">3.1.132. Consider generating dependency injection code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org09f25d0">3.1.133. Formatters can only belong to one facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org57387d5">3.1.134. Model "types" and element binding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc35a74e">3.1.135. Project layout analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfd478d5">3.1.136. Consider moving compatibility mode to feature model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga4a34a6">3.1.137. Model SQL scripts as meta-model entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf26feff">3.1.138. Model lisp scripts as meta-model entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7d6730b">3.1.139. Consider adding descriptions to feature bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6aba1b9">3.1.140. Move models into the project directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgea48576">3.1.141. Add support for product skeleton generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1944d13">3.1.142. Add support for the static/dynamic pattern&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1ecda7f">3.1.143. Add additional reference directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8c665f5">3.1.144. Add version support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0443b3d">3.1.145. Allow dropping facet postfix for an element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org700c5ff">3.1.146. Add "is abstract" to profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org63c7975">3.1.147. Detect non-configurable fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org676c8c4">3.1.148. Replace variability enum mapper with lexical casts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc9c3bfb">3.1.149. Enablement problem is in the variability domain&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgae4d389">3.1.150. Invalid stereotypes outside of objects are not detected&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4b34d23">3.1.151. Setting include and source directory to empty&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgeff6eb7">3.1.152. Throw on unsupported stereotypes for specific kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org89b425b">3.1.153. Add support for multi-components in a model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0e79ed6">3.1.154. Create "opaque" kernel and element properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0a8ccf9">3.1.155. Consider creating a "variant" meta-model type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org20446b1">3.1.156. Consider changing variability value into a variant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb1230a1">3.1.157. Come up with a name for models that contain "meta-elements"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgffdb610">3.1.158. Use of binding points in profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org047bfcc">3.1.159. Investigate current implementation of the origin transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org616dc16">3.1.160. Add <code>ignore</code> meta-model element for VCS ignore files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0083770">3.1.161. Consider creating meta-entity for root module&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7db29f5">3.1.162. Handling of "derived meta-types"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc695f5a">3.1.163. Make vistor a proper meta-model element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgae157f9">3.1.164. Create a README meta-type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org70f6499">3.1.165. Schema name in ORM should be transitive&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2bde602">3.1.166. ODB pragmas not populated when schema name is not set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org68b7b2d">3.1.167. Assorted improvements to CMake files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf32bb4d">3.1.168. Support for cmake components and groups&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org39c0f09">3.1.169. Warn on transitive references to models used directly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org061c05d">3.1.170. Mapping of third-party dependencies (PDMs)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org494644e">3.1.171. Add support for object templates that work cross-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcdd2dba">3.1.172. Rename validators to checkers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org32a0359">3.1.173. Add stereotypes support at the attribute level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7c332af">3.1.174. Rename types that clash with reserved keywords&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5a1af9f">3.1.175. The <code>types</code> facet should always be on&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0d74e6f">3.1.176. Improving use of exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org44c7a05">3.1.177. Attributes versus properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf139815">3.1.178. Replace boost property tree with real JSON support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org09a5ff0">3.1.179. Handling of inclusion constants needs reviewing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4fdc5d4">3.1.180. Consider adding an indent JSON transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orged463f3">3.1.181. Update copyright notices&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org481db5a">3.1.182. Remove empty default values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org978e2bf">3.1.183. Add logging support to generated tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0fc8e95">3.1.184. Move ORM camel-case and databases into assets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#org09f14dd">3.2. Feature Heap</a>
<ul>
<li><a href="#org2842c1b">3.2.1. Licence compatibility errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reviewing">reviewing</span>&#xa0;<span class="story">story</span></span></a></li>
<li><a href="#orgd9bf6b5">3.2.2. Add support for operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1072ff6">3.2.3. Add stereotype for IoC containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org188b556">3.2.4. Primitives are not comparable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4d8522a">3.2.5. Exception classes should allow inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga5bace1">3.2.6. Add ORM type mapping support to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org851c90e">3.2.7. Allow stereotypes in object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaab1b57">3.2.8. Keep track of which transforms touch which elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc3a3080">3.2.9. Allow property level bindings to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org43df0fb">3.2.10. Default model modules from filename&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9dc95a6">3.2.11. Handcrafted templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org06603b4">3.2.12. Make use of association relationships&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb5df3df">3.2.13. Consider allowing UML inheritance of object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org158ade9">3.2.14. Consider inheriting annotations and stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org86163e1">3.2.15. Consider creating shared pointer typedefs for leaves&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org420fd2c">3.2.16. Getter by reference of pointee&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge25d803">3.2.17. Consider adding stereotypes into profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a8edcb">3.2.18. Consider adding "deprecated feature names"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfb44e5a">3.2.19. Add string view to dogen exception constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a20a50">3.2.20. Mask sensitive fields in io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge4c6a41">3.2.21. Add models for executables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org046552a">3.2.22. Support for multiple "generation strategies"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org23ba875">3.2.23. Additional extraction model post-processing chain transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org965224f">3.2.24. Consider adding collections at the meta-model level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org860dede">3.2.25. Add support for "directory mode" in conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdbbe3e8">3.2.26. Add model sources and sinks in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgac57983">3.2.27. Generate a single type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org227a1b6">3.2.28. Add aliases to enumeration string conversions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8df6c96">3.2.29. Consider adding a <code>to_string</code> facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org446974c">3.2.30. Consider extending lexical casts, <code>to_string</code> to any type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb2821b9">3.2.31. Add support for ignoring types and models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf859284">3.2.32. Consider making fully generated files read-only&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfcb832f">3.2.33. Pre-includes defines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge3044f7">3.2.34. Add support for inlining&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc54f6da">3.2.35. Create org-mode documentation for <code>cli</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga86ef03">3.2.36. Consider generating program options code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga242d9f">3.2.37. Code-generate a "one-shot" serialisation API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb2dfdcd">3.2.38. Add visibility to coding attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org958e199">3.2.39. Add support for default values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1b5eae6">3.2.40. Add support for interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org8f76fae">3.2.41. Add support for private and protected attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb08cf17">3.2.42. Add support for error info augmenting of exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org28a02a0">3.2.43. Add support for deprecation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#org22240b5">3.3. Technical debt and refactoring</a>
<ul>
<li><a href="#org03c2472">3.3.1. Detect duplicate attributes via validator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge966161">3.3.2. Use GCC to code generate tests in nightly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga6de62a">3.3.3. Do not throw when getting attribute value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2d40163">3.3.4. Resolution needs to segment names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5a113c4">3.3.5. Rewrite name resolution in terms of lists&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0406ea9">3.3.6. Create tests for variability overrides&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9bc658c">3.3.7. Simplify implementation of boost serialisation registrar&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfa4c9b1">3.3.8. Merging of profiles and configurations is non-intuitive&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org30c4e2f">3.3.9. Handling of forward declarations on generated types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3a14725">3.3.10. Add "is abstract" to assets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org96a5a52">3.3.11. Implement CLI configuration validator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2ee9e1e">3.3.12. Create a theme for element colours based on an algorithm&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org760cc8b">3.3.13. Improve error messages for mistakes in meta-data enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4b100e1">3.3.14. Tracing backend is not defaulted&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reviewing">reviewing</span>&#xa0;<span class="story">story</span></span></a></li>
<li><a href="#org428b420">3.3.15. Naming of DLL entry point does not follow existing convention&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc6fed32">3.3.16. Boost test module is named after the entity&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2e225c1">3.3.17. Use profile overrides reduce the number of test models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org85a530f">3.3.18. Improve error message for missing files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb8e4122">3.3.19. Add "structural" to structural stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge0acbb6">3.3.20. Mop-up nested namespaces using legacy syntax&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd078179">3.3.21. Tidy-up profile names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbd0215d">3.3.22. Add inheritance via meta-data to profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgee4d43c">3.3.23. Consider renaming <code>origin_types</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org673474e">3.3.24. Consider merging all "registrar-like" entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1d4e613">3.3.25. Code generation of registrars for static registration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd7298ac">3.3.26. Update the MASD UML profile to reflect the latest changes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5e657d7">3.3.27. Update all exception names to match framework guiidelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org035a724">3.3.28. Fix pictures in old release notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org24eb537">3.3.29. Current implementation of vcxproj has many problems&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5574698">3.3.30. Create a meta-model mapping type for ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org02d37e4">3.3.31. Improve handling of stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga8a3768">3.3.32. Single reporting format option&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd978172">3.3.33. Clean up injection element properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf57320d">3.3.34. Multiple entries of the same key is invalid in JSON&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfb3101e">3.3.35. Check if enable kernel directories is on extraction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org03531c7">3.3.36. Add additional checks in generation formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org55cc64d">3.3.37. Operations to add when we have code merging support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org766a6e6">3.3.38. Shared pointers have getters and setters with references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2933a7e">3.3.39. Improve LAM test models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org48adb4a">3.3.40. Create an element builder&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org70d86b5">3.3.41. Improve model mapping support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org37ecf49">3.3.42. Improve resolution errors when user fails to reference model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4474b9f">3.3.43. Move to .net core in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org98325db">3.3.44. Use C# notation in JSON C# models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9f3041d">3.3.45. Consider renaming LAM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgabf90d7">3.3.46. Remove empty types in <code>=injection.json</code> models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org28ccbfa">3.3.47. Consider creating top level exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org90a8db3">3.3.48. Add dependency checks to transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3091616">3.3.49. Modeling elements should not have <code>profile</code> setup&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4109369">3.3.50. Profile overriding may cause link errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2e302a3">3.3.51. References to ODB types in different namespaces fails&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org99b691f">3.3.52. Schema name propagation is not handled correctly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8d3e15c">3.3.53. Test ORM support for table name and column name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a47916">3.3.54. Conversion does not output static stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga5e52e3">3.3.55. Colours test model is invalid at present&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5febe83">3.3.56. Copyright holders is scalar when it should be an array&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org390d8d4">3.3.57. Check support for decoration configuration overrides&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd577dbb">3.3.58. Location of <code>--byproduct-directory</code> not respected on conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc703680">3.3.59. Generated tests fail when model has nothing to test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org329005f">3.3.60. Add meta-data to "force" parent&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge221c92">3.3.61. <code>CMakeFiles</code> do not reference dogen models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0dbf46d">3.3.62. Cannot create classes with pointers to base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbaec8df">3.3.63. Detect unqualified stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga9a8f46">3.3.64. Using <code>std::set&lt;std::string&gt;</code> causes compilation errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org97c8cbf">3.3.65. Line endings could cause rewrites&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org22e5b82">3.3.66. Character member variables are not tidied up on io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfd1d610">3.3.67. Lists of strings are not properly tidied up on io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org68d7037">3.3.68. Use of disabled facets in non-generatable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4d18a83">3.3.69. Type with the same name as the project does not compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0dea965">3.3.70. Allow for generation of class with the same name as package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2741a84">3.3.71. Partial matching of built-ins doesn't work for certain types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0ad6b2b">3.3.72. Returning optional of base class results in invalid code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgca8e956">3.3.73. Investigate current support for <code>std::set</code> and <code>std::map</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3b123e3">3.3.74. Format doubles, floats and bools properly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb709ebb">3.3.75. Private properties should be ignored&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1b71b8e">3.3.76. Identifiable needs to use camel case in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc44ee1d">3.3.77. Inserter for enumerations shouldn't throw&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf6fdc3f">3.3.78. Assignment operator seems to pass types by value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0957a21">3.3.79. Shared pointer to vector fails to build&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb458e4a">3.3.80. Add tests for immutability on an inheritance tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8d4dea9">3.3.81. Equality in floating point numbers is incorrect&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8448495">3.3.82. Fix northwind tests on OSX and Windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga2af136">3.3.83. Do not output JSON markers for primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0910ebb">3.3.84. Parent without descendants in current model errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgef98164">3.3.85. C# inheritance requires ordering&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb552bb6">3.3.86. Add meta-data to trigger inclusion/generation of <code>stdafx</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfdb5865">3.3.87. Immutable types cannot be owned by mutable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd5fe319">3.3.88. Add DateTime and related types to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8293f6e">3.3.89. Using underscores with C# results in invalid code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf1b91cb">3.3.90. Not setting output language results in weird errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc525f06">3.3.91. Add cross-model support to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1477177">3.3.92. Do not include algorithm if swap is disabled&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge23f73c">3.3.93. Multiple inheritance and profiles do not work predictably&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org82415bb">3.3.94. Reference to non-existent features produce unhelpful errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga6030d5">3.3.95. Using <code>std::unordered_map&lt;my_enum, ...&gt;</code> fails equality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9218b4c">3.3.96. Recursive structures result in crashes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org67e6f43">3.3.97. Hydrators provide no context when errors occur&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org58fd6c8">3.3.98. Using types of non-referenced models produces bad error messages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc20b00a">3.3.99. Improve error messages on empty meta-data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7682248">3.3.100. Improve error message for blank types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org281c9bd">3.3.101. Error in log files when reading in Dia model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3224a2b">3.3.102. Improve error messages for unconnected objects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3df49e7">3.3.103. Code coverage does not work for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7bbf53e">3.3.104. ODB linking is incorrect for generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org91971f4">3.3.105. Inheriting from oneself causes segfault&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf767fe5">3.3.106. Nested external model path results in strange references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbdbf061">3.3.107. Facet enablement and model references is buggy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd32bf01">3.3.108. Serialisation support for C++-11 specific containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org52e8072">3.3.109. Shared pointers to built-in types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org135decd">3.3.110. Generate ORM tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2de8e1e">3.3.111. Add warning for unused references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7326263">3.3.112. Additional validation rules for coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org39d3dc3">3.3.113. Report validation errors like compilers do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgda79b46">3.3.114. Check for incompatibility between input language and kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org99adef0">3.3.115. Improve comments on reference implementation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org83957fe">3.3.116. Spirit: Improve error reporting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org77a17fa">3.3.117. Spirit: replace the legacy parser with the Klaus parser&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org456ed59">3.3.118. Spirit: Add support for "native" arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga278daf">3.3.119. Add test with smart pointer in base class&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0574d77">3.3.120. Improve error reporting around JSON&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6fa842d">3.3.121. Failed facet dependencies should be treated as errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org01186b5">3.3.122. Ensure an error info tag is not set already before we set it&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb15c229">3.3.123. Add more validation to stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgda72507">3.3.124. Add tests for external and model modules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5d92a08">3.3.125. Add test for parent with no derived classes on the same model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org91a290e">3.3.126. Add tests to inheritance test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf606494">3.3.127. Add tests to association model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd338ca8">3.3.128. Add tests to identifier parser with invalid names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0f1cb1f">3.3.129. Add tests for empty objects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2e5d9ad">3.3.130. Cross package referencing tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1e907af">3.3.131. Add test model for disabling XML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org13f21f9">3.3.132. Add tests for disconnected connections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb4c0b82">3.3.133. Add run spec targets for each test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb4b7835">3.3.134. Add specification comments to tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8c0eb4c">3.3.135. Create model with invalid built-in type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#orga8e28aa">3.4. Infrastructure</a>
<ul>
<li><a href="#org466ad7f">3.4.1. Update the contributing to dogen doco&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org866a1ba">3.4.2. Test cases show up as zero in report.ci&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6528b7a">3.4.3. Upload release to github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb8a8efc">3.4.4. Consider adding support for kcov&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org14aaf39">3.4.5. Add support for stack traces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org93d041e">3.4.6. Consider adding <code>ClangBuildAnalyzer</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org364eceb">3.4.7. Add new c++ warnings to compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6c7dd5b">3.4.8. Investigate <code>modern-cpp-template</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6f711e7">3.4.9. Run ODB on nightlies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge78d639">3.4.10. Check OSX packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6159b8e">3.4.11. Move from doxygen to standardese&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org50c66d8">3.4.12. Build dogen from docker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5d0746d">3.4.13. Create a docker image for builds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgab28b70">3.4.14. Linux and OSX binaries are not stripped&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc478a3f">3.4.15. Code coverage does not include odb files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1af5ca9">3.4.16. Investigate the emblems used by Bit7z&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org887091f">3.4.17. Mine <code>common-universal-cmake</code> for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1791233">4. V3 Release</a>
<ul>
<li><a href="#org9db674e">4.1. Candidates</a>
<ul>
<li><a href="#orgbd35dae">4.1.1. Add support for SPDX licences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org12696f9">4.1.2. Tight integration of Dogen and <code>build2</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd88ba87">4.1.3. Tighter vcpkg integration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf5b6521">4.1.4. Tighter integration of Dogen and Emacs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0710545">4.1.5. User interface generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org4fdffcd">4.1.6. Investigate support for automatic model updates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgda8a8b7">4.1.7. Code generation as a service&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org4590a3c">4.1.8. Consider replacing out libxml bindings with RapidXML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9828382">4.1.9. Implement wale in terms of existing template libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfc07e28">4.1.10. Org-mode schemas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3e4374b">4.1.11. Dogen Modeling Studio&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org998d5d1">4.1.12. dogen as a github integration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8bf5da3">4.1.13. LSP as a form of roundtrip support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org53fdf3f">4.1.14. LSP damemon for Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org13700e3">4.1.15. Dogen studio: builds and binaries for users&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcbbbb3f">4.1.16. Add support for element renaming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1bc0382">4.1.17. Consider C++ itself as a front-end&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf4dc8bf">4.1.18. Consider compiling generated code with clang&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org564b191">4.1.19. Compile stitch template output with clang&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org99d1fea">4.1.20. Splitting facets out of a component&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb2ddde7">5. Future Releases</a>
<ul>
<li><a href="#org9b4a8fd">5.1. Technical debt</a>
<ul>
<li><a href="#org63ab8a3">5.1.1. Create a test model with SHA1 hash in generation marker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org43eba65">5.1.2. Logging at info is very messy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8dddfeb">5.1.3. Check all of the dogen warnings in lgtm&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge6b6e11">5.1.4. Convert utility exceptions into dogen exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org972380f">5.1.5. Change order of includes according to Lakos major design rule&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf877863">5.1.6. Consider making <code>disabled</code> a trace/log level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf6f786e">5.1.7. Consider renaming log level <code>trace</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb1658d2">5.1.8. Consider replacing the associations against object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org641c0b1">5.1.9. Use DI in injection model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7efb7f9">5.1.10. Use <code>std::filesystem</code> instead of <code>boost::filesystem</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2a12961">5.1.11. Use <code>std::shared_ptr</code> instead of <code>boost::shared_ptr</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org57721ab">5.1.12. Consider renaming <code>object</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9954659">5.1.13. Cross-model transformations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf7baf8f">5.1.14. Add support for "ad-hoc" tracing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org74ec36c">5.1.15. Split registrar into two classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf52f939">5.1.16. Use element ids for associations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf3958be">5.1.17. Tidy-up "is floating point"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6d73eee">5.1.18. Benchmarks do not work for utility tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfe31ed8">5.1.19. Clean up comment formatter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org793b665">5.1.20. Language namespaces and modeling element locations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4c76d5c">5.1.21. Rename formatting assistant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6e8e5ce">5.1.22. Remove unused elements from logical model's final model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga5ce588">5.1.23. Model should contain set of built-in id's&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org54aca00">5.1.24. Identifier parser has hard-coded built-ins&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6c69237">5.1.25. <code>always_in_heap</code> is not a very good name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org81864f5">5.1.26. "current" is not the best of names in name tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcfc460e">5.1.27. Rename methods parsing name trees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge433afa">5.1.28. Create utility methods for <code>__type__</code> etc&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge599aee">5.1.29. Improve container details in JSON dump&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbedbc7f">5.1.30. Consider removing filtering ostream&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org065ac71">5.1.31. Sequences that support multiple postfixes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org44af3ac">5.1.32. Attribute types are always fully qualified&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6261460">5.1.33. Using default value with text collection throws&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfe7ade9">5.1.34. Perform lexical casts once only for error reporting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge92654e">5.1.35. Consider moving the mock factories into the test<sub>data</sub> directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org28041c3">5.1.36. Use consistently the American spelling for license&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbdd8e73">5.1.37. Clean up coding resolver tests by extending mock factory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgec00bc1">5.1.38. Refactor coding mock factory method names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org266017a">5.1.39. Validate assets mock factory on its own tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaa02b8f">5.1.40. Split floating point stream settings from double&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org98cf732">5.1.41. Split is floating point like from int like in view model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org736849d">5.1.42. Inline comments in <code>comment_formatter</code> are a hack&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc158025">5.1.43. Assignment operator should be protected in ABC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb5fd8b7">5.1.44. Full constructor parameter comments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org22c805f">5.1.45. Header only models shall not generate projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a8be87">5.1.46. IO header could depend on types forward declaration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7f9ea9f">5.1.47. Improve streaming of empty expressions in stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org369720a">5.1.48. Rename sequence formatter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org54ebb19">5.1.49. Create more "utility" members for formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgd7a2e27">5.1.50. Investigate the integration of <code>boost::log</code> with throw exception&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7f9ed25">5.1.51. Change stitch's standard control block start marker to match t4&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgecb3814">5.1.52. Improve stitch's processing of inline statements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc9928eb">5.1.53. Consider moving <code>add_model_module</code> to flags&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfa781eb">5.1.54. Add a configuration class to logical model's mock factory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org520a5e5">5.1.55. Consider using boost pointer container for formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgba20554">5.1.56. Clean up stitch terminology using markup fundamentals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb3394df">5.1.57. Consider adding stitch support for class feature control blocks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#orgdc74ce9">5.2. Unclassified</a>
<ul>
<li><a href="#org3d7bb1f">5.2.1. Handling empty primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org77c2d9c">5.2.2. Add equals operator to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge1d0a45">5.2.3. Org-mode and rountripping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#orgb7c1f77">5.3. Injection</a></li>
<li><a href="#org0a55f85">5.4. Logical Model</a></li>
<li><a href="#org5abcd4a">5.5. Extraction</a></li>
<li><a href="#orgb578006">5.6. Feature Heap</a>
<ul>
<li><a href="#org5178aca">5.6.1. Consider using PMR strings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgec8be6f">5.6.2. Consider adding attributes to meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0d06cc8">5.6.3. Consider making conversions a generation concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdb1e783">5.6.4. Consider generating model generation tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7a07462">5.6.5. Consider computing hashes only once for immutable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org80e712b">5.6.6. Dump transforms as serialisable data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org863a415">5.6.7. Add a new annotation type of "pair"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1951a71">5.6.8. Add support for "colour themes" to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org66d3790">5.6.9. Consider adding inheritance support to modelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc8a1819">5.6.10. Create a mock factory facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9a91249">5.6.11. Consider making editor a meta-data element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1e02c0a">5.6.12. Add support for multiple profile binds per modeling element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfff5bae">5.6.13. Consider adding text transform details to generation marker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org55926e1">5.6.14. Add a "info" activity to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org706c75b">5.6.15. Allow user supplied enumerator values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgceb75a5">5.6.16. Consider adding support for JWT&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc39a04a">5.6.17. Investigate the uses of <code>nameOf</code> in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdb4e265">5.6.18. Consider adding support for secure string&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf2f592c">5.6.19. Update static strings to string views&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1764da0">5.6.20. Add string view to dogen exception constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org206470a">5.6.21. Add support for the "badge" pattern&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1ac7278">5.6.22. Add support for <code>fixed_storage_arrays</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1d8a282">5.6.23. Consider exceptions with stream to build exception message&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd0eee8a">5.6.24. Add support for proper JSON serialisation in C++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3451596">5.6.25. Consider adding support for Hypothesis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1d1337c">5.6.26. Investigate <code>machine.specifications</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org36e88ee">5.6.27. Finish adding support for Language Agnostic Models (LAM)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb02c50e">5.6.28. Add support for "naming rules"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2a5c798">5.6.29. Add knobs to control output of constructors and operators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org881ec21">5.6.30. Add support for type<sub>index</sub>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0c194d2">5.6.31. Support only specific attributes for certain facets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2504a97">5.6.32. Consider supporting non-boost exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2efbab7">5.6.33. Serialisable and ioable exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf48998e">5.6.34. Use error codes in exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga057e6e">5.6.35. Control the emission of pragma once with meta-data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org597e5b2">5.6.36. Consider adding <code>with</code> support for fluent properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org18eaf4b">5.6.37. Consider creating a netty like builder for fluency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb92f6c3">5.6.38. Make test data generator more configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6e038e8">5.6.39. Use coroutines in test data generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbf635c3">5.6.40. Add support for <code>std::forward_list</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc74ca3c">5.6.41. Add support for boost and/or std tuple&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge75adcd">5.6.42. Add support for posix<sub>time</sub><sub>zone</sub>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdfb39e0">5.6.43. Add support for structs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaf7ca0f">5.6.44. Code generate C# models using msbuild&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb7ebc30">5.6.45. Add support for package installation scripts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2dde47c">5.6.46. Consider adding support for iguana&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org130ef4d">5.6.47. Consider adding support for ormpp&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6861699">5.6.48. Consider adding support for Apache Arrow IPC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org17f4ba4">5.6.49. Consider adding C#/C++ attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3f0e0c1">5.6.50. Consider adding a swagger frontend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org72eeb2c">5.6.51. Factory method instead of complete constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga545501">5.6.52. Null assertion on pointers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org25c6297">5.6.53. Add support for primitive validation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgac3a5f0">5.6.54. Add test data "types" for generated data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcba7220">5.6.55. Add support for RPC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgea63f06">5.6.56. Add support for dependency graphs and complexity data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2fa516d">5.6.57. Add support for configuration as environment variables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd247f18">5.6.58. Consider adding support for SBE&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9b901c9">5.6.59. Consider adding support for magic enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org40f826c">5.6.60. Consider adding support for the <code>enum.hpp</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org176adf4">5.6.61. Consider adding support for Meta Enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6cc1057">5.6.62. Consider adding support for Better Enums library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga1ea1a3">5.6.63. Consider adding support for FWK enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgde9c1ae">5.6.64. Consider adding support for bitsery serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org816de89">5.6.65. Consider adding support for the spaceship operator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7257fcb">5.6.66. Consider adding support for OutOfLine&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5620c7b">5.6.67. Consider adding support for GraphQL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7448547">5.6.68. Consider adding support for compile time mocking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9699583">5.6.69. Consider integrating a sqitch like approach&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc346ee1">5.6.70. Add support for entity framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbc68a92">5.6.71. Add dogen specific binary serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4cc4359">5.6.72. Add support for MARISA&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbdd2f11">5.6.73. Consider using Boost.PolyCollection in model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org28c66b9">5.6.74. Add support for units&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9b752a1">5.6.75. Add support for boost UUID&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org164f9fc">5.6.76. Add support for object cloning&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb87a7f6">5.6.77. Add support for boost pointer container&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6630db2">5.6.78. Use pointer container&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd18ca62">5.6.79. Add support to foreign keys in ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4774f82">5.6.80. Add column name support to ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2eca98f">5.6.81. Allow users to override string prefixes in test data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfba41e0">5.6.82. Add a top-level "Visual Studio" knob&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8f044ca">5.6.83. Add support for Visual Studio C++ projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5c8dbd5">5.6.84. Add support for exports on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org195993b">5.6.85. Add export macros support for Linux&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8dd26cd">5.6.86. Add <code>targetver.h</code> support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcf7914a">5.6.87. Add support for DLL Main on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdb2636f">5.6.88. Add support for pre-compiled headers on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org322332e">5.6.89. Add case conversion support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3054955">5.6.90. Add support for generic container types to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbae1664">5.6.91. Add support for nullable built-ins and primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2ba80fd">5.6.92. Add auxiliary function properties to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org368b8df">5.6.93. Add internal object dumper resolution in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org558802c">5.6.94. Add support for boxed types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org390770a">5.6.95. Add handcrafted class to C# test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb4fac9e">5.6.96. Add support for native arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgea00a21">5.6.97. Add fluency support for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4361c0b">5.6.98. Add visitor support to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0111544">5.6.99. Generate benchmarking code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1d7c208">5.6.100. Remove existing benchmark infrastructure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org89538bf">5.6.101. Consider using a benchmarking framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1e3e861">5.6.102. Generate AssemblyInfo in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org35a5988">5.6.103. Consider adding a clone method for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org185b02f">5.6.104. Consider making the output directory configurable in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org445a2c0">5.6.105. Add code generation support for importing nuget libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga06e3da">5.6.106. Add feature to disable regions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org60743bf">5.6.107. Add parameters for using imported assemblies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org90d9ff5">5.6.108. Add msbuild target for C# test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgffba6f7">5.6.109. Add visibility to coding elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0143834">5.6.110. Add partial element support to coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org24f2045">5.6.111. Add final support in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org35c442f">5.6.112. Add aspects for C# serialisation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6119932">5.6.113. Add support for cross-language LAM serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5a3bee5">5.6.114. Consider adding stereotype of noncopyable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbfcd3dd">5.6.115. Add support for thrift and protocol buffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org0bf43d4">5.6.116. Add support for flatbuffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf3b8a2a">5.6.117. Add support for BSON serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org62802f9">5.6.118. Add support for Decimal numbers in C++ and C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5e35bf8">5.6.119. Add depth detection to io in C++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org33dec21">5.6.120. Use clang format in physical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd2a8053">5.6.121. Add an injector for visual studio models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org79d799f">5.6.122. Add an injector for ArgoUML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org819ff32">5.6.123. Add support for "capitalisation theming"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3932a2f">5.6.124. Add support for clang format configurations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf17462f">5.6.125. Add support for object caches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org406d8aa">5.6.126. Generate Redis get/set code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgae53565">5.6.127. Add support for libnop&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb298589">5.6.128. Add boost variant visitors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2f45ff3">5.6.129. Add support for disabling unique filenames&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga87723a">5.6.130. Create a map between UML/MOF terminology and yarn&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orga8754a8">5.6.131. Investigate boost log config files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd43fb48">5.6.132. Create a PDM for the utility model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org86e2c84">5.6.133. Concepts, immutability and fluency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org48d91d7">5.6.134. Create an interface for the text reader&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbbb0bda">5.6.135. Adding types to package namespace&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9a55d5f">5.6.136. Add support for inner classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0b39695">5.6.137. Consider adding support for inline hashing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org2b41019">5.6.138. Consider making header guards configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org719b978">5.6.139. Consider adding facet specific types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgb08656b">5.6.140. Control JSON output via traits&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8ad1290">5.6.141. Add support for user defined literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org211f009">5.6.142. Modeling of visitors in <code>cpp</code> can be improved&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org262342b">5.6.143. Move <code>invalid</code> value to a different value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6744398">5.6.144. Allow renaming <code>invalid</code> enumerator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org472a84f">5.6.145. Allow non-throwing casts for enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org92493e2">5.6.146. Consider adding a better enum representation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbb34528">5.6.147. Bitmask enumeration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf524463">5.6.148. Support for file level comments via annotations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org52cbf93">5.6.149. Add getter and setter prefixes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org25ba0f0">5.6.150. Add support for boost concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org978da85">5.6.151. Add documentation for concepts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2e6253b">5.6.152. Consider adding support for keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org02d6eb5">5.6.153. Add versioning support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc404877">5.6.154. Add support for boost parameter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3f3aa94">5.6.155. Add composite stereotype&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org922bb19">5.6.156. Add support for bitsets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2679774">5.6.157. Add string table support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org84b6eda">5.6.158. Enumeration string conversion could be configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org70e8c9a">5.6.159. Enumeration string dumps could be configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org13aa0f6">5.6.160. Add is comparable to coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6162ac7">5.6.161. Add support for type framing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org996fc2f">5.6.162. Add pimpl support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2d3eaab">5.6.163. Manual typedef generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgff8511d">5.6.164. Automatic typedef generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org12dc46d">5.6.165. Add support for iterable enumerations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1b0c82a">5.6.166. Add support for enumeration subsets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3ffb028">5.6.167. Add support for load testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1062840">5.6.168. Add support for user supplied test data sets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0895f79">5.6.169. Add support for <code>std::function</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org720a2b6">5.6.170. Add support for references and pointers to types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgafe9bb7">5.6.171. Add support for immutable attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8bf0d8a">5.6.172. Add support for static attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org471bbcf">5.6.173. Immutable static attributes and inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga0947b1">5.6.174. Shared pointers as keys in associative containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc49aa18">5.6.175. Add support for <code>smartref</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1043cf8">5.6.176. Add support for MetaStuff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5420557">5.6.177. Add support for Franca IDL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0ae5f5f">5.6.178. Add support for D-Bus&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8c18373">5.6.179. Add support for Asio uring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0688f4b">5.6.180. Add support for Microsoft Bond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org6b3bd22">5.6.181. Add support for Aeron&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge209435">5.6.182. Consider adding support for Boost.Operators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5e34fe1">5.6.183. Support for COM/CORBA&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org4a84632">5.6.184. Support for pretty printing libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#orgf34f249">5.7. Miscellaneous</a>
<ul>
<li><a href="#org69955a7">5.7.1. Consider cross-platform building&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga632296">5.7.2. Log file per transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4a26671">5.7.3. Consider adding pre-commit hooks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgee0c4f1">5.7.4. Add fuzzing tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org777f6f7">5.7.5. Updates to debian package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7d37da6">5.7.6. Add stitch section in manual&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb6a79c6">5.7.7. Diagrams used in manual should be in docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcf53b30">5.7.8. Tidy-up dogen windows package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb422cc4">5.7.9. Add project documentation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga24f144">5.7.10. Create a <code>ci</code> folder in build&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc8fe49d">5.7.11. Fix issues with bintray windows uploads&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7384b8b">5.7.12. Add support for ODB schema version&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8154916">5.7.13. Add proper DEB support to bintray&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org339b566">5.7.14. Add scripts to sanity check packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf229fdb">5.7.15. Consider adding profiling support via build type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org03f2d73">5.7.16. Add support for coverity analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5957f60">5.7.17. Link against boost dynamic libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3f88c81">5.7.18. Enable doxygen warnings for all undocumented code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge6da007">5.7.19. Self-contained build files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org525a915">5.7.20. Remove calls to unix utilities directly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org61325df">5.7.21. Detect the presence of the diff command&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3f09d20">5.7.22. Installable package names should follow a well-known convention&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6ff16dd">5.7.23. Allow user to choose whether to build shared or static libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org86378c9">5.7.24. Migrate from Boost Test to Catch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8f42521">5.7.25. Add a GitHub page for Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4f04f7c">5.7.26. Add Doxygen docs to GitHub page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfe5af14">5.7.27. Add vagrant and docker support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org02424fe">5.7.28. Use clang format to format the code base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5ca7e8c">5.7.29. Consider adding an emblem for clang's analysis checks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org11b9b66">5.7.30. Consider adding nuget support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7e2c049">5.7.31. Consider hosting documentation in read the docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5ae7aee">5.7.32. Consider adding support for clang-tidy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5f2fd7c">5.7.33. Add support for the <code>scan-build</code> static analyser&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org216187a">5.7.34. Add support for iwyu&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9b739c3">5.7.35. Add support for clang sanitizers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaa7c42a">5.7.36. Add support for CPPCheck&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbab3ab4">5.7.37. Create a demo of installing dogen and generating hello world&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org75d9924">5.7.38. Mine MongoDB Smasher for test data ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org921ec8d">5.7.39. Write blog post on reflexive programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgacbeaa7">5.7.40. Read A Concept Design for the STL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
<li><a href="#orgb267b2d">5.8. Visionary</a>
<ul>
<li><a href="#org9fb57f4">5.8.1. Investigate integrating HTM with dogen</a></li>
<li><a href="#orgf5edf01">5.8.2. Add support for digests</a></li>
<li><a href="#orgeda3e11">5.8.3. Consider adding support for scheduling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5f7d454">5.8.4. Consider adding support for <code>cpp-equiv</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8a8a11e">5.8.5. Consider adding support for trees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0a657d1">5.8.6. Consider adding support for <code>libvineyard</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9d31b60">5.8.7. org-block extras&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfede444">5.8.8. Investigate <code>ganja.js</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6a52d7a">5.8.9. Investigate adding support for unity builds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga6dbfc5">5.8.10. Consider adding support for replxx&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge8ea42e">5.8.11. Consider adding support for rocksdb&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga1d65d5">5.8.12. Consider adding support for typesense&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdcb59af">5.8.13. Consider adding support for snowflake&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org77ee9b0">5.8.14. Consider moving to <code>PEGTL</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org62ecef5">5.8.15. Consider integrating with <code>NN-512</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9d56cfc">5.8.16. Investigate <code>refureku</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbe5e0fe">5.8.17. Investigate <code>kodgen</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org19babfd">5.8.18. Investigate cookietemple project templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org37b3583">5.8.19. Consider adding support for <code>repr</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7771b34">5.8.20. Product based operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2bb1132">5.8.21. Integration of <code>vcpkg</code> and <code>build2</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf16d806">5.8.22. Investigate build time library configuration post&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc35e62e">5.8.23. Investigate CG-SQL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org85cc302">5.8.24. AWS boilerplate generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5cea1fa">5.8.25. MDE links and information&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org04cc743">5.8.26. Org-mode integration with modeling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc885b2d">5.8.27. Investigate telosys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org29d1cd9">5.8.28. Consider allowing users to create their own parts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc7b00b5">5.8.29. Check RedHat guidelines on release notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org00a9b3a">5.8.30. Add support for CBadge&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1e61cbf">5.8.31. Consider adding support for <code>libcudacxx</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga17d357">5.8.32. Consider adding <code>using</code> statements to models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb05cb0a">5.8.33. Consider creating wrappers for containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga5dfe2f">5.8.34. Consider adding support for Matplot++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8def7aa">5.8.35. Consider adding support for Crypto3&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdd58ffa">5.8.36. Consider adding support for libstud-json&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8b2a96c">5.8.37. Consider adding support for automigrate&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaaad9c7">5.8.38. Consider adding support for eCAL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdbbc5a1">5.8.39. AutoMapper in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9ad0e22">5.8.40. Consider adding support for aspects in logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org67d3d80">5.8.41. Consider adding support for static site generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9fe75cb">5.8.42. Consider adding support for cpprouter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org172d3ee">5.8.43. Consider adding support for LogDevice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6925047">5.8.44. Improve C# primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9ef8cc6">5.8.45. Consider allowing restrictions on primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8b2336c">5.8.46. Consider adding scripts or targets for core dumping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdf9666b">5.8.47. Consider adding support for <code>zq</code> and ZNG&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc67728c">5.8.48. Consider adding support for <code>objectbox</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7442a34">5.8.49. Consider adding support for <code>libmish</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf1e1425">5.8.50. Consider adding support for gatbage collection via Oilpan&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org966ef7f">5.8.51. Add support for QR codes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3e15f16">5.8.52. Investigate SQLancer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3e48176">5.8.53. Investigate how RBAC can be integrated with Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge74b999">5.8.54. Consider adding OpenHMI support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd07d7d8">5.8.55. Consider adding AMQP support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org908f121">5.8.56. Consider supporting nano-id&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb955734">5.8.57. Consider developing a org-mode log format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0d9c344">5.8.58. Consider adding support for SignalR&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org16a1efa">5.8.59. Add support for T2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc5814ed">5.8.60. Consider making <code>stitch_template_builder</code> a text template builder&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfe5b86a">5.8.61. Consider implementing transforms as dataflow graphs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga6e748e">5.8.62. Consider adding suppot for SeqAn&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaebdb2c">5.8.63. Use static registration with initialisers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0165425">5.8.64. Consider adding a <code>--dump-stats</code> option&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org588eb02">5.8.65. Feature toggles and code generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc40f57d">5.8.66. Add support for design by contract&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org5ee922f">5.8.67. Add the the EMF purchase order examples to manual&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc6b18dd">5.8.68. Investigate CLAFER&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6323bf8">5.8.69. Consider adding a GIR/GObject injector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2d29519">5.8.70. Message replay&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgad9f5d5">5.8.71. Consider adding support for binary logging&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org03e8db0">5.8.72. Consider using command line indicators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org04ed4ce">5.8.73. Consider adding support for tabulate&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7ac3dd9">5.8.74. Consider visualisation like source trail&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgf747ce4">5.8.75. Create some basic naming guidelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2c044b4">5.8.76. Add Levenshtein distance to enums when converting from string&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9fdd87d">5.8.77. Add GraphViz/Dot export support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga0e9f2a">5.8.78. Syntax checking support for stitch templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdc4e024">5.8.79. Consider adding TableGen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4752b52">5.8.80. Consider adding support for TOML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org39ca249">5.8.81. Consider integration with GNU plot library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8b7b232">5.8.82. Consider adding JSON schemas and XSDs as an injection source&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8ee78a8">5.8.83. Consider generating SSL certificates and keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org06ce721">5.8.84. Add support for terraform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6860b22">5.8.85. Consider using ditaa&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcf8bf04">5.8.86. Consider adding a wt frontend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5cc07a8">5.8.87. Consider using typedefs for variants&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org478376e">5.8.88. Investigate if Seamless template can be used instead of stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org198491f">5.8.89. Consider adding support for OData&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgccb995e">5.8.90. Consider adding support for BERT&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge7b45ae">5.8.91. LSP daemon for MOP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org73b0280">5.8.92. Add design by contract to code-base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaf88e50">5.8.93. Improving boost test support with org-mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4d6a659">5.8.94. Consider splitting transforms into rules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb85144f">5.8.95. Create a new data-driven architecture for dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgce48674">5.8.96. Support for locations other than filesystems&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgb96abfb">5.8.97. HTTP API support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1f168ac">5.8.98. Consider generating consul service discovery code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgdf8f122">5.8.99. Grepping non-generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcd500df">5.8.100. Add support for data anonymisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org90ebcc7">5.8.101. Consider using indices rather than associative containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org292e944">5.8.102. Model Oriented Programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8e04600">5.8.103. Interactive interface to models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf02ba77">5.8.104. Consider extending stitch with ideas from Xpand/Xtend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org0c4b61b">5.8.105. Feature Models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org00285fe">5.8.106. Make more use of stack instead of heap&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd08060d">5.8.107. Add support for field renaming in annotations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org13c6d43">5.8.108. Transform tracing "coordinates"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga9fe03e">5.8.109. Add support for UML profiles and XMI&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org50f7da2">5.8.110. Reducing the overhead of other facets in types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgaab22ea">5.8.111. Model anonymiser and slicer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcd1ec5b">5.8.112. Consider adding support for the <code>fmt</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org316e223">5.8.113. Consider adding support for the <code>fast_io</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga9df34c">5.8.114. Determine types that are no longer used&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgae5ccdc">5.8.115. Overuse of <code>std::set</code>, <code>std::map</code>, etc&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbda7b3a">5.8.116. Add support for multiple kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgc7fa2d2">5.8.117. Consider adding support for OCL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4255479">5.8.118. Code generation and system configuration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc178f98">5.8.119. Supporting user defined generic types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3a091ba">5.8.120. Visitor adaptor for usage in ranges&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org48f72f4">5.8.121. Visitor with <code>std::function</code> for each <code>visit</code> method&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga6d5e12">5.8.122. Create a visitor interface with multiple implementations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3b2b6bf">5.8.123. Add targets to output manual in downloadable formats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org40dfea7">5.8.124. Investigate the possibility of creating a mock facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1af58d3">5.8.125. Investigate ribosome for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4fc1b53">5.8.126. Add support for languages available in Dia2Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org5200592">5.8.127. Generate model from database tables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4fc6946">5.8.128. Generate model from CSV files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge6df8dd">5.8.129. Generate model from Excel files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org1630244">5.8.130. Add serialisation support to and from spreadsheets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgccca3bf">5.8.131. Generate model from JSON or XML instance files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3e53306">5.8.132. Investigate GDB visualisers for generated models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgdf1fa70">5.8.133. Add memory measurements support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5d1ebfb">5.8.134. Add cling support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgd58876d">5.8.135. Consider adding support for spelling on comments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgc2904b8">5.8.136. Consider offering identifier suggestions for misspelling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orge739c0d">5.8.137. Add support for type "labels" or "tags"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0b9eca3">5.8.138. Add support for plugins&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5e631be">5.8.139. Improving test data generation via "reflection"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org4abe9e4">5.8.140. Consider using bounded integers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3d1dbb2">5.8.141. Investigate ModelQ for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org7c17542">5.8.142. Use <code>observer_ptr</code> in factory methods&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org42dc6f1">5.8.143. Consider adding XML schema as a front-end&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgf51bb80">5.8.144. XML serialisation for interoperability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orge1feb99">5.8.145. Add support for CSV serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org9a2a2b2">5.8.146. Consider generation of validators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgdadb391">5.8.147. Providing view model hints&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org364b975">5.8.148. Consider adding SWIG and Boost.Python support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgc499d6d">5.8.149. Add yuml markup language support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org71e5b5a">5.8.150. Automatic generation of C interfaces for C++ code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org05b561a">5.8.151. Improvements to Dogen's dia model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfd8d371">5.8.152. Add support for XSD tool&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgef66a80">5.8.153. Harmful workload generator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org3b8f2d2">5.8.154. Add Coherence POF serialisation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orga49dfb2">5.8.155. Generate Visual Studio solutions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org4ef967a">5.8.156. Consider adding YQL support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org3b80b26">5.8.157. Generate state diagrams&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orgfd9169f">5.8.158. Add reflection support by using model and type enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org2b3ef75">5.8.159. Add model diff support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#orga151e81">5.8.160. Add sql support to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></a></li>
<li><a href="#org965ba64">5.8.161. Consider adding support for <code>sandbox-api</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgcbf94c4">5.8.162. Consider adding support for draw.io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org6d2dbca">5.8.163. Consider adding "sidecar" service functionality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org96fb431">5.8.164. Consider generating code for RAII wrapper&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org5ce8386">5.8.165. Add jailer like functionality to ORM support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8a05c58">5.8.166. Add support for portable services&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0a95bde">5.8.167. Add support for the sobjectizer actor framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org804862d">5.8.168. Add support for the rotor actor framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org2848264">5.8.169. Add support for CAF serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgea016c2">5.8.170. Add sonar cloud checks to project&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org45da88a">5.8.171. Consider adding weaving support as a command&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgeb1ba96">5.8.172. Consider creating textual UML injectors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgfec9e4d">5.8.173. Consider implementing a "mock server" for HTTP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orga462196">5.8.174. Consider adding metrics support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#orgbbc5a14">5.8.175. Consider adding support for RAFT protocol&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org8397003">5.8.176. Consider adding support for static site generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org0a3d4cf">5.8.177. Consider adding support for Boost.Pool&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
<li><a href="#org16cb2d6">5.8.178. Unmaintained emblem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This document contains the <a href="http://www.mountaingoatsoftware.com/agile/scrum/product-backlog">product backlog</a> for Dogen.
</p>

<div id="outline-container-org31c387d" class="outline-2">
<h2 id="org31c387d"><span class="section-number-2">1</span> Product Vision</h2>
<div class="outline-text-2" id="text-1">
<p>
Here we define what we consider to be the <a href="http://www.scaledagileframework.com/vision/">the vision</a> for Dogen; what
guides us when we think about the product and what can and cannot go
into the product backlog.
</p>
</div>

<div id="outline-container-org612e5c6" class="outline-3">
<h3 id="org612e5c6"><span class="section-number-3">1.1</span> Vision Statement</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The vision for Dogen is:
</p>

<ul class="org-ul">
<li>to create a suite of code generation tools targeting component and
product generation, according to a well-specified product line;</li>
<li>for these tools to have the potential to be useful to developers in
multiple programming languages, and to be designed to be integrated
with IDEs and text editors;</li>
<li>to make the suite extensible, such that users can come up with
modifications suited to their particular domain.</li>
</ul>
</div>
</div>

<div id="outline-container-org79b21d0" class="outline-3">
<h3 id="org79b21d0"><span class="section-number-3">1.2</span> Vision Quotes</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>code that can be reduced to an heuristic must be codegened; code
that cannot, must be helped.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6642e14" class="outline-2">
<h2 id="org6642e14"><span class="section-number-2">2</span> Release Checklist</h2>
<div class="outline-text-2" id="text-2">
<p>
Steps to create a new release.
</p>
</div>

<div id="outline-container-org6b9eb2b" class="outline-3">
<h3 id="org6b9eb2b"><span class="section-number-3">2.1</span> Close previous sprint</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To be done on the last Sunday of the sprint.
</p>

<ol class="org-ol">
<li>Make a copy of current sprint backlog and name it current
sprint + 1 but don't check it in.</li>
<li>Move all untouched stories into product backlog.</li>
<li>Close current sprint: close all open tasks, delete tasks we did not
work on, update clocks.</li>
<li>Push commit and wait for builds. This ensures that if there are any
failures you can fix them before the release tag.</li>
<li>Tag commit and sign it with key.</li>
<li>Push tag. You can generate new builds overnight.</li>
</ol>
</div>
</div>

<div id="outline-container-org0abbdd4" class="outline-3">
<h3 id="org0abbdd4"><span class="section-number-3">2.2</span> Open new sprint</h3>
<div class="outline-text-3" id="text-2-2">
<p>
To be done on the Monday morning of the new sprint.
</p>

<ol class="org-ol">
<li>Open new sprint, updating CMake version, README, appveyor version
and decoration formatter tests. Build all and run tests (some will
fail). This should all be in one commit. <b>DO NOT PUSH</b>.</li>
<li>Regenerate the LAM models for C# and C++ with the new version, and
commit the changed files. Push the commit. (Ensure there are no
pending builds still running or tests will fail due to version
change).</li>
<li>Create a demo. Publish it on youtube.</li>
<li>Write up release notes, publish them in github.</li>
<li>Download the binaries from bin tray and manually upload them to github.</li>
<li>Update bintray with the correct release notes.</li>
<li>When tag build is finished, announce on gitter, twitter and linked
in.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org036a8df" class="outline-2">
<h2 id="org036a8df"><span class="section-number-2">3</span> V2 Release</h2>
<div class="outline-text-2" id="text-3">
<p>
Release goals:
</p>

<ul class="org-ul">
<li>finish the dogen API and implement all functionality in terms of
metamodel elements - e.g. no special cases such as profiles,
licences etc.</li>
<li>we also expected to define the logical-physical conceptual model.</li>
</ul>
</div>

<div id="outline-container-orga4c6669" class="outline-3">
<h3 id="orga4c6669"><span class="section-number-3">3.1</span> Core work</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The most significant stories needed by v2. These are either features
or refactoring that must go in.
</p>
</div>

<div id="outline-container-orgfc6c0a1" class="outline-4">
<h4 id="orgfc6c0a1"><span class="section-number-4">3.1.1</span> Implement code mer</h4>
</div>

<div id="outline-container-org20f85ed" class="outline-4">
<h4 id="org20f85ed"><span class="section-number-4">3.1.2</span> "Inferred" models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<a href="https://www.reddit.com/r/cpp/comments/ksf2az/code_generation_using_attributes/">This reddit post</a> inspired an idea. The gist of it is, one could
annotate an object with some attributes, e.g.:
</p>

<pre class="example">
[[Register]]
class Service
</pre>


<p>
Via something like LSP one should be able to retrieve both the class,
the attributes and the properties. With this, it would be "trivial" to
create a Dogen model on the fly and generate it. The attributes could
contain stereotypes to configure the object, such as binding it into a
profile, etc. This would make integration of generated and
non-generated code much easier.
</p>
</div>
</div>

<div id="outline-container-orge25e360" class="outline-4">
<h4 id="orge25e360"><span class="section-number-4">3.1.3</span> Add custom IDs to attributes in org model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
At present we do not seem to be reading the custom id properties in
attributes. This means that if we add them to a model, rountripping
will fail. We should read them in.
</p>
</div>
</div>

<div id="outline-container-orge611c86" class="outline-4">
<h4 id="orge611c86"><span class="section-number-4">3.1.4</span> Artefacts do not belong in codec models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
At present we implemented a trimmed-down version of artefact in codec
model. In reality, we need the physical model artefacts to be
available because we are getting more and more use cases:
</p>

<ul class="org-ul">
<li>store a diff against the file;</li>
<li>use the write artefact transforms;</li>
</ul>

<p>
And so forth. In truth we should compose codec with physical model in
order to implement reading and writing:
</p>

<ul class="org-ul">
<li>the physical model reads a file from the filesystem and generates
an artefact;</li>
<li>in orchestration, we extract the content and supply it to the codec
for processing;</li>
<li>we then take the string output and place it in an artefact as
required (i.e. for model to model transforms). This means we can run
the physical model's transforms for writting, diffing, etc.</li>
</ul>

<p>
When we do this splitting, we can then implement tests for org-to-org
transforms.
</p>

<p>
Notes
</p>

<ul class="org-ul">
<li>the problem is that we need to read the target in order to get the
references; this means we need to generate the codec model
first. Wwe would have to split the codec transform into two across
orchestration to implement this: load codec model, in orchestration
load artefacts for references, then load codec model, etc.</li>
</ul>
</div>
</div>

<div id="outline-container-org3aeaf0b" class="outline-4">
<h4 id="org3aeaf0b"><span class="section-number-4">3.1.5</span> Add model name as title in PlantUML diagram&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
At present its not possible to know the name of the model by looking
at the SVG. We should have a comment with the title. It could be added
to the existing model level comment with documentation.
</p>
</div>
</div>

<div id="outline-container-orga788ace" class="outline-4">
<h4 id="orga788ace"><span class="section-number-4">3.1.6</span> Create a "manual tests" stereotype with profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
At present we have a <code>tests</code> facet that contains only the generated
tests, and writes to the <code>generated_tests</code> directory. We also have
created folders for manual tests under the <code>tests</code> directory. However,
the problem is that we still have no way to tell dogen about the
manual tests. This means we must use a regex to ignore the contents of
the folder. A better approach is:
</p>

<ul class="org-ul">
<li>create two distinct test facets:
<ul class="org-ul">
<li>manual tests</li>
<li>generated tests</li>
</ul></li>
<li>create a profile that enables manual tests. When enabled, we simply
create a skeleton boost test file. We must set it to override so
that we update the contents of the file manually with real tests.</li>
</ul>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>rename tests facet to <code>generated_tests</code></li>
<li>create a new facet <code>manual_tests</code>. Copy most of the contents of the
existing facet (main, cmake). Make the directory name <code>tests</code>.</li>
<li>create a template for tests with associated meta-model entity
(e.g. <code>masd::test</code>). It probably will also need its own namespace
(<code>test</code>).</li>
<li>create a stereotype that enables manual tests in the dogen model.</li>
<li>update all models, adding <code>masd::test</code> for each manual test, with
the new stereotype.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the present situation of ignoring regexes is a bit dangerous, e.g.:</li>
</ul>

<pre class="example">
#DOGEN masd.extraction.ignore_files_matching_regex=.*/test/.*
#DOGEN masd.extraction.ignore_files_matching_regex=.*/tests/.*
</pre>


<p>
This means any type in a model in the path "tests" will be
ignored. This results in a lot of surprising behaviour because some
times we create packages called tests (for example the "tests"
facet).
</p>

<p>
<b>Previous understanding</b>
</p>

<p>
<b>Rationale</b>: the right solution for this is to split generated tests
from manual tests such that we do not have to mix and match the two
types of code.
</p>

<p>
At present we are ignoring all of the contents of <code>tests</code>. This means
whenever we delete a type we are left behind with its tests. A better
solution is to create model elements for each handcrafted test marked
as "masd::handcrafted<sub>test</sub>". This disables all facets except for
tests. We can then remove the regex.
</p>

<p>
Whilst variability overrides will address the underlying issue in a
more maintainable way (e.g. the deletion of generated tests), we
should still create a profile and model all tests as proper entities
instead of bypassing the modeling system. We want to move to a world
were <b>all</b> files in the system can be attributable to modeling
entities.
</p>
</div>
</div>

<div id="outline-container-orgb09c635" class="outline-4">
<h4 id="orgb09c635"><span class="section-number-4">3.1.7</span> Modeling of dogen models themselves&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
<b>Note</b>: we probably already have this story in the backlog, or at
least some of its ideas. Do a grep and merge as required.
</p>

<p>
At present we have placed the dogen models in a top-level <code>models</code>
directory. However, if we think about it, it makes more sense to
consider the model itself a file that belongs to the component. For
this we need:
</p>

<ul class="org-ul">
<li>a models facet;</li>
<li>an assets type of model. The model type can be Dia or JSON; actually
we should not name this "model", it is a component model. We can
also have "product models".</li>
<li>an associated CMakeLists in the facet, responsible for generating
the model.</li>
</ul>

<p>
We are no longer worried about Dia and JSON directories because we
expect that JSON models are automatically generated from Dia models in
the nightly build for testing purposes.
</p>

<p>
As we did with generated tests, when the model facet is enabled (which
should be by default, lest we confuse everyone), we generate the
model.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this could enable a bootstrapping scenario: supply a model name and
a directory to dogen and it will first generate the model itself and
then generate it. Actually this may not be a good idea as we did not
choose a profile. We probably would also need to supply the
profile. We should look at build2 to see how the bootstrapping
works. We should also keep in mind that there are two bootstrapping
cases: the product case and the component case. Since the product
itself will have a model, we need to make sure these are
consistent. See Introduce dogen projects.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Consider creating a <code>modeling</code> folder/part</b>
</p>

<p>
At present we were thinking about having several folders related to
modeling, for each component:
</p>

<ul class="org-ul">
<li>templates</li>
<li>models</li>
<li>etc</li>
</ul>

<p>
It may make more sense to gather them all under <code>modeling</code>. We could
also have a product level folder with the same name.
</p>

<p>
So <code>modeling</code> is the part, and <code>templates</code>, <code>models</code> etc are facets.
</p>

<p>
<b>Consider creating a "model" meta-model element</b>
</p>

<p>
This is not yet particularly clear, and we may already have something
on the backlog for this, but the gist of it is that we have a number
of elements in the meta-model that are functions of the model itself:
</p>

<ul class="org-ul">
<li>the root module.</li>
<li>projects and solutions for the model itself.</li>
<li>common ODB options.</li>
<li>top-level CMakefile (and perhaps others).</li>
<li>msbuild</li>
</ul>

<p>
In all those cases we are duplicating information available at the
model level, with perhaps a tiny bit of extra processing. It would
make more sense for there to be an element that models the model
itself and then to have formatters for this element. We should wait
until we finish with the fabric refactor (and possibly the generation
refactor too) until we look into this. We should also take into
account the product models.
</p>

<p>
In addition, cases such as common ODB options need to be rethought; if
all we are supplying is a different representation of data that
already exists in the model itself, then we should either rely on the
model meta-type or move those properties to the new meta-type. Seems a
tad excessive having common ODB options just for a "post-processed"
set of properties.
</p>
</div>
</div>

<div id="outline-container-orga078fb9" class="outline-4">
<h4 id="orga078fb9"><span class="section-number-4">3.1.8</span> Allow defaulting to target directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-8">
<p>
At present we default the location of the log file and the byproduct
directory to the location of the binary. It may make more sense to
default it to the location of the target model, allowing us to keep
all generated data next to the model now that we have the
<code>PRODUCT.modeling</code> directories. We probably want to make this optional
in case the old behaviour was more sensible.
</p>

<p>
Names:
</p>

<ul class="org-ul">
<li><code>default-to-target-directory</code>?</li>
</ul>
</div>
</div>

<div id="outline-container-org27118a8" class="outline-4">
<h4 id="org27118a8"><span class="section-number-4">3.1.9</span> Missing PlantUML features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-9">
<p>
This story keeps track of features that we need to implement when
exporting into PlantUML.
</p>

<ul class="org-ul">
<li>generalisation via meta-data does not work. This would be very
complicated: we need to resolve <code>masd.generalization.parent</code> into
the value and then look for all classes with the stereotype of the
concept (e.g. <code>meta_element</code> for logical model).</li>
<li>we need to unpack all properties and resolve those into types for
the current model in order to model associations. Also, we need a
simple resolver to find the types in the right namespaces. The
logic would be very similar to the existing resolver. One possible
solution is to move name trees into the codec model and perform
these transforms earlier in the pipeline.</li>
<li>add tests to check that PlantUML output has not changed. We need to
have support for diffing on conversion, which we may not yet
have. Also the existing tests do not take into account the action.</li>
<li>add plantuml representations to reference models.</li>
<li>improve layout: <a href="https://crashedmind.github.io/PlantUMLHitchhikersGuide/layout/layout.html">layout</a>. See also <a href="https://stackoverflow.com/questions/61639970/align-packages-vertically-in-plantuml">SO: Align packages vertically in
PlantUML</a></li>
<li>add comments on relations:</li>
</ul>

<pre class="example">
someclass o-- otherclass : a description of the relation
</pre>


<p>
This means the org-mode model must contain the comment. We could
either use the comment on the association itself, or have a field in
properties:
</p>

<pre class="example">
:masd.codec.relation_comment: a description of the relation
</pre>


<p>
This is then copied as is into the UML diagram. By separating the
two means we can still make "proper" comments at the attribute
level.
</p>
<ul class="org-ul">
<li>there should be meta-data to determine if a comment will show up in
the diagram as a note or not. It should apply to both classes and
methods.</li>
<li>we should allow users to set the location of the comment for classes
etc (bottom, top, left, right).</li>
<li>we should allow enabling comments on methods and attributes, with
direction (left or right).</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need to move features such as name trees and generalisation into
the codec model.</li>
<li>actually perhaps we need to allow users to "tweak" the
relationships. We probably don't want every single relationship to
become a link in UML because then we can't see the wood for the
trees. A better approach may be to force users to declare the
relationships as meta-data, like we suggested above for comments,
and then transport those annotations to the UML diagram. This also
means we could add a full reference to the types, which solves the
issue of having to merge models. Finally, it means we can declare
any kind of relation, as per the plant uml syntax - in fact we
should probably expose the plant UML syntax directly, e.g. the user
is expected to declare a native plantuml relation:</li>
</ul>

<pre class="example">
:masd.codec.plantuml_relation: AS_IS_RELATION
</pre>


<p>
We could perhaps default to the current class, but that's about
it. This would also allow for things like hidden links, etc. In
effect the only relation you get for free is inheritance. Actually
we should also have a "raw" way of inserting relations in a
</p>

<p>
  namespace. These are placed at the end of the namespace.
Links:
</p>

<ul class="org-ul">
<li><a href="https://forum.plantuml.net/8770/how-to-force-vertical-arrangement-of-packages">How to force vertical arrangement of packages?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org54c8378" class="outline-4">
<h4 id="org54c8378"><span class="section-number-4">3.1.10</span> Deprecate managed directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-10">
<p>
There should only be one "managed directory" at the input stage, which
is the component directory (for component models). If parts have
relative directories off of the component directory then we should add
to the list of managed directories inside the PM pipeline.
</p>
</div>
</div>

<div id="outline-container-org4a9eb32" class="outline-4">
<h4 id="org4a9eb32"><span class="section-number-4">3.1.11</span> Add models directory to each component&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-11">
<p>
Instead of a product level models directory, we should have separate
component level directories. We can't do the PMM implementation just
yet but we can use regexes to get the directory in the correct shape
and then use it to target the changes in the PMM. The directory should
be called <code>modeling</code> to reflect the fact that it will contain more
than models.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>when we do this we will break the dogen product unit tests.</li>
<li>we need to add the targets to each component (generation,
conversion).</li>
</ul>
</div>
</div>

<div id="outline-container-org666e1ac" class="outline-4">
<h4 id="org666e1ac"><span class="section-number-4">3.1.12</span> Move hello world model from models directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-12">
<p>
It is confusing to have it mixed up with product models. Use a regular
dogen model to test the package. We could have it on the reference
model as a stand alone example, or we could create a "hello dogen"
product for a trivial example of dogen usage.
</p>

<p>
Actually, we need to address the entire samples use case. The easy
thing to do is just to add all dogen org models as examples. Or we
could just add the hello world model.
</p>

<p>
Merged stories:
</p>

<p>
<b>Create or update samples folder</b>
</p>

<p>
We should add samples to the package. These could be organsided by
injector (dia, json), then by language type (lam, cpp, csharp) or vice
versa.
</p>

<p>
We could also try to generate all of these models when testing the
package.
</p>

<p>
On the other hand, once we create a proper package for dogen headers,
with SOs etc, we should really include the dogen models there. In
effect, it will be symmetric with PDM packages.
</p>
</div>
</div>

<div id="outline-container-org5e7d38c" class="outline-4">
<h4 id="org5e7d38c"><span class="section-number-4">3.1.13</span> Consider handling "dia comments" in a general manner&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-13">
<p>
At present we allow comments with:
</p>

<pre class="example">
#DOGEN masd.codec.dia.comment=true
</pre>


<p>
to be processed as part of the containing object. We should try to
generalise this notion so that any codec could make use of this
feature.
</p>
</div>
</div>

<div id="outline-container-orgf39f0c8" class="outline-4">
<h4 id="orgf39f0c8"><span class="section-number-4">3.1.14</span> Move wale templates to TS namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-14">
<p>
At present the wale templates are in the top-level namespace of the
text model, but they should really be in each technical space.
</p>

<p>
Merged stories:
</p>

<p>
<b>Move mustache templates into the <code>transforms</code> namespaces</b>
</p>

<p>
We left the templates at the top level as it was in the TS-specific
models but they should really be within <code>transforms</code> namespace. We
need to check to see how name resolution for templates is working.
</p>
</div>
</div>

<div id="outline-container-orge6d6d0a" class="outline-4">
<h4 id="orge6d6d0a"><span class="section-number-4">3.1.15</span> Implement M2T chains via code generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-15">
<p>
We need to update the <code>backend</code> and <code>part</code> transforms to be a set of
calls to their "children", based on the PMM. Once this is done we can
remove all of the existing infrastructure in the TS models:
</p>

<ul class="org-ul">
<li>repositories</li>
<li>initialisers</li>
<li>workflows</li>
<li>traits</li>
<li>registrars</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>in the new world we no longer need a M2T interface at the text
transform level. The backend chain knows of all of the facet chains;
and the facet chains know of all of the archetypes. We can dispatch
the element using the visitor into a concrete type and then find the
archetypes that process that type. However, we do not want to
generate an apply method per logical element&#x2026;</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Implement backend and facet transform</b>
</p>

<p>
The backend transform should:
</p>

<ul class="org-ul">
<li>return the ID of the backend;</li>
<li>use the facet and archetype transforms to process all elements.</li>
</ul>

<p>
Check backlog for a story on this.
</p>
</div>
</div>

<div id="outline-container-org9392a84" class="outline-4">
<h4 id="org9392a84"><span class="section-number-4">3.1.16</span> Consider renaming <code>text</code> to <code>logical_physical</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-16">
<p>
This is really the right name for the model; the text processing part
are the transforms that are done on the model.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>rename <code>logical_physical_region</code> to just <code>region</code>.</li>
<li>actually another way of looking at this is trying to figure out what
is the dominant responsibility of the component. The LPS will
probably be 2 or 3 types whereas the M2T transforms will be 99% of
the types. We probably should name the model after lps and the
component after the M2Ts. So rename instead the model to LPS.</li>
</ul>
</div>
</div>

<div id="outline-container-org0e20d3b" class="outline-4">
<h4 id="org0e20d3b"><span class="section-number-4">3.1.17</span> Validate no two artefacts have the same ID&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-17">
<p>
At present it is possible to generate two artefacts with the same path
(which is the physical ID) and then have them overwrite each
other. This causes diffs that are very difficult to get to the bottom
of. It would be better to fail with a validation that detects
duplicates.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add a validator for text model</b>
</p>

<p>
The validator should check the paths. This can also be done in
physical model.
</p>

<pre class="example">
/*
 * FIXME: we are still generating artefacts for global
 * module.
 */
if (aptr-&gt;file_path().empty()) {
    BOOST_LOG_SEV(lg, error) &lt;&lt; empty_path
                             &lt;&lt; aptr-&gt;name().id();
    // BOOST_THROW_EXCEPTION(transform_exception(empty_path +
    //         aptr-&gt;name().id().value()));
    continue;
}
</pre>
</div>
</div>

<div id="outline-container-orga3c01eb" class="outline-4">
<h4 id="orga3c01eb"><span class="section-number-4">3.1.18</span> Fix name of configuration tracing file&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-18">
<p>
This name looks incorrect:
</p>

<pre class="example">
00000-configuration--initial_input.json
</pre>
</div>
</div>

<div id="outline-container-org91041bc" class="outline-4">
<h4 id="org91041bc"><span class="section-number-4">3.1.19</span> Rename <code>name</code> to <code>codec</code> name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-19">
<ul class="org-ul">
<li>add codec ID to name.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>variability is also using the name class.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb977058" class="outline-4">
<h4 id="orgb977058"><span class="section-number-4">3.1.20</span> Add descriptions to PMM elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-20">
<p>
We need to read a description attribute for:
</p>

<ul class="org-ul">
<li>backend</li>
<li>facet</li>
<li>part</li>
<li>archetype</li>
</ul>

<p>
And populate these on the LM PMM, and then code generate them. The
description should be the comment of the associated element.
</p>
</div>
</div>

<div id="outline-container-org5504686" class="outline-4">
<h4 id="org5504686"><span class="section-number-4">3.1.21</span> Create a physical ID in logical-physical space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-21">
<p>
Artefacts are points in logical-physical space. They should have an ID
which is composed by both logical and physical location. We could
create a very simple builder that concatenates both, for example:
</p>

<pre class="example">
&lt;dogen&gt;&lt;variability&gt;&lt;entities&gt;&lt;default_value_override&gt;|&lt;masd&gt;&lt;cpp&gt;&lt;types&gt;&lt;class_header&gt;
</pre>


<p>
The use of <code>|</code> would make it really easy to split out IDs as required,
and to visually figure out which part is which. Note though that the
ID is an opaque identifier and the splitting happens for
troubleshooting purposes only, not in the code. With the physical
model, all references are done using these IDs. So for example, if an
artefact <code>a0</code> depends on artefact <code>a1</code>, the dependency is recorded as
the ID of <code>a1</code>. The physical model should also be indexed by ID
instead of being a list of artefacts.
</p>

<p>
We already created <code>logical_meta_physical_id</code> type so maybe we don't
need this ID as well.
</p>
</div>
</div>

<div id="outline-container-orgda2d4ed" class="outline-4">
<h4 id="orgda2d4ed"><span class="section-number-4">3.1.22</span> Factor out duplication in stitch and wale templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-22">
<p>
At present we are duplicating a lot of stuff in stitch templates. If
we look at the directives, we can group them as follows:
</p>

<ol class="org-ol">
<li>Hard-coded. These have the same value for all templates:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.stream_variable_name=ast.stream() #&gt;
&lt;#@ masd.stitch.inclusion_dependency=&lt;boost/throw_exception.hpp&gt; #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.physical/types/helpers/meta_name_factory.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.logical/types/helpers/meta_name_factory.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/traits.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/traits.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/inclusion_constants.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/formatting_error.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/sequence_formatter.hpp" #&gt;
&lt;#@ masd.stitch.wale.kvp.meta_name_factory=logical::helpers::meta_name_factory #&gt;
</pre>


<ol class="org-ol">
<li>Facet-dependent. These have the same value for a given facet:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.containing_namespaces=dogen::text::cpp::transforms::types #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/traits.hpp" #&gt;
</pre>


<ol class="org-ol">
<li>Meta-element dependent. If we know who the meta-element is, we can
generate these:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #&gt;
&lt;#@ masd.stitch.wale.kvp.yarn_element=logical::entities::structural::object #&gt;
&lt;#@ masd.stitch.wale.kvp.meta_element=object #&gt;
</pre>


<ol class="org-ol">
<li>M2T transform dependent. If we know the name of the transform, we
can generate these:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.wale.kvp.class.simple_name=class_implementation_transform #&gt;
&lt;#@ masd.stitch.wale.kvp.archetype.simple_name=class_implementation #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/types/class_implementation_transform.hpp" #&gt;
</pre>


<ol class="org-ol">
<li>Not needed in the new world:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.wale.text_template=cpp_artefact_transform_implementation.wale #&gt;
</pre>


<ol class="org-ol">
<li>Are dependent on the content of the template and so must be added manually:</li>
</ol>

<pre class="example">
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/traits.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/io/inserter_implementation_helper.hpp" #&gt;
</pre>


<p>
We can address the first point and possibly the second point by
creating profiles. For point 3 and 4 we could inject these values as
part of transforms. Finally, we could so some simple filtering of
meta-data: any key starting with <code>masd.stitch.</code> is added to the KVP
container for the template. Some of these are injected manually.
</p>

<p>
Sadly we cannot share profiles between C++ and C# because at present
we cannot inherit across models. We could consider fixing this via
meta-data. Actually having said that we need to be able to use:
</p>

<pre class="example">
masd.variability.profile = dogen.profiles.base.disable_all_facets
</pre>


<p>
In the same model; this may work across models as well (modulus
possible problems with merging).
</p>

<p>
At any rate the profiles should be kept within the <code>text*</code> models
given they are used only for M2T transforms.
</p>
</div>
</div>

<div id="outline-container-orged95eea" class="outline-4">
<h4 id="orged95eea"><span class="section-number-4">3.1.23</span> Stitch templates should be bound to Dogen M2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-23">
<p>
At present we have tried to create some kind of generic implementation
of a templating engine. However in practice we only need it for the
implementation of the apply method of a M2T transform. We could take
advantage of this in order to simplify templates; we could assume that
the only thing we could code-generate in a stitch template is the
inside of the apply method. We need to check but T4 does something
similar. This would mean that many things would be hard-coded such as
the name of the stream variable etc.
</p>

<p>
Everything else should be supplied as meta-data parameters to the
modeling element for archetypes: includes, etc. This means the
templates would be much simpler. This can only be done once we use the
PMM to compute paths. Also, we probably require a way to inject the
dependencies. This will probably require merging code generation as
well.
</p>

<p>
Also this can only be done when we remove the current implementation
of helpers and move to PDMs.
</p>
</div>
</div>

<div id="outline-container-orgfb9ca44" class="outline-4">
<h4 id="orgfb9ca44"><span class="section-number-4">3.1.24</span> Name all transform exceptions consistently&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-24">
<p>
It seems on engine we call them "transform exception" but on assets we
call them "transformation error". Check all other models and them
these consistently.
</p>

<p>
Merged stories:
</p>

<p>
<b>Rename <code>transformation_error</code> to <code>transform_exception</code></b>
</p>

<p>
In keeping with the framework guidelines for naming exceptions. We need to
also look at all other exceptions.
</p>
</div>
</div>

<div id="outline-container-org64e7edd" class="outline-4">
<h4 id="org64e7edd"><span class="section-number-4">3.1.25</span> Processing of boost tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-25">
<p>
We could create a meta-model element to represent the handcrafted
tests. These could then be populated by locating the physical file and
looking for patterns:
</p>

<pre class="example">
BOOST_AUTO_TEST_SUITE(stitch_parser_tests)
BOOST_AUTO_TEST_CASE(empty_string_results_in_empty_template)
</pre>


<p>
We could then read up these strings into the model element and then
create:
</p>

<ul class="org-ul">
<li>the CDash runner. We wouldn't need any CMake magic for this any
more.</li>
<li>org file with all the tests. If there is an environment variable to
set the log level, we could then control it from org-babel.</li>
</ul>
</div>
</div>

<div id="outline-container-org1a5fc25" class="outline-4">
<h4 id="org1a5fc25"><span class="section-number-4">3.1.26</span> Model projections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-26">
<p>
When we have a model element for models themselves, we could add
support for model projections.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>model to PlantUML diagram.</li>
<li>is the project file not a model projection?</li>
<li>look for a similar story on this.</li>
</ul>
</div>
</div>

<div id="outline-container-orga3fdfd8" class="outline-4">
<h4 id="orga3fdfd8"><span class="section-number-4">3.1.27</span> Add references as links to org documents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-27">
<p>
Try adding a <code>references</code> tag. Content is a list of links to org
models. However, because of the way our referencing works in dogen, we
need to do some kind of hack. Perhaps the "text" of the link could be
the simple path to the file and the link the relative path. To start
off with, it can be ignored and managed manually. This will be spun
into its own story for the future.
</p>
</div>
</div>

<div id="outline-container-org1510cf3" class="outline-4">
<h4 id="org1510cf3"><span class="section-number-4">3.1.28</span> Empty model generation produces no diffs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-28">
<p>
At present if we do not generate any files at all, the diffing system
breaks down. This is because we always diff the generated files
against the actual files but if there are no generated files then we
have nothing to diff. Logs:
</p>

<pre class="example">
2020-12-24 11:09:56.742871 [INFO] [physical.helpers.file_status_collector] Started collecting status for model: dogen
2020-12-24 11:09:56.742874 [DEBUG] [physical.helpers.file_status_collector] Initial directories: [ "/work/DomainDrivenConsulting/masd/dogen/integration/projects/dogen/cpp" ]
2020-12-24 11:09:56.742888 [DEBUG] [physical.helpers.file_status_collector] Filtered directories: [  ]
2020-12-24 11:09:56.742892 [DEBUG] [physical.helpers.file_status_collector] No directories to analyse.
2020-12-24 11:09:56.742895 [DEBUG] [physical.transforms.gather_external_artefacts_transform] No files found.
2020-12-24 11:09:56.742898 [DEBUG] [physical.transforms.gather_external_artefacts_transform] Finished transform: gather external artefacts transform.
</pre>


<p>
We need to look at the actual files and report all of those that
exist but have not match in the generated files collection.
</p>
</div>
</div>

<div id="outline-container-org1fa901e" class="outline-4">
<h4 id="org1fa901e"><span class="section-number-4">3.1.29</span> Generated CMakefiles do not take tests into account&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-29">
<p>
At present most models have:
</p>

<pre class="example">
masd::build::cmakelists, dogen::handcrafted::cmake
</pre>


<p>
One of the reasons is because the template is not taking generated
tests into account. It should have:
</p>

<pre class="example">
if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/generated_tests)
   add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/generated_tests)
endif()
</pre>
</div>
</div>

<div id="outline-container-org6a73b53" class="outline-4">
<h4 id="org6a73b53"><span class="section-number-4">3.1.30</span> Consider creating a "combined" template&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-30">
<p>
We have a large number of templates that look very similar: the M2T
transforms. We could support them with a "clever" combination of wale
and stitch templates: the top-level wale template could stay as it is,
plus a "preamble" and "postamble":
</p>

<pre class="example">
void primitive_implementation_transform::
apply(const text::transforms::context&amp; ctx, const text::entities::model&amp; lps,
    const logical::entities::element&amp; e, physical::entities::artefact&amp; a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
</pre>


<p>
and a closing bracket:
</p>

<pre class="example">
}
</pre>


<p>
However, maybe this is just too much work for just a few lines of code
and it will increase the complexity a lot for a small win.
</p>
</div>
</div>

<div id="outline-container-org29b0b96" class="outline-4">
<h4 id="org29b0b96"><span class="section-number-4">3.1.31</span> JSON models do not create containment structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-31">
<p>
At present the JSON models represent containment via qualified names,
e.g.:
</p>

<pre class="example">
"name": "posix_time::ptime",
</pre>


<p>
However, this is then not propagated correctly into the codec
model. This means that if you have a JSON model with namespaces, it
will result in an org model (say) without namespaces. We need to
figure out what we did for Dia. Perhaps we can use the qualified names
to create packages.
</p>

<p>
We have a similar problem with org-mode models; the containment
properties are not populated, so rountripping of org to org will not
work.
</p>
</div>
</div>

<div id="outline-container-org90af0e2" class="outline-4">
<h4 id="org90af0e2"><span class="section-number-4">3.1.32</span> Running convert without parameters should work&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-32">
<p>
We tried converting like so:
</p>

<pre class="example">
$ dogen.cli convert cpp.boost.json cpp.boost.org
Error: File not found:
Failed to execute command.
</pre>


<p>
It seems we ended up with empty source and target. The correct
incantation is as follows:
</p>

<pre class="example">
$ dogen.cli convert --help
Dogen is a Model Driven Engineering tool that processes models encoded in supported codecs.
Dogen is created by the MASD project.
Displaying options specific to the convert command.
For global options, type --help.

Convert:
  -s [ --source ] arg      Input model to read, in any of the supported
                           formats.
  -d [ --destination ] arg Output model to convert to, in any of the supported
                          formats.
</pre>


<p>
We should at least give a proper error message. Ideally we should be
able to infer source and destination from the positional arguments.
</p>
</div>
</div>

<div id="outline-container-orga4a021c" class="outline-4">
<h4 id="orga4a021c"><span class="section-number-4">3.1.33</span> Reorganise dogen output&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-33">
<p>
At present we have many different artefacts we're interested in:
</p>

<ul class="org-ul">
<li>the target model;</li>
<li>the reference models;</li>
<li>log file;</li>
<li>tracing data;</li>
<li>reports;</li>
<li>etc.</li>
</ul>

<p>
In the past we decided to place all references in either the shared
library directory, or the same directory as the target models. In
terms of the output, we created the "by-products" directory where all
files other than log files go, and the directory for the log
file. However, it perhaps makes more sense to have an holistic view:
why not place <span class="underline">all</span> files, except for references, in the same
directory as the target model? If we did this, we would be able to
create org files that cross reference artefacts:
</p>

<ul class="org-ul">
<li>link to all tracing files in the org file with all transforms.</li>
<li>link to log file.</li>
</ul>

<p>
This only makes sense when we move all models into the component
directory, under <code>modeling</code>.
</p>
</div>
</div>

<div id="outline-container-orgfb7c968" class="outline-4">
<h4 id="orgfb7c968"><span class="section-number-4">3.1.34</span> Consider adding support for C++ container generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-34">
<p>
At present we are creating a lot of maps etc. These have common access
patterns:
</p>

<ul class="org-ul">
<li>"strict" find: find or throw.</li>
<li>"strict" insert: if duplicate, throw.</li>
</ul>

<p>
We should catalogue all of these, there are probably more. A better
approach would be to have a type much like primitive which wraps the
container with the right accessors. It would also make domain
terminology much saner. We should probably expose the typical C++
infrastructure such as iterators, ranges, etc. This may also be useful
for containers such as list and vector though we don't have use cases
for these yet.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.internalpointers.com/post/writing-custom-iterators-modern-cpp">Writing a custom iterator in modern C++</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0e55c3e" class="outline-4">
<h4 id="org0e55c3e"><span class="section-number-4">3.1.35</span> Consider adding a codec meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-35">
<p>
As we did with the PMM, it would be nice if you could create an
element with a stereotype, say:
</p>

<pre class="example">
masd::codec
</pre>


<p>
And then have it create a meta-model entry for the codec, with an
associated name and description. These can then be used for
documentation. It should also include the codec extension. The codec
interface should return the meta-type of the codec.
</p>
</div>
</div>

<div id="outline-container-org8f612f7" class="outline-4">
<h4 id="org8f612f7"><span class="section-number-4">3.1.36</span> Allow uses of "dictionaries" for invalid class names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-36">
<p>
It would be nice if we had a meta-type that represented a dictionary
of invalid names and then could associate it with meta-types and
possibly technical spaces. For example, we could say that certain
words are invalid for all technical spaces, other only for technical
space x etc. In addition, certain words could be valid for certain
meta-types (say archetypes) but invalid for others (say objects). If
these were meta-types we could place them in a dogen model and even
allow users to create their own lists. Maybe the better term is
"whitelist"?
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://english.stackexchange.com/questions/51088/alternative-term-to-blacklist-and-whitelist">Alternative term to Blacklist and Whitelist</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Reserved keywords are relative to model elements</b>
</p>

<p>
At present we do a blanket check for reserved keywords across all
elements. Some elements however are unaffected by this such as
profiles, archetypes (to an extent) etc. We need a way to check
different kinds of elements against different lists.
</p>
</div>
</div>

<div id="outline-container-orge9d3c35" class="outline-4">
<h4 id="orge9d3c35"><span class="section-number-4">3.1.37</span> Technical space composition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-37">
<p>
There are some formatters which are really not specific to a technical
space:
</p>

<ul class="org-ul">
<li>CMake can be used with several languages such as C, C++, etc.</li>
<li>Visual studio solutions are common to many technical spaces (F#, C#,
C++, etc).</li>
</ul>

<p>
It seems we need to create a set of generation models which can be
used in conjunction with the "dominant" technical space. These are
triggered by the presence of meta-elements. Or perhaps we can just say
that we iterate through all "non-dominant" technical spaces ("main"
and "secondary"?  "subsidiary"?) and generate anything for which there
is an enabled and matching meta-element.
</p>

<ul class="org-ul">
<li>emacs terms: major and minor technical spaces.</li>
</ul>
</div>
</div>

<div id="outline-container-orge936d57" class="outline-4">
<h4 id="orge936d57"><span class="section-number-4">3.1.38</span> Add technical space version to element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-38">
<p>
We should add the version of the TS to the element itself rather than
querying it on the model. We probably should also have the major TS
name in the element as well.
</p>

<p>
Merged stories:
</p>

<p>
<b>Create the concept of a technical space version</b>
</p>

<p>
We need a simple way to compare versions of technical spaces and have
them mapped into "identifiers" that users can relate to. For example,
C++ versions such as C++ 98 etc are the identifier; we should also
have a simple natural number mapping for each of these. We also need
to take into account the TRs - e.g. a type may be defined on a TR but
not be available on a version.
</p>

<p>
This should be done when we add technical spaces to the meta-model.
</p>

<p>
We have now added a "temporary" <code>technical_space_version</code> that could
be used for this (in <code>identification</code>). However, this needs to be done
as data.
</p>

<p>
<b>Drop the "c++-" prefix in meta-data for standard</b>
</p>

<p>
At present we do:
</p>

<pre class="example">
quilt.cpp.standard=c++-98
</pre>


<p>
The "c++-" seems a bit redundant.
</p>

<p>
<b>Add a C++ version to types</b>
</p>

<p>
Not all system model types are available for all versions. This
applies to the C++ standard (e.g. 98, 11, 14 etc) but also to
boost. We need to be able to mark a type against a version; the user
then declares which version it is using in the model. If the user
attempts to use types that are not available for that version we
should throw.
</p>

<p>
We have now added a "temporary" <code>technical_space_version</code> that could
be used for this (in <code>identification</code>).
</p>

<p>
<b>Add facet validation against language standard</b>
</p>

<p>
With the move of enablement to yarn, we can no longer validate facets
against the language standard. For example, we should not allow
hashing on C++ 98. The code was as follows:
</p>

<pre class="code"><code><span style="color: #35CDAF;">void</span> <span style="color: #339CDB;">enablement_expander</span>::<span style="color: #D9DAA2;">validate_enabled_facets</span><span style="color: #C586C0;">(</span>
    <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">global_enablement_configurations_type</span>&amp; <span style="color: #85DDFF;">gcs</span>,
    <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB;">formattables</span>::<span style="color: #35CDAF;">cpp_standards</span> <span style="color: #85DDFF;">cs</span><span style="color: #C586C0;">)</span> <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #C586C0;">{</span>
    BOOST_LOG_SEV<span style="color: #DB8E73;">(</span>lg, debug<span style="color: #DB8E73;">)</span> &lt;&lt; <span style="color: #DB8E73;">"Validating enabled facets."</span>;

    <span style="color: #339CDB; font-weight: bold;">if</span> <span style="color: #DB8E73;">(</span>cs == <span style="color: #339CDB;">formattables</span>::<span style="color: #339CDB;">cpp_standards</span>::cpp_98<span style="color: #DB8E73;">)</span> <span style="color: #DB8E73;">{</span>
        <span style="color: #339CDB; font-weight: bold;">using</span> <span style="color: #339CDB;">formatters</span>::<span style="color: #339CDB;">hash</span>::<span style="color: #35CDAF;">traits</span>;
        <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB; font-weight: bold;">auto</span> <span style="color: #85DDFF;">arch</span><span style="color: #579C4C;">(</span><span style="color: #339CDB;">traits</span>::class_header_archetype<span style="color: #85DDFF;">()</span><span style="color: #579C4C;">)</span>;

        <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB; font-weight: bold;">auto</span> <span style="color: #85DDFF;">i</span><span style="color: #579C4C;">(</span>gcs.find<span style="color: #85DDFF;">(</span>arch<span style="color: #85DDFF;">)</span><span style="color: #579C4C;">)</span>;
        <span style="color: #339CDB; font-weight: bold;">if</span> <span style="color: #579C4C;">(</span>i == gcs.end<span style="color: #85DDFF;">()</span><span style="color: #579C4C;">)</span> <span style="color: #579C4C;">{</span>
            BOOST_LOG_SEV<span style="color: #85DDFF;">(</span>lg, error<span style="color: #85DDFF;">)</span> &lt;&lt; archetype_not_found &lt;&lt; arch;
            BOOST_THROW_EXCEPTION<span style="color: #85DDFF;">(</span>expansion_error<span style="color: #BB80B3;">(</span>archetype_not_found + arch<span style="color: #BB80B3;">)</span><span style="color: #85DDFF;">)</span>;
        <span style="color: #579C4C;">}</span>

        <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB; font-weight: bold;">auto</span>&amp; <span style="color: #85DDFF;">gc</span><span style="color: #579C4C;">(</span>i-&gt;second<span style="color: #579C4C;">)</span>;
        <span style="color: #339CDB; font-weight: bold;">if</span> <span style="color: #579C4C;">(</span>gc.facet_enabled<span style="color: #85DDFF;">()</span><span style="color: #579C4C;">)</span> <span style="color: #579C4C;">{</span>
            <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB; font-weight: bold;">auto</span> <span style="color: #85DDFF;">fctn</span><span style="color: #85DDFF;">(</span>gc.facet_name<span style="color: #BB80B3;">()</span><span style="color: #85DDFF;">)</span>;
            BOOST_LOG_SEV<span style="color: #85DDFF;">(</span>lg, error<span style="color: #85DDFF;">)</span> &lt;&lt; incompatible_facet &lt;&lt; fctn;
            BOOST_THROW_EXCEPTION<span style="color: #85DDFF;">(</span>expansion_error<span style="color: #BB80B3;">(</span>incompatible_facet + fctn<span style="color: #BB80B3;">)</span><span style="color: #85DDFF;">)</span>;
        <span style="color: #579C4C;">}</span>
    <span style="color: #DB8E73;">}</span>

    BOOST_LOG_SEV<span style="color: #DB8E73;">(</span>lg, debug<span style="color: #DB8E73;">)</span> &lt;&lt; <span style="color: #DB8E73;">"Validated enabled facets."</span>;
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
It was called from the main transform method in enablement transform,
prior to uptading facet enablement.
</p>

<p>
What we really need is the concept of a technical space in the
metamodel, as well as a "version" for that technical space, and then
also the concept of a facet. Then we are effectively building
(weaving?) an instance of a theoretical TS based on the configuration
(positive variability). We can then validate the configuration. This
should all now be part of archetypes. The versions can be attributes
of technical space with a string version (e.g. "c++ 98) and a numeric
version (1 say) so that we can make comparisons (e.g. c++ 17 &gt; c++
98). Each formatter can then declare its compatibility against the
versions of the technical space.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this will require the injection of TS and the TS version as well.</li>
</ul>

<p>
Merged stories
</p>

<p>
<b>Facets incompatible with standards</b>
</p>

<p>
Some facets may not be supported for all settings of a language. For
example the hash facet is not compatible with C++ 98. We need to have
some kind of facet/formatter level validation for this.
</p>
</div>
</div>

<div id="outline-container-org015aafb" class="outline-4">
<h4 id="org015aafb"><span class="section-number-4">3.1.39</span> Model functionality provided by assistant in the logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-39">
<p>
We need to look at all the methods in assistant and see if we can
replace them by data which is processed in transforms.
</p>
</div>
</div>

<div id="outline-container-org3f9fde9" class="outline-4">
<h4 id="org3f9fde9"><span class="section-number-4">3.1.40</span> Refactor the templating model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-40">
<p>
We should use "standard" conventions in this model as well:
</p>

<ul class="org-ul">
<li>add entities namespace. Name entities after their "type",
e.g. <code>stitch_template</code>, etc.</li>
<li>add transforms for the template expansion.</li>
</ul>
</div>
</div>

<div id="outline-container-org42a9e6a" class="outline-4">
<h4 id="org42a9e6a"><span class="section-number-4">3.1.41</span> Remove annotations from stitch templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-41">
<p>
In the new world, stitch templates don't have all of the required
information to build the boilerplate:
</p>

<ul class="org-ul">
<li>they cannot expand wale templates because the KVPs will be in the
element itself, not the template. Strictly speaking this is not an
problem we have right now though.</li>
<li>more importantly, the include dependencies cannot be computed by the
template. This is because the dependencies are really a function of
the model type we are expressing on the template. Instead, we did a
quick hack and supplied the includes as KVPs. So they are kind of
parameters but kind of not really parameters because they are
hard-coded to the template. It solved the immediate problem of
having them formatted and placed in the right part of the file, but
now we can see this is not the right approach.</li>
</ul>

<p>
In reality, we should not have any annotations at all in
templates. The boilerplate and includes should be supplied as KVPs and
applied as variables. They should be composed externally with access
to data from the model element. Thus we then need a way to associate
includes with model elements. This is captured as a separate story.
</p>

<p>
We seem to be using features to read values out of the templates. We
need to see if this adds any value.
</p>
</div>
</div>

<div id="outline-container-org0251775" class="outline-4">
<h4 id="org0251775"><span class="section-number-4">3.1.42</span> Move all stitch include dependencies to legacy transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-42">
<p>
We should move all of the inclusion dependencies in stitch templates
into the legacy dependencies transform, e.g.:
</p>

<pre class="code"><code>&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/traits.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/assistant.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #&gt;
&lt;#@ masd.stitch.inclusion_dependency="dogen.text.cpp/types/transforms/hash/date_helper_transform.hpp" #&gt;
</code></pre>

<p>
Once we do this we should also remove support for
<code>inclusion_dependency</code> so that it is not possible to add these any
more. We need to check to see if all the headers we have at present
are really required (for example traits should not be).
</p>

<p>
This is a prerequisite for moving to relationship based dependencies.
</p>
</div>
</div>

<div id="outline-container-org5c4d062" class="outline-4">
<h4 id="org5c4d062"><span class="section-number-4">3.1.43</span> Improve modeling of attribute properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-43">
<p>
When we decommissioned formattables we did a lift and shift of a few
properties into the model itself:
</p>

<ul class="org-ul">
<li><code>streaming_properties</code></li>
<li><code>aspect_properties</code></li>
<li><code>assistant_properties</code></li>
</ul>

<p>
This was the first phase of this work. Once the PDM work has been
carried out and we determine which of these properties are really
required, we should move them to the attributes instead of the model
because that is how they are ultimately used.
</p>
</div>
</div>

<div id="outline-container-orgd7db422" class="outline-4">
<h4 id="orgd7db422"><span class="section-number-4">3.1.44</span> Prune non-generatable types from logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-44">
<p>
Add a pruning transform that filters out all non-generatable types
from logical model.
</p>

<p>
Actually we can't just do this directly else the inclusion will not
work. However we do have a "reducer" transform in the formattables
namespace which needs to be moved to the new world.
</p>
</div>
</div>

<div id="outline-container-org1f5f157" class="outline-4">
<h4 id="org1f5f157"><span class="section-number-4">3.1.45</span> Feature initializer with no features does not compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-45">
<p>
We removed all the features from <code>masd::variability::initializer</code> and
the compilation failed with the following error:
</p>

<div class="epigraph"><blockquote>
<p>
<code>[5/19]</code> Building CXX object projects/dogen.text.cpp/src/CMakeFiles/dogen.text.cpp.lib.dir/types/feature<sub>initializer.cpp.o</sub>
FAILED: projects/dogen.text.cpp/src/CMakeFiles/dogen.text.cpp.lib.dir/types/feature<sub>initializer.cpp.o</sub>
<i>usr/bin/clang++-11  -DENABLE<sub>CPP</sub><sub>REF</sub><sub>IMPL</sub><sub>TESTS</sub> -DENABLE<sub>CSHARP</sub><sub>REF</sub><sub>IMPL</sub><sub>TESTS</sub> -DLZMA<sub>API</sub><sub>STATIC</sub> -D<sub>GLIBCXX</sub><sub>USE</sub><sub>CXX11</sub><sub>ABI</sub>=1 -Istage/include -I..</i>../../../projects/dogen/include -I../../../../projects/dogen.identification/include -I../../../../projects/dogen.physical/include -I../../../../projects/dogen.cli/include -I../../../../projects/dogen.utility/include -I../../../../projects/dogen.variability/include -I../../../../projects/dogen.dia/include -I../../../../projects/dogen.codec/include -I../../../../projects/dogen.codec.dia/include -I../../../../projects/dogen.codec.json/include -I../../../../projects/dogen.codec.org<sub>mode</sub>/include -I../../../../projects/dogen.tracing/include -I../../../../projects/dogen.logical/include -I../../../../projects/dogen.orchestration/include -I../../../../projects/dogen.templating/include -I../../../../projects/dogen.text/include -I../../../../projects/dogen.text.cpp/include -I../../../../projects/dogen.text.csharp/include -I../../../../projects/dogen.relational/include -isystem <i>work/DomainDrivenConsulting/masd/vcpkg/masd/installed/x64-linux/include -Wall -Wextra -Wconversion -Wno-mismatched-tags -pedantic -Werror -Wno-system-headers -Woverloaded-virtual -Wwrite-strings  -frtti -fvisibility-inlines-hidden -fvisibility=hidden  -O3 -DNDEBUG -fPIC   -std=gnu++17 -MD -MT projects/dogen.text.cpp/src/CMakeFiles/dogen.text.cpp.lib.dir/types/feature<sub>initializer.cpp.o</sub> -MF projects/dogen.text.cpp/src/CMakeFiles/dogen.text.cpp.lib.dir/types/feature<sub>initializer.cpp.o.d</sub> -o projects/dogen.text.cpp/src/CMakeFiles/dogen.text.cpp.lib.dir/types/feature<sub>initializer.cpp.o</sub> -c ..</i>../../../projects/dogen.text.cpp/src/types/feature<sub>initializer.cpp</sub>
../../../../projects/dogen.text.cpp/src/types/feature<sub>initializer.cpp</sub>:26:52: error: unused parameter 'rg' [-Werror,-Wunused-parameter]
register<sub>entities</sub>(variability::helpers::registrar&amp; rg) {
</p>

</blockquote></div>

<p>
We could perhaps issue a dogen warning for the absence of features but
the code should compile.
</p>
</div>
</div>

<div id="outline-container-orga84ce1f" class="outline-4">
<h4 id="orga84ce1f"><span class="section-number-4">3.1.46</span> Create a patch for tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-46">
<p>
At present we only output the head of the first 5 diffs when a model
fails. However, in some cases we may want to look at the entire
diff. It would be nice if we could output the patch into the
byproducts directory for each test.
</p>
</div>
</div>

<div id="outline-container-org042f454" class="outline-4">
<h4 id="org042f454"><span class="section-number-4">3.1.47</span> Wale should throw on non-required keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-47">
<p>
At present we throw if we do not supply required keys. We should also
throw if we supply non-required keys.
</p>
</div>
</div>

<div id="outline-container-org35752be" class="outline-4">
<h4 id="org35752be"><span class="section-number-4">3.1.48</span> Remove wale instantiation from stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-48">
<p>
Though we've split wale out of stitch in the logical model, its still
possible to instantiate a wale template within stitch. We should
remove this as well.
</p>
</div>
</div>

<div id="outline-container-orgd7128c4" class="outline-4">
<h4 id="orgd7128c4"><span class="section-number-4">3.1.49</span> Decouple physical model from logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-49">
<p>
At present we have a dependency of the logical model on the physical
model. This is for two reasons:
</p>

<ul class="org-ul">
<li>variability (<code>variability_profiles_chain</code>): we need to instantiate
the template domains.</li>
<li>helpers (<code>helper_properties_transform</code>): we need access to the
helpers in order to create the helper properties.</li>
</ul>

<p>
We should not really couple these two models. For the first case we
could supply the domains as an argument when constructing the context
and rely only on <code>std</code> types. Helpers will be decommissioned with
PDMs. At that point we should look into making these two models
independent again.
</p>

<p>
Actually we could do a quick change now and address this:
</p>

<ul class="org-ul">
<li>do the variability change now.</li>
<li>instead of adding helper transform, add this work into the logical
to physical projector.</li>
</ul>

<p>
Actually that would not work as we are projecting "the other way
around". This work will have to wait.
</p>
</div>
</div>

<div id="outline-container-orgd2ee4a4" class="outline-4">
<h4 id="orgd2ee4a4"><span class="section-number-4">3.1.50</span> Replace meta-model naming with stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-50">
<p>
At present we are using meta-names for binding formatters to logical
meta-model elements. This is not a very good way of doing things. We
should bind them directly at the stereotype level. This would allow us
to decomission a lot of code:
</p>

<ol class="org-ol">
<li><code>meta_naming_transform</code>, <code>meta_name_factory</code>.</li>
<li><code>stereotypes_helper</code></li>
<li><code>static_stereotypes</code> enumeration</li>
</ol>
</div>
</div>

<div id="outline-container-orge81c425" class="outline-4">
<h4 id="orge81c425"><span class="section-number-4">3.1.51</span> Consider making technical spaces a core concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-51">
<p>
At present we are trying to instantiate a stitch template. It requires
knowing the technical space that the original archetype belongs to so
that we can locate the appropriate decoration. However, because we are
in the text model and the archetype is a physical concept, we have no
way of knowing what the original TS was for a given archetype. We
could of course locate the associated M2T transform etc - but this
perhaps hints at a bigger problem with the conceptual model: technical
spaces are much more of a pervasive concept than just logical model:
</p>

<ul class="org-ul">
<li>injectors belong to technical spaces.</li>
<li>logical model entities belong to technical spaces.</li>
<li>text transforms belong to technical spaces.</li>
<li>physical model entities such as archetypes and artefacts belong to
technical spaces.</li>
</ul>

<p>
It would be nice if we could have this modeled correctly, in some kind
of shared model. At present, the only model which does this is
<code>variability</code> but it does not make a lot of sense to put TS'
there. Perhaps we should wait until we have enough entities to see
what the name of this "core" model should be.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add technical spaces to PM and LM</b>
</p>

<p>
Technical spaces and their associated versions should be declared by
the text models and should be part of the PM. The TS should be
declared on the "global" text model so that backends can reuse them
(e.g. we can declare XML with associated extensions and then use it
where required).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>TS should also have a physical name. However, they are not
associated with a backend. Actually they don't need a physical name
but they need some kind of identification.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc53cf60" class="outline-4">
<h4 id="orgc53cf60"><span class="section-number-4">3.1.52</span> Move io code in types in C++ to io facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-52">
<p>
Originally we implemented io support for inheritance by making use of
virtual functions. This is still the easiest way to do type
dispatching; however, we then placed the io implementation in
types. This is a bit annoying because it clutters types with io
machinery. Another way of doing this is:
</p>

<ul class="org-ul">
<li>create a class to do the streaming for each type, call it <code>dumper</code>;</li>
<li>when there is no inheritance, <code>operator&lt;&lt;</code> simply calls the
appropriate dumper.</li>
<li>when there is inheritance, to<sub>stream</sub> calls the appropriate dumper
directly; <code>operator&lt;&lt;</code> calls <code>to_stream</code>. in an ideal world we could
even make it private and <code>operator&lt;&lt;</code> a friend.</li>
</ul>

<p>
With this, we no longer need all the complications of supporting io
helpers in types (enabled in helpers, etc). We just need to determine
if io is enabled (and in inheritance), in which case we output
<code>to_stream</code> and for implementation, also include/use the dumper. Note
that we still need to declare the dumpers in the io headers - at least
for types involved in inheritance, but probably in all cases for
consistency.
</p>

<p>
In fact we should go one step further and rename the io facet
"dumper", "data<sub>dumper</sub>" or some such name. We called it "io" because
it uses iostreams in C++ but that is just an implementation
detail. The facet itself should be mainly composed of the dumpers
themselves and then simply have <code>operator&lt;&lt;</code> as entry points to call
the dumpers.
</p>

<p>
This is a dependency in order to move to PDMs because we will not have
helpers. Therefore there will be no way to handle the complex
relationships between types and IO.
</p>
</div>
</div>

<div id="outline-container-org7fa091e" class="outline-4">
<h4 id="org7fa091e"><span class="section-number-4">3.1.53</span> Analysis of MDE papers to read&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-53">
<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://ulir.ul.ie/bitstream/handle/10344/2126/2007_Botterweck.pdf;jsessionid=AC6FF39BA414E6065602C7851860C43D?sequence=2">Model-Driven Derivation of Product Architectures</a></li>
<li><a href="https://madoc.bib.uni-mannheim.de/993/1/abwl_02_05.pdf">A Taxonomy of Metamodel Hierarchies</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5d1d22c" class="outline-4">
<h4 id="org5d1d22c"><span class="section-number-4">3.1.54</span> Order of headers is hard-coded&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-54">
<p>
In inclusion expander, we have hacked the sorting:
</p>

<pre class="example">
// FIXME: hacks for headers that must be last
const bool lhs_is_gregorian(
    lhs.find_first_of(boost_serialization_gregorian) != npos);
const bool rhs_is_gregorian(
    rhs.find_first_of(boost_serialization_gregorian) != npos);
if (lhs_is_gregorian &amp;&amp; !rhs_is_gregorian)
    return true;
</pre>


<p>
This could be handled via meta-data, supplying some kind of flag (sort
last?). We should try to generate the code in the "natural order" and
see if the code compiles with latest boost. We should also test this
with latest boost to see if its still needed.
</p>
</div>
</div>

<div id="outline-container-org97648a9" class="outline-4">
<h4 id="org97648a9"><span class="section-number-4">3.1.55</span> Create a de-normalised representation of archetype properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-55">
<p>
At present we have a two-step process: we first read the global
configuration for a model, create the corresponding properties
(e.g. backend, facet, archetype properties) and then we post-process
these to create the <code>denormalised_archetype_properties</code>. However, we
never really need to think about the individual properties because
they are always used in the context of an artefact, which means we
care about the de-normalised archetype properties only. Therefore we
should:
</p>

<ul class="org-ul">
<li>have a <code>archetype_properties</code> that is composed of all other
properties;</li>
<li>change the <code>meta_model_properties_transform</code> to create internal
indices of properties as a first step for the final property
generation but do not expose these containers.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we can't remove the top-level containers just yet because they are
used within the formatables namespace. However, these appear to be
legacy use cases, so we should be able to do so when we get rid of
this namespace.</li>
</ul>
</div>
</div>

<div id="outline-container-org9d399c9" class="outline-4">
<h4 id="org9d399c9"><span class="section-number-4">3.1.56</span> Move default constructor work from resolver&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-56">
<p>
At present we are populating the default constructor for the bundle in
the resolver:
</p>

<pre class="code"><code><span style="color: #35CDAF;">void</span> <span style="color: #339CDB;">resolver</span>::<span style="color: #D9DAA2;">resolve_feature_template_bundles</span><span style="color: #C586C0;">(</span><span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">indices</span>&amp; <span style="color: #85DDFF;">idx</span>,
    <span style="color: #339CDB;">entities</span>::<span style="color: #35CDAF;">model</span>&amp; <span style="color: #85DDFF;">m</span><span style="color: #C586C0;">)</span> <span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">for</span> <span style="color: #DB8E73;">(</span><span style="color: #339CDB; font-weight: bold;">auto</span>&amp; <span style="color: #85DDFF;">pair</span> : m.variability_elements<span style="color: #579C4C;">()</span>.feature_template_bundles<span style="color: #579C4C;">()</span><span style="color: #DB8E73;">)</span> <span style="color: #DB8E73;">{</span>
        <span style="color: #339CDB; font-weight: bold;">auto</span>&amp; <span style="color: #85DDFF;">fb</span><span style="color: #579C4C;">(</span>*pair.second<span style="color: #579C4C;">)</span>;
        <span style="color: #339CDB; font-weight: bold;">for</span> <span style="color: #579C4C;">(</span><span style="color: #339CDB; font-weight: bold;">auto</span>&amp; <span style="color: #85DDFF;">ft</span> : fb.feature_templates<span style="color: #85DDFF;">()</span><span style="color: #579C4C;">)</span> <span style="color: #579C4C;">{</span>
            resolve_name_tree<span style="color: #85DDFF;">(</span>m, idx, fb.name<span style="color: #BB80B3;">()</span>, ft.parsed_type<span style="color: #BB80B3;">()</span><span style="color: #85DDFF;">)</span>;
            <span style="color: #339CDB; font-weight: bold;">if</span> <span style="color: #85DDFF;">(</span>ft.parsed_type<span style="color: #BB80B3;">()</span>.is_current_simple_type<span style="color: #BB80B3;">()</span><span style="color: #85DDFF;">)</span>
                fb.requires_manual_default_constructor<span style="color: #85DDFF;">(</span><span style="color: #339CDB;">true</span><span style="color: #85DDFF;">)</span>;
        <span style="color: #579C4C;">}</span>
    <span style="color: #DB8E73;">}</span>
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
This is very confusing because one would assume the resolver just
resolves. We need to move this logic to <code>technical_space_properties</code>.
</p>
</div>
</div>

<div id="outline-container-org74c14a3" class="outline-4">
<h4 id="org74c14a3"><span class="section-number-4">3.1.57</span> Create a technical space specific property for default functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-57">
<p>
In assistant we have:
</p>

<pre class="code"><code><span style="color: #35CDAF;">bool</span> <span style="color: #339CDB;">assistant</span>::<span style="color: #D9DAA2;">supports_defaulted_functions</span><span style="color: #C586C0;">()</span> <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">return</span> <span style="color: #85DDFF; font-weight: bold;">!</span>is_cpp_standard_98<span style="color: #DB8E73;">()</span>;
<span style="color: #C586C0;">}</span>

<span style="color: #35CDAF;">bool</span> <span style="color: #339CDB;">assistant</span>::<span style="color: #D9DAA2;">supports_move_operator</span><span style="color: #C586C0;">()</span> <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">return</span> <span style="color: #85DDFF; font-weight: bold;">!</span>is_cpp_standard_98<span style="color: #DB8E73;">()</span>;
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
This should really be in <code>technical_space_properties</code>. Check to see if
we missed any.
</p>
</div>
</div>

<div id="outline-container-org6480ece" class="outline-4">
<h4 id="org6480ece"><span class="section-number-4">3.1.58</span> Default constructor incorrectly generated in C++ 98&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-58">
<p>
We have this logic in <code>technical_space_properties_transform</code>:
</p>

<pre class="code"><code>    <span style="color: #5F7F5F;">/*</span>
<span style="color: #579C4C;">     * In C++ 98 we must always create a default constructor because</span>
<span style="color: #579C4C;">     * we cannot make use of the defaulted functions.</span>
<span style="color: #5F7F5F;">     */</span>
    <span style="color: #339CDB; font-weight: bold;">if</span> <span style="color: #C586C0;">(</span>is_cpp_standard_98 || src_tsp.requires_manual_default_constructor<span style="color: #DB8E73;">()</span><span style="color: #C586C0;">)</span>
        dest_tsp.requires_manual_default_constructor<span style="color: #C586C0;">(</span><span style="color: #339CDB;">true</span><span style="color: #C586C0;">)</span>;
</code></pre>

<p>
This is actually incorrect: we can use default constructors in C++ 98,
as long as there are no other constructors. The problem is we are
relying on the default constructor in test data generator so if we fix
this with an <code>&amp;&amp;</code> instead of an <code>||</code> we break that code. We need to
figure out what the correct implement is.
</p>
</div>
</div>

<div id="outline-container-org0fb95d7" class="outline-4">
<h4 id="org0fb95d7"><span class="section-number-4">3.1.59</span> Detect absence of configuration in bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-59">
<p>
It would be nice if when we call <code>make_static_configuration</code> it would
populate some flag stating whether none of the config was
populated. The specific use case is that we may want to detect absence
of all elements and do something in that case (for example, missing
streaming properties).
</p>
</div>
</div>

<div id="outline-container-orgffa94af" class="outline-4">
<h4 id="orgffa94af"><span class="section-number-4">3.1.60</span> Refactor streaming properties processing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-60">
<p>
At present we copied across the logic from <code>text.cpp</code> where the
streaming properties are stored as a class and the final processing
happens in assistant. However, when we get rid of helpers, we could do
all the processing in the streaming processing transform and store it
in attributes.
</p>
</div>
</div>

<div id="outline-container-orgd62dc49" class="outline-4">
<h4 id="orgd62dc49"><span class="section-number-4">3.1.61</span> Add method to check if string is valid enum&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-61">
<p>
We have a method to convert a string to an enum, but sometimes we just
want to know if its valid without converting. We should have a method
that just returns true or false, or throws, if the string is not a
valid enum.
</p>
</div>
</div>

<div id="outline-container-org7f0ac73" class="outline-4">
<h4 id="org7f0ac73"><span class="section-number-4">3.1.62</span> Split <code>utility</code> into multiple models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-62">
<p>
What we have in the <code>utility</code> library at present is in fact a
combination of different things:
</p>

<ul class="org-ul">
<li>log could be an extension to boost log, so part of <code>boost</code> PDM.</li>
<li>testing could be an extension of <code>Boost.Test</code> so part of <code>boost</code>
PDM.</li>
<li><code>filesystem</code> also belongs to boost.</li>
<li><code>formatters</code> are helpers in the LPS model.</li>
<li><code>hash</code> is an extension of either boost or std models.</li>
<li>&#x2026;</li>
</ul>

<p>
We need to finish the analysis on this and make sure we have the right
model and PDMs to house these types.
</p>
</div>
</div>

<div id="outline-container-orgc113340" class="outline-4">
<h4 id="orgc113340"><span class="section-number-4">3.1.63</span> Add full and relative path processing to PM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-63">
<p>
We need to be able to generate full paths in the PM. This will require
access to the file extensions. For this we will need new decoration
elements. This must be done as part of the logical model to physical
model conversion. While we're at it, we should also generate the
relative paths. Once we have relative paths we should compute the
header guards from them. These could be generalised to "unique
identifiers" or some such general name perhaps. That should be a
separate transform.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we are not yet populating the archetype kind in archetypes so we
cannot locate the extensions. Also we did not create all of the
required archetype kinds in the text models. The populating should
be done via profiles.</li>
<li>we must first figure out the number of enabled backends. The
meta-model properties will always contain all backends, but not all
of them are enabled.</li>
<li>we need to populate the part directories. For this we need to know
what parts are available for each backend (PMM), and then ensure the
part properties have been created. We also need a directory for the
part in variability. It is not clear we have support for this in the
template instantiation domains - we probably only have backend,
facet, archetype.</li>
<li>guiding principle: there should be a direct mapping between the two
hierarchical spaces: the definition meta-model of the physical space
and its instances in the file-system.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Map archetypes to labels</b>
</p>

<p>
We need to add support in the PMM for mapping archetypes to labels. We
may need to treat certain labels more specially than others - its not
clear. We need a container with:
</p>

<ul class="org-ul">
<li>logical model element ID</li>
<li>archetype ID</li>
<li>labels</li>
</ul>

<p>
<b>Implement locator in physical model</b>
</p>

<p>
Use PMM entities to generate artefact paths, within <code>m2t</code>.
</p>

<p>
<b>Create a archetypes locator</b>
</p>

<p>
We need to move all functionality which is not kernel specific into
yarn for the locator. This will exist in the helpers namespace. We
then need to implement the C++ locator as a composite of yarn
locator.
</p>

<p>
<b>Other Notes</b>
</p>

<p>
At present we have multiple calls in locator, which are a bit
ad-hoc. We could potentially create a pattern. Say for C++, we have
the following parameters:
</p>

<ul class="org-ul">
<li>relative or full path</li>
<li>include or implementation: this is simultaneously used to determine
the placement (below) and the extension.</li>
<li>meta-model element:</li>
<li>"placement": top-level project directory, source directory or
"natural" location inside of facet.</li>
<li>archetype location: used to determine the facet and archetype
postfixes.</li>
</ul>

<p>
E.g.:
</p>

<pre class="example">
make_full_path_for_enumeration_implementation
</pre>


<p>
Interestingly, the "placement" is a function of the archetype location
(a given artefact has a fixed placement). So a naive approach to this
seems to imply one could create a data driven locator, that works for
all languages if supplied suitable configuration data. To generalise:
</p>

<ul class="org-ul">
<li>project directory is common to all languages.</li>
<li>source or include directories become "project
sub-directories". There is a mapping between the artefact location
and a project sub-directory.</li>
<li>there is a mapping between the artefact location and the facet and
artefact postfixes.</li>
<li>extensions are a slight complication: a) we want to allow users to
override header/implementation extensions, but to do it so for the
entire project (except maybe for ODB files). However, what yarn's
locator needs is a mapping of artefact location to  extension. It
would be a tad cumbersome to have to specify extensions one artefact
location at a time. So someone has to read a kernel level
configuration parameter with the artefact extensions and expand it
to the required mappings. Whilst dealing with this we also have the
issue of elements which have extension in their names such as visual
studio projects and solutions. The correct solution is to implement
these using element extensions, and to remove the extension from the
element name.</li>
<li>each kernel can supply its configuration to yarn's locator via the
kernel interface. This is fairly static so it can be supplied early
on during initialisation.</li>
<li>there is still something not quite right. We are performing a
mapping between some logical space (the modeling space) and the
physical space (paths in the filesystem). Some modeling elements
such as the various CMakeLists.txt do not have enough information at
the logical level to tell us about their location; at present the
formatter itself gives us this hint ("include cmakelists" or "source
cmakelists"?). It would be annoying to have to split these into
multiple archetypes just so we can have a function between the
archetype location and the physical space. Although, if this is the
only case of a modeling element not mapping uniquely, perhaps we
should do exactly this.</li>
<li>However, we still have inclusion paths to worry about. As we done
with the source/include directories, we need to somehow create a
concept of inclusion path which is not language specific; "relative
path" and "requires relative path" perhaps? These could be a
function of archetype location.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Generate file paths as a transform</b>
</p>

<p>
We need to understand how file paths are being generated at present;
they should be a transform inside generation.
</p>

<p>
<b>Create the notion of project destinations</b>
</p>

<p>
At present we have conflated the notion of a facet, which is a logical
concept, with the notion of the folders in which files are placed - a
physical concept. We started thinking about addressing this problem by
adding the "intra-backend segment properties", but as the name
indicates, we were not thinking about this the right way. In truth,
what we really need is to map facets (better: archetype locations) to
"destinations".
</p>

<p>
For example, we could define a few project destinations:
</p>

<pre class="example">
masd.generation.destination.name="types_headers"
masd.generation.destination.folder="include/masd.cpp_ref_impl.northwind/types"
masd.generation.destination.name=top_level (global?)
masd.generation.destination.folder=""
masd.generation.destination.name="types_src"
masd.generation.destination.folder="src/types"
masd.generation.destination.name="tests"
masd.generation.destination.folder="tests"
</pre>


<p>
And so on. Then we can associate each formatter with a destination:
</p>

<pre class="example">
masd.generation.cpp.types.class_header.destination=types_headers
</pre>


<p>
Notes:
</p>

<ul class="org-ul">
<li>these should be in archetypes models.</li>
<li>with this we can now map any formatter to any folder, particularly
if this is done at the element level. That is, you can easily define
a global mapping for all formatters, and then override it
locally. This solves the long standing problem of creating say types
in tests and so forth. With this approach you can create anything
anywhere.</li>
<li>we need to have some tests that ensure we don't end up with multiple
files with the same name at the same destination. This is a
particular problem for CMake. One alternative is to allow the
merging of CMake files, but we don't yet have a use case for
this. The solution would be to have a "merged file flag" and then
disable all other facets.</li>
<li><p>
this will work very nicely with profiles: we can create a few out of
the box profiles for users such as flat project, common facets and
so on. Users can simply apply the stereotype to their models. These
are akin to "destination themes". However, we will also need some
kind of "variable replacement" so we can support cases like
<code>include/masd.cpp_ref_impl.northwind/types</code>. In fact, we also have
the same problem when it comes to modules. A proper path is
something like:
</p>
<ul class="org-ul">
<li><code>include/${model_modules_as_dots}/types/${internal_modules_as_folders}</code></li>
<li><code>include/${model_modules_as_dots}/types/${internal_modules_as_dots}.</code></li>
<li><code>include/${model_modules_as_dots}/types/${internal_modules_as_underscores}_</code></li>
</ul>

<p>
This is <b>extremely</b> flexible. The user can now create a folder
structure that depends on package names etc or choose to flatten it
and can do so for one or all facets. This means for example that we
could use nested folders for <code>include</code>, not use model modules for
<code>src</code> and then flatten it all for <code>tests</code>.
</p></li>
<li>actually it is a bit of a mistake to think of these destinations as
purely physical. In reality, we may also need them to contribute to
namespaces. For example, in java the folders and namespaces must
match. We could solve this by having a "module contribution" in the
destination. These would then be used to construct the namespace for
a given facet. Look for java story on backlog for this.</li>
<li>this also addresses the issue of having multiple serialisation
formats and choosing one, but having sensible folder names. For
example, we could have boost serialisation mapped to a destination
called <code>serialisation</code>. Or we could map it to say RapidJSON
serialisation. Or we could support two methods of serialisation for
the same project. The user chooses where to place them.</li>
</ul>
</div>
</div>

<div id="outline-container-org5142483" class="outline-4">
<h4 id="org5142483"><span class="section-number-4">3.1.64</span> Create a factory transform for parts and archetype kinds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-64">
<ul class="org-ul">
<li>integrate their generation into PMM chains.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>it does not make a lot of sense to have an archetype kind
transform. That is, as with TSs, archetype kinds only provide
attributes (e.g. data) about physical space, but they won't be
expressed as actual physical elements. Parts however are connected
to the transforms; they will in the future be used as part of the
transform chain.</li>
<li>do we instantiate template domains over parts? We need to do so in
order to support directory overrides. The problem is that in order
for the part to become part of the topology of physical space, we
now need to make sure we can still convert archetypes into facets. A
lot of the code is going to break once we add path.</li>
</ul>
</div>
</div>

<div id="outline-container-org263c26d" class="outline-4">
<h4 id="org263c26d"><span class="section-number-4">3.1.65</span> Allow arbitrary physical containment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-65">
<p>
We need to allow archetypes to be contained by any physical element,
except for archetypes. We also need to allow facets to belong to any
physical element other than facets.
</p>
</div>
</div>

<div id="outline-container-org7211fa8" class="outline-4">
<h4 id="org7211fa8"><span class="section-number-4">3.1.66</span> Rename <code>archetype_name_set</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-66">
<p>
We haven't yet found the right name for this but the idea is that we
have a container of all the meta-names which refer to archetypes in a
region of physical space.
</p>

<ul class="org-ul">
<li>archetype name meta region? it is only meta-names.</li>
</ul>
</div>
</div>

<div id="outline-container-orga45dba5" class="outline-4">
<h4 id="orga45dba5"><span class="section-number-4">3.1.67</span> Add dependencies to artefacts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-67">
<p>
We need to propagate the dependencies between logical model elements
into the physical model. We still need to distinguish between "types"
of dependencies:
</p>

<ul class="org-ul">
<li>transparent<sub>associations</sub></li>
<li>opaque<sub>associations</sub></li>
<li>associative<sub>container</sub><sub>keys</sub></li>
<li>parents</li>
</ul>

<p>
Basically, anything which we refer to when we are building the
dependencies for inclusion needs to be represented. We could create a
data structure for this purpose such as "dependencies". We should also
include "namespace" dependencies. These can be obtained by <code>sort |
 uniq</code> of all of the namespaces for which there are dependencies. These
are then used for C#.
</p>

<p>
Note however that all dependencies are recorded as logical-physical
IDs.
</p>

<p>
We also need a way to populate the dependencies as a transform. This
must be done in <code>m2t</code> because we need the formatters. We can rely on
the same approach as <code>inclusion_dependencies</code> but instead of creating
<i>inclusion dependencies</i>, we are just creating <i>dependencies</i>.
</p>

<p>
This will also address the uses of traits, e.g.:
</p>

<pre class="example">
const auto ch_arch(traits::archetype_class_header_factory_archetype_qn());
</pre>


<p>
This is because the traits are used to express dependencies.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we did the work to record the relations at the archetype level and
started updating the archetypes with these in <code>text.cpp</code>. However,
we only did a couple of types.</li>
<li>in order to instantiate meta-relations onto the LPS, we need to be
able to resolve a relation type such as "transparent" into a
concrete archetype. This means the archetype must have a label of
that relation type.</li>
<li>artefacts must have relations stored as LPS points with both the
logical name and physical meta-name. At this point we no longer care
about relation type since it has been resolved.</li>
<li>a part is really a "meta-part". We still need to instantiate it with
the actual project path. The physical model needs to contain this
instantiation.</li>
<li>artefacts need to know their parts.</li>
<li>archetypes do not have part populated and their type is incorrect
(<code>physical_id</code>).</li>
</ul>
<ul class="org-ul">
<li>parts should have a root folder. These are specified through
meta-data. The path is relative to the project path. Different
models can have different part paths. This means we need to remember
them when computing a reference to an artefact. Actually this is
only needed because of split projects. We need to deprecate it as it
makes things very complicated.</li>
<li>parts need a directory name. This must be supplied by meta data with
the part name:</li>
</ul>

<pre class="example">
masd.physical.part.folder_name.implementation=src
</pre>


<p>
Where implementation is a KVP.
</p>

<ul class="org-ul">
<li>physical model must be split by backend. Backend must have an
associated folder name or blank for no folder:</li>
</ul>

<pre class="example">
masd.physical.backend.folder_name.cpp=src
</pre>


<ul class="org-ul">
<li>actually we will have exactly the same problem with facets too. We
need to create instances of all the meta-model elements.</li>
<li>due to the fact that you can configure physical meta-elements, we
have no choice but keep track of the referenced models. This is
because we could have overwritten them differently in any of the
referenced models.</li>
<li>actually we found a much more profound problem, which already exists
in dogen: if you configure backend/facet/archetypes differently in
say M0 and M1, and if M1 references M0, the paths will not be
constructed correctly. That is because we assume that we can
reconstruct M0 paths using M1's configuration, which is true at
present merely because we use the same variability settings for all
models within a product; and on the rare cases we don't, we never
make use of these models from other models - e.g. test models. To
fix this properly would require a fairly complex set of changes to
Dogen: we would need to keep track of the references and their types
all the way through to code generation. This will not be
easy. However, what we can do is to start introducing the notion of
reference models and elements; initially this can be used just to
check that all references have the same configuration. Eventually,
as use cases arrive we can extend it to implement this per-model
configuration properly. This also means that it is not possible to
refer to a model that has more than one backend for now from a model
that only has a backend.</li>
</ul>
</div>
</div>

<div id="outline-container-orga0f0642" class="outline-4">
<h4 id="orga0f0642"><span class="section-number-4">3.1.68</span> Add instances of physical meta-model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-68">
<p>
We made a modeling error with regards to the physical meta-model
elements. We assumed that the user configuration of the meta-model
elements could be stored with the PMM. This is incorrect because the
PMM is created from static data; it is as it was code generated by the
state of the <code>text.cpp</code> and <code>text.csharp</code> models. However, users can
apply their own configuration to these elements: change backend
directory, facet directory etc. These properties are relative to the
models the users load. Worse, they are possibly different for each
reference - though that particular problem will have to be addressed
separately.
</p>

<p>
This now causes a big conceptual problem: we assumed that artefacts
were instances of archetypes but yet there is a need to have an
archetype instance where the model specific configuration is
stored. The quick hack, is to create some types that sit in between
the meta-type and the instance type:
</p>

<ul class="org-ul">
<li><code>backend_instance</code></li>
<li><code>archetype_instance</code></li>
<li>etc.</li>
</ul>

<p>
This is not very nice but it does solve the problem at hand. We can
then associate these with physical models. Alternatively we could use
a more neutral name like <code>_properties</code>, <code>_configuration</code>&#x2026; Actually
we already had some suitable types for enablement, they can be
repurposed for this.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>add transform to populate meta-model properties</li>
<li>update enablement to use the properties, deprecate existing ones.</li>
<li>merge local enablement transform with the reading of local
properties; merge global enablement transform with the reading of
meta-model properties. Add comments on local facet (for
profiles). Add the missing properties to the global field groups.</li>
<li>actually we can just rename both transforms instead of creating new
ones.</li>
<li>backends and parts also need a file path, just like artefacts.</li>
<li>the meta-model properties also need a file path, which represents
the component path. Paths can then be computed "recursively": the
backend path is the component path plus the backend directory and so
forth.</li>
<li>that which we called "meta-model" in the PM is really the "component
meta-model". In the future as we model more physical aspects we will
have other kinds of meta-models (product, family, etc.). The "model"
is really the component model because its an instance of a
component. The product model will be made up of artefacts and will
have parts and so forth but it will be different from the component
model. Or perhaps we will just have other kinds of components inside
the product model. In which case we need to consider having a notion
of "component types" and possibly "component groups"
(e.g. "projects").</li>
<li>technical spaces and their associated versions should be declared by
the text models and should be part of the PM. The TS should be
declared on the "global" text model so that backends can reuse them
(e.g. we can declare XML with associated extensions and then use it
where required).</li>
</ul>
</div>
</div>

<div id="outline-container-org61bf14e" class="outline-4">
<h4 id="org61bf14e"><span class="section-number-4">3.1.69</span> Improve support for references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-69">
<p>
At present we have limited support for references in the presence of
variability. This is because once we start changing configuration
points such as the backend directory, facet directories etc, in a
model which is referenced from another model then the path resolution
will start to fail. This is because we expect all models to have the
same configuration for all configuration elements that affect file
paths. Since they do at present we never noticed this problem.
</p>

<p>
The correct solution is to introduce reference models and reference
elements. These just need to have a small number of properties:
</p>

<ul class="org-ul">
<li>configuration of root module;</li>
<li>model and element logical name, as well as meta-element name.</li>
</ul>

<p>
With this we could also stop creating elements for referenced models
which would probably result on a major reduction of processing
time. Then we have two ways of introducing these models:
</p>

<ol class="org-ol">
<li>"the best way": do not fully parse reference models at all, just
extract the reference properties. This will require a lot of
changes on the pipeline.</li>
<li>"the quick hack": for all references, load the codec model into the
logical model and then convert it into a reference model. We do a
lot of unnecessary processing but it should be easier.</li>
</ol>

<p>
We could even start by taking approach 2 and then eventually move to
approach 1. Either way we need to do this once we move to the new
world of dependency generation.
</p>
</div>
</div>

<div id="outline-container-org969db16" class="outline-4">
<h4 id="org969db16"><span class="section-number-4">3.1.70</span> Replace <code>facet_default</code> with labels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-70">
<p>
We need to stop using the enumeration to determine the canonical
header and use instead the new labelling mechanism.
</p>

<p>
The right label is probably <code>transparent</code>.
</p>
</div>
</div>

<div id="outline-container-org2a1542f" class="outline-4">
<h4 id="org2a1542f"><span class="section-number-4">3.1.71</span> Add dependency generation to PM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-71">
<p>
We should store the dependencies in the following format:
</p>

<ul class="org-ul">
<li>relative path</li>
<li>dot notation</li>
<li>colon notation</li>
<li>header guard: not very nice but its the easiest way to solve this
problem for now.</li>
</ul>

<p>
Archetypes should record their own information for this. This involves
reading meta-data for certain cases (e.g. PDMs). One archetype can
have more than one of these entries. We could map this like an RPM:
</p>

<ul class="org-ul">
<li>provides</li>
<li>requires</li>
</ul>

<p>
or
</p>

<ul class="org-ul">
<li>exports</li>
<li>imports</li>
</ul>

<p>
Once we are generating the provides/exports we can then use the maps
to populate the imports.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add dependencies between artefacts in the PM</b>
</p>

<p>
During logical model conversion, we need to create a map in the
physical model capturing for each artefact:
</p>

<ul class="org-ul">
<li>id of the dependent element</li>
<li>archetype</li>
<li>relation type</li>
</ul>

<p>
Note however that the full purpose of this transform is to resolve
this triplet into a relative path to create a dependency. So we may
not need to store this in the model and just have it in the transform
as an intermediate state.
</p>

<p>
For C# dependencies are written as the fully qualified element
name. We then need further processing to determine what the using
statements should be. As we do not have any usings at present this
will have to be handled in another story. For now we should just make
sure we record the dependencies.
</p>
</div>
</div>

<div id="outline-container-org517aefd" class="outline-4">
<h4 id="org517aefd"><span class="section-number-4">3.1.72</span> Add archetype ownership model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-72">
<p>
Archetypes can be owned by either a part or directly by a backend. In
the future, they can also be owned by a product, a component, etc. We
don't need to worry about this yet. Parts are owned by a backend. We
need to ensure the current code supports this correctly. Archetypes
that live at the project level must be owned by the backend, not the
part.
</p>
</div>
</div>

<div id="outline-container-org40fe21a" class="outline-4">
<h4 id="org40fe21a"><span class="section-number-4">3.1.73</span> Implement dependencies in terms of new physical types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-73">
<ul class="org-ul">
<li>add dependency types to physical model.</li>
<li>add dependency types to logical model, as required.</li>
<li>compute dependencies in generation. We need a way to express
dependencies as a file dependency as well as a model
dependency. This caters for both C++ and C#/Java.</li>
<li>remove dependency code from C++ and C# model.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>in light of the new physical model, we need a transform that calls
the formatter to obtain dependencies. The right way to do this is to
have another registrar (<code>dependencies_transform</code>?) and to have the
formatters implement both interfaces. This means we can simply not
implement the interface (and not register) when we have no
dependencies - though of course given the existing wale
infrastructure, we will then need yet another template for
formatters which do not need d</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Formatter dependencies and model processing</b>
</p>

<p>
At present we are manually adding the includes required by a formatter
as part of the "inclusion<sub>dependencies</sub>" building. There are several
disadvantages to this approach:
</p>

<ul class="org-ul">
<li>we are quite far down the pipeline. We've already passed all the
model building checks, etc. Thus, there is no way of knowing what
the formatter dependencies are. At present this is not a huge
problem because we have so few formatters and their dependencies are
mainly on the standard library and a few core boost models. However,
as we add more formatters this will become a bigger problem. For
example, we've added formatters now that require access to
variability headers; in an ideal world, we should now need to have a
reference to this model (for example, so that when we integrate
package management we get the right dependencies, etc).</li>
<li>we are hard-coding the header files. At present this is not a big
problem. To be honest, we can't see when this would be a big
problem, short of models changing their file names and/or
locations. Nonetheless, it seems "unclean" to depend on the header
file directly.</li>
<li>the dependency is on c++ code rather than expressed via a model.</li>
</ul>

<p>
In an ideal world, we would have some kind of way of declaring a
formatter meta-model element, with a set of dependencies declared via
meta-data. These are on the model itself. They must be declared
against a specific archetype. We then would process these as part of
resolution. We would then map the header files as part of the existing
machinery for header files.
</p>

<p>
However one problem with this approach is that we are generating the
formatter code using stitch at present. For this to work we would need
to inject a fragment of code into the stitch template somehow with the
dependencies. Whilst this is not exactly ideal, the advantage is that
we could piggy-back on this mechanism to inject the postfix fields as
well, so that we don't need to define these manually in each
model. However, this needs some thinking because the complexity of
defining a formatter will increase yet again. When there are problems,
it will be hard to troubleshoot.
</p>

<p>
<b>Move dependencies into archetypes</b>
</p>

<p>
Actually the dependencies will be generated at the kernel level
because 99% of the code is kernel specific. However, we need to make
it an external transform. We need to figure out an interface that
supplies archetypes with the data needed to create the dependencies
container.
</p>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>create the locator in the C++ external transform</li>
<li>create a dependencies transform that uses the existing include
generation code.</li>
</ul>

<p>
<b>Previous understanding</b>
</p>

<p>
It seems all languages we support have some form of "dependencies":
</p>

<ul class="org-ul">
<li>in c++ these are the includes</li>
<li>in c# these are the usings</li>
<li>in java these are the imports</li>
</ul>

<p>
So, it would make sense to move these into yarn. The process of
obtaining the dependencies must still be done in a kernel dependent
way because we need to build any language-specific structures that the
dependencies builder requires. However, we can create an interface for
the dependencies builder in yarn and implement it in each kernel. Each
kernel must also supply a factory for the builders.
</p>

<p>
<b>Tidy-up of inclusion terminology</b>
</p>

<p>
Random notes:
</p>

<ul class="org-ul">
<li>imports and exports</li>
<li>some types support both (headers)</li>
<li>some support imports only (cpp)</li>
<li>some support neither (cmakelists, etc).</li>
</ul>
</div>
</div>

<div id="outline-container-org2039070" class="outline-4">
<h4 id="org2039070"><span class="section-number-4">3.1.74</span> Top-level "inclusion required" should be "tribool"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-74">
<p>
One of the most common use cases for inclusion required is to have it
set to true for all types where we provide an override, but false for
all other cases. This makes sense in terms of use cases:
</p>

<ul class="org-ul">
<li>either we need to supply some includes; in which case where we do
not supply includes we do not want the system to automatically
compute include paths;</li>
<li>or we don't supply any includes, in which case:
<ul class="org-ul">
<li>we either don't require any includes at all (hardware built-ins);</li>
<li>or we want all includes to be computed by the system.</li>
</ul></li>
</ul>

<p>
The problem is that we do not have a way to express this logic in the
meta-data. The only way would be to convert the top-level
<code>requires_includes</code> to an enumeration:
</p>

<ul class="org-ul">
<li>yes, compute them</li>
<li>yes, where supplied</li>
<li>no</li>
</ul>

<p>
We need to figure out how to implement this. For now we are manually
adding flags.
</p>
</div>
</div>

<div id="outline-container-orgbb0e9d9" class="outline-4">
<h4 id="orgbb0e9d9"><span class="section-number-4">3.1.75</span> Implement meta-name validator correctly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-75">
<p>
The logic in the meta- name validator is completely wrong. We are
checking for facet defaults without taking into account the logical
model element component. Thus, there are fundamental problems with the
meta-model validator that are not easy to fix. We need a facet default
for every logical meta-model element. That is, we need to loop through
all logical meta-model elements and ensure they have a facet default;
but this should only be done for meta-model elements which support a
facet default. This cannot be done until:
</p>

<ul class="org-ul">
<li>we know which elements require a facet default;</li>
<li>we have created a logical meta-model.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Set expectation for facet default</b>
</p>

<p>
At present we are only warning when a facet does not have a facet
default. This is because some facets do not have facet defaults (such
as build, visual studio, etc). However, we know this upfront so on the
facet factory we should set up the expectation. Then we can throw.
</p>
</div>
</div>

<div id="outline-container-org1f724bd" class="outline-4">
<h4 id="org1f724bd"><span class="section-number-4">3.1.76</span> Update archetype generator to handle decoration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-76">
<p>
Once relations have been moved into the generator type, we need to
create a special handling for archetypes.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>instead of obtaining all of its relations from the archetype, we
need to also query the logical model element. these will supply
additional constant relations which need to be transformed into
physical counterparts and resolved.</li>
<li>relations in archetype can be ignored entirely for the purposes of
artefact projection.</li>
<li>the archetype transform can then be implemented as a "regular"
transform, handling decoration, boilerplate, namespaces, includes,
etc. We need to remove the includes from the stitch template.</li>
<li>once all of this is done, remove support for includes and
configuration from stitch.</li>
</ul>
</div>
</div>

<div id="outline-container-orgba3268e" class="outline-4">
<h4 id="orgba3268e"><span class="section-number-4">3.1.77</span> Create a logical meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-77">
<p>
At present we did a quick hack and created the notion of meta-names in
the logical model. In fact, what we really need is the idea of a
"meta-element". We don't need this to be done completely cleanly; the
meta-element is merely just an object really. We just need to have a
way to add:
</p>

<ul class="org-ul">
<li>virtual meta-element property to the base type.</li>
<li>static meta-element in each leaf.</li>
<li>generated code which constructs a static meta-element for each
descendant.</li>
<li>meta-data to supply meta-element properties. We just need maybe two:
stereotype and description.</li>
<li>transform that generates the logical meta-model. It should be
indexed by stereotype.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the LMM can be part of the boostrapping phase as is the PMM.</li>
<li>the stereotype, which is defined in <code>ident</code> replaces the meta-name.</li>
<li>the meta-name factory, transforms etc are deprecated.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Replace meta-model IDs with stereotypes</b>
</p>

<p>
We probably already have a story for this, check backlog.
</p>

<p>
<b>Generating a meta-model for dogen</b>
</p>

<p>
We are making use of coding meta-types a fair bit in dogen:
</p>

<ul class="org-ul">
<li>we have meta-names, which we use for things such as indexing,
formatter discovery etc.</li>
<li>we need to know which types are generatable.</li>
<li>we are associating meta-types with technical spaces (intrinsic).</li>
</ul>

<p>
It would be nice if somehow we were able to generate some basic
reflection code that enabled us to ask for a meta-model's element
meta-class. For example, given an element, we should be able to do:
</p>

<pre class="example">
element.meta_class().intrinsic_technical_space()
</pre>


<p>
The <code>meta_class()</code> method should be static and code-generated by
dogen. This still requires a lot of thinking though. Look for
reflection stories in backlog.
</p>

<p>
We could also have a way to access a collection of all
meta-types. This would be useful in order to generate a list of all
the valid stereotypes which as model elements. However, for this there
is some mapping required as we want
<code>masd::coding::meta_model::enumeration</code> to map to <code>masd::enumeration</code>.
</p>

<p>
Actually the right approach for this is to annotate all elements in
coding as "meta-elements". They would then have all of these
properties as features (stereotypes, etc). The code generator would
then generate static methods for each class with this information. We
could then return a <code>meta_class</code> from these classes, populated with
relevant data.
</p>

<p>
For this to work we need to define a <code>meta_class</code> meta-element, which
has properties such as:
</p>

<ul class="org-ul">
<li>stereotype</li>
<li>the comments become the documentation of the stereotype</li>
<li>is generatable</li>
</ul>

<p>
Dogen then generates the appropriate code for these types, as required
by Dogen (pun intended).
</p>

<p>
Interestingly, we have been binding formatters against model elements
via the meta-name, but perhaps what we are really looking for is the
stereotype instead. The meta-name is more or less meaningless but the
stereotype is used by the UML profile. Of course we can't just call it
"stereotype because that could mean anything, but it is in effect some
kind of meta-type. The formatter binds against this, as does the UML
modeling element; the meta-name and the assets class is simply an
implementation detail.
</p>

<p>
Merged stories:
</p>

<p>
<b>Meta-element configuration</b>
</p>

<p>
It is becoming obvious that there is a need to explicitly model
meta-elements. A good example are the wale templates for handcrafted
types. Say we want to associate a wale template with <code>entry_point</code>. We
need one for C# and one for C++. We have the following alternatives:
</p>

<ul class="org-ul">
<li>the user needs to manually supply these as meta-data parameters
every time it creates an entry point.</li>
<li>next level is to have profiles: we could define a profile with these
parameters and the user is responsible for applying it to entry
points as required. This is flexible because users could choose
different wale templates. However, its painful that there isn't a
default wale template.</li>
<li>we could hard-code the default wale template into the field's value,
so that you'd get that value if you don't supply any. At least now
there is a default, but its hard-coded.</li>
<li>finally, if we could create a <code>&lt;&lt;metaclass</code> in a diagram, we could
then add the default values there <span class="underline">as data</span>.</li>
</ul>

<p>
A related point is to do with cases where the meta-element requires
specific configuration:
</p>

<ul class="org-ul">
<li>entry point, interface: should be types only.</li>
</ul>

<p>
For these cases, it would be nice if we could associate a stereotype
with the metaclass and then all instances would inherit these.
</p>

<p>
This is actually simpler to implement than it may appear. We just need
to have a meta-element of type <code>metaclass</code>, with an annotation and a
name. The name of the metaclass is the element it is configuring
(e.g. <code>entry_point</code>). We could have a transform that sets the static
stereotype of the element based on the name for good measure. Then,
during the profile merging, we could simply merge first its annotation
into all elements of this type. Then we would continue with the
profile merging. We could also do a hack and have a <code>root_module</code>
<code>metaclass</code> which could be used for defaults. However, it is not clear
when we should use this as opposed to plain stereotypes. The good
thing about stereotypes is that we make the relationships explicit,
whereas with <code>metaclass</code> we are making them slightly less transparent.
</p>

<p>
If dogen had a way to set static properties, we could have a transform
that updated all elements with their metaclass, so that you could
simply do:
</p>

<pre class="example">
element.metaclass().name();
element.metaclass().annotation();
</pre>


<p>
This should be very simple to do, we just need a way to know if an
attribute is static or not.
</p>

<p>
<b>Consider creating a meta-element for logical elements</b>
</p>

<p>
We probably either have a story for this or these ideas are scattered
over a few stories. At present we have a number of properties
associated with assets (i.e. logical) model elements which we set
manually (each of these probably has a separate story):
</p>

<ul class="org-ul">
<li>meta-name</li>
<li>stereotype</li>
<li>whether a type is intrinsically generatable or not</li>
<li>RGB colour</li>
<li>whether the element supports dynamic stereotypes or not.</li>
</ul>

<p>
There are probably more. These are all functions of the meta-type we
are modeling. Just like we need "formatters" as a meta-type, we also
need a way to express these within the model itself. The ideal
solution would be to have a meta-type for these elements such that
when we code-generate, we can add the additional elements that are
specific to the logical model meta-types. However, the snag with that
approach is that these elements have all attributes of an <code>object</code>
plus these additional fields. We would have to create templates that
intersperse object functionality with this meta-data, resulting on a
lot of code duplication.
</p>

<p>
A better approach is to copy what we did for ORM. We can have
additional stereotypes associated with a meta-type, and those would
result in the population of meta-data information. If those are
present then we emit code for it (seems a bit much to create a facet
for it as we did with ORM).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we probably don't need the meta-name. We just use it to bind
formatters to meta-types. We can use the "intrinsic stereotype" for
this.</li>
<li>we could use the same ORM-like approach for formatters and just
extend object.</li>
<li>we probably need a namespace for masd types. At present we have
<code>templating</code> but these are actually masd/dogen specific templates,
so they should also be in the same namespace.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Investigate use of <code>is_element_type</code> in stereotypes</b>
</p>

<p>
We seem to only be considering a subset of the elements when doing the
stereotype transform, yet its all working. Need to figure out why, and
if this is no longer required, remove this method.
</p>

<p>
<b>Add logical entity for meta-model elements</b>
</p>

<p>
We now have a clear pattern for all logical model elements: they need
a stereotype and an associated description, which must be registered
somewhere (to avoid duplication and for documentation purposes). This
is known at compile time - i.e. static.
</p>

<p>
We could easily create a logical model representation of these
elements and then allow users to annotate types with it. However, they
must still remain <code>objects</code> because we still need to be able to model
regular OO relationships.
</p>
</div>
</div>

<div id="outline-container-org6bab357" class="outline-4">
<h4 id="org6bab357"><span class="section-number-4">3.1.78</span> Add file extensions to decoration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-78">
<p>
Create something really simple:
</p>

<ul class="org-ul">
<li>extension groups</li>
<li>extensions</li>
</ul>

<p>
Model this after modelines and modeline groups. We just need to define
an extension group that has all the extensions we have currently in
use. Extensions belong to a TS. Extensions can have a label. If there
is more than one extension for a given TS they must have a
label. Example:
</p>

<p>
<code>extension_type:odb_headers</code>
</p>

<p>
We then need to label archetypes with these. This is only needed for
cases where there is more than one extension for a given TS (c++
headers and implementation).
</p>
</div>
</div>

<div id="outline-container-orgccaac0e" class="outline-4">
<h4 id="orgccaac0e"><span class="section-number-4">3.1.79</span> Move decoration to <code>text</code> model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-79">
<p>
Last sprint we thought that decorations belonged to the logical
model. We were partially right; the part of decorations that refers
only to the modeling of entities is correctly placed in the logical
model. However, the transformation of those elements into text needs
to be placed in the text model. And the output of those
transformations should rightly belong to the archetype set (preamble,
postamble) if not to the artefact themselves. However, for this to
work we need a way to associate technical spaces with artefacts. Then
we can simply ask for all technical spaces in a plane. Or
alternatively we could try to generate the decoration using only the
meta-data. Basically this needs to be done when creating either the
text model or the artefact repository.
</p>
</div>
</div>

<div id="outline-container-org330c117" class="outline-4">
<h4 id="org330c117"><span class="section-number-4">3.1.80</span> Consider creating a label for generated files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-80">
<p>
We could label all files which are not generated as "manual". Not
clear how exactly that would be useful.
</p>
</div>
</div>

<div id="outline-container-org944fb51" class="outline-4">
<h4 id="org944fb51"><span class="section-number-4">3.1.81</span> Replace initialisers with facet-based initialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-81">
<p>
Now that we have facets, archetypes, etc as proper meta-model
elements, it is becoming clear that the initialiser is just a facet in
disguise. We have enough information to generate all initialisers as
part of the code generation of facets and backends. Once we do this,
we have reached the point where it is possible to create a new
meta-model element and add a formatter for it and code will be
automatically generated without any manual intervention. Similarly,
deleting formatters will delete all traces of it from the code
generator.
</p>
</div>
</div>

<div id="outline-container-org54c4545" class="outline-4">
<h4 id="org54c4545"><span class="section-number-4">3.1.82</span> Injector types with regards to containment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-82">
<p>
It seems we have two models for injectors:
</p>

<ul class="org-ul">
<li>those where element containment is represented through nesting,
e.g. XML, JSON, org-mode. These can of course be flat too, but its
natural to represent elements as containers.</li>
<li>those where element containment is represented through "links",
e.g. Dia. When we represent containment through links, we need to
create a graph of the elements and then transform them into a
qualified path.</li>
</ul>

<p>
At present we left it to the dia injector to resolve the link
containment. It makes more sense to model the containment type in the
injection model and then to have a transform that does the graphing
for link models. We also need a transform that does the name nesting
for nested models. Both do nothing for the converse case. This will
simplify injector code.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>linked models must supply the original model ID as well as container
ID. Nested models may or may not supply this information.</li>
<li>we should transform nested models into flat models as part of the
injection chain. The final model should be a flat model.</li>
<li>perhaps we should have a notion of a nested model and a nested
element. This way the type system encodes this information.</li>
</ul>
</div>
</div>

<div id="outline-container-org4e218fa" class="outline-4">
<h4 id="org4e218fa"><span class="section-number-4">3.1.83</span> Mine the build2 layout terminology&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-83">
<p>
It seems build2 is modeling a lot of concepts that are similar to ours
in project layout. We should use their terminology where possible.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://build2.org/bdep/doc/bdep-new.xhtml#src-layout">bdep-new source layout</a></li>
<li><a href="https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#proj-struct">Canonical Project Structure</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdccaeb9" class="outline-4">
<h4 id="orgdccaeb9"><span class="section-number-4">3.1.84</span> Make physical model name a qualified name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-84">
<p>
At present we are setting up the extraction model name from the simple
name of the model. It should really be the qualified name. Hopefully
this will only affect tracing and diffing.
</p>
</div>
</div>

<div id="outline-container-org8d0b089" class="outline-4">
<h4 id="org8d0b089"><span class="section-number-4">3.1.85</span> Add a PMM enablement satisfiability transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-85">
<p>
For now this transform can simply check that there are no enabled
archetypes that depend on disabled archetypes. In the future we could
have a flag that enables archetypes as required.
</p>

<p>
Merged stories:
</p>

<p>
<b>Investigate the use of solvers for enablement</b>
</p>

<p>
A long standing problem we've had in Dogen is how to solve enablement
requirements. This appears to be a well-researched problem within
MDE. One such solution is Alloy.
</p>

<p>
Since Alloy is written in Java it will not be easy to integrate it
within the Dogen workflows. However, perhaps we can use it as a
starting point to understand how SAT solving can be used to address
our problem. If we could create an output that targets alloy and then
get alloy to produce a solution for our problem, we can then try to
understand how the alloy language maps to SAT solving and remove alloy
from the process. This should be doable given we have very simple
needs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.doc.ic.ac.uk/project/examples/2007/271j/suprema_on_alloy/Final%20Report/LaTeX/report.pdf">A Guide To Alloy</a>: very simple guide on how to use Alloy.</li>
<li><a href="https://github.com/gsdlab/claferIG">claferIG GitHuub repo</a>: Support for reasoning on Clafer models by
instantiation and counter example generation.</li>
<li><a href="https://alloytools.org/">https://alloytools.org/</a>: home page for Alloy.</li>
<li><a href="https://www.amazon.co.uk/Software-Abstractions-Logic-Language-Analysis/dp/0262017156">Software Abstractions: Logic, Language, and Analysis (The MIT
Press)</a>: Alloy book.</li>
<li><a href="https://github.com/AlloyTools/org.alloytools.alloy">Alloy GitHub repo</a></li>
<li><a href="https://github.com/necavit/li-sat-solver">li-sat-solver GitHub repo</a>: Very simple C++ SAT solver
implementation, based on the <a href="http://en.wikipedia.org/wiki/DPLL_algorithm">DPLL</a> algorithm.</li>
<li><a href="https://sahandsaba.com/understanding-sat-by-implementing-a-simple-sat-solver-in-python.html">Understanding SAT by Implementing a Simple SAT Solver in Python</a></li>
<li><a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/">Modern SAT solvers: fast, neat and underused (part 1 of N)</a></li>
<li><a href="https://github.com/master-keying/minisat/">Mini-SAT GitHub repo</a>: Production-ready MiniSAT. Forked off MiniSAT
2.2, this repository aims at providing a production-ready version of
the famous library.</li>
<li><a href="https://github.com/dobrichev/fsss2">fsss2 GitHub repo</a>: Fast Simple Sudoku Solver 2.</li>
<li><a href="https://www.reddit.com/r/cpp/comments/94dkme/modern_sat_solvers_fast_neat_and_underused_part_1/">reddit: Modern SAT solvers: fast, neat and underused (part 1 of N)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">Wikipedia: Conjunctive normal form</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6ed1ab7" class="outline-4">
<h4 id="org6ed1ab7"><span class="section-number-4">3.1.86</span> Add a PM enablement satisfiability transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-86">
<p>
To start with, this should just check to see if any of the
dependencies are disabled. If so it throws. In the future we can add
solving.
</p>
</div>
</div>

<div id="outline-container-orge3a5ba0" class="outline-4">
<h4 id="orge3a5ba0"><span class="section-number-4">3.1.87</span> KVPs with invalid field name still works&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-87">
<p>
As a test we created an invalid KVP:
</p>

<pre class="example">
+#DOGEN masd.labelz.a_labelz=a,b,c
</pre>


<p>
This should have failed because the name of the KVP is <code>label</code>, so
<code>labelz</code> shouldn't have matched. However there was no error. We are
probably adding the <code>z.</code> to the key. We need to check how variability
is handling this.
</p>
</div>
</div>

<div id="outline-container-org0674ac5" class="outline-4">
<h4 id="org0674ac5"><span class="section-number-4">3.1.88</span> Add a PM transform to prune disabled artefacts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-88">
<p>
We must first start by expanding the physical space into all possible
points. Once enablement is performed though we can prune all artefacts
that are disabled. Note that we cannot prune based on global
information because archetypes may be enabled locally. However, once
all of the local information has been processed and the enabled flag
has been set, we can then remove all of those with the flag set to
false.
</p>

<p>
In a world with solving, we just need to make sure solving is slotted
in after enablement and before pruning. It should just work.
</p>

<p>
This transform is done within the <code>m2t</code> model, not the <code>physical</code>
model, because we need to remove the artefacts from the <code>m2t</code>
collection.
</p>
</div>
</div>

<div id="outline-container-org52c8f56" class="outline-4">
<h4 id="org52c8f56"><span class="section-number-4">3.1.89</span> Add primitives to feature selector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-89">
<p>
It would be nice to be able to associate a primitive to the selector,
so that instead of:
</p>

<pre class="example">
ftg.enabled = s.get_by_name(fct.value(), enabled_feature);
</pre>


<p>
We could simply do:
</p>

<pre class="example">
ftg.enabled = s.get_by_name(fct, enabled_feature);
</pre>


<p>
This would also mean that you couldn't use a string by mistake.
</p>
</div>
</div>

<div id="outline-container-orgb5b4bf4" class="outline-4">
<h4 id="orgb5b4bf4"><span class="section-number-4">3.1.90</span> Add the notion of a major and a minor technical space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-90">
<p>
When we move visual studio and other elements out of the current
technical spaces, we will need some way of distinguishing between a
"primary" technical space (e.g. C++, C# etc) and a "secondary"
technical space (e.g. visual studio, etc). We could use emacs'
convention and call these major and minor technical spaces.
</p>

<p>
This should be a property of the backend.
</p>
</div>
</div>

<div id="outline-container-orgab722bb" class="outline-4">
<h4 id="orgab722bb"><span class="section-number-4">3.1.91</span> Add documentation to archetypes headers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-91">
<p>
At present we are ignoring the documentation we supply with the
archetype. We need to populate the wale KVPs with it and make use of
it in the wale template.
</p>
</div>
</div>

<div id="outline-container-org08e7aa4" class="outline-4">
<h4 id="org08e7aa4"><span class="section-number-4">3.1.92</span> Associate git details with components&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-92">
<p>
If the model of the component had access to the git repository
location then we could make use of it. The primary component could
have links to all of the secondary components; you can then point
dogen to the primary component and it would create the "standard" git
layout, e.g.:
</p>

<pre class="example">
primary.remote
primary.local
secondary_1.remote
secondary_1.local
...
</pre>


<p>
If we had backup remotes, we could also setup the remotes
(e.g. bitbucket, etc). In effect, dogen would act product level
operations (build all components, run all tests, etc). It would know
for each component what the appropriate command is (e.g. build2,
cmake, dotnet, etc).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>should we have a top-level <code>masd</code> binary for this kind of stuff?
seems like there is a pretty obvious boundary between plain code
generation and product level operations such as these. The <code>masd</code>
component could be built using dogen's libraries, but at least this
way we wouldn't have to link against git etc for all of these
product level use cases.</li>
</ul>
</div>
</div>

<div id="outline-container-org85af324" class="outline-4">
<h4 id="org85af324"><span class="section-number-4">3.1.93</span> Consider modeling primitive value as attribute&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-93">
<p>
At present we have used meta-data:
</p>

<pre class="example">
#DOGEN masd.primitive.underlying_element=float
</pre>


<p>
It may be more obvious if we model these as an attribute called
value. It would make the type of the primitive more visible.
</p>
</div>
</div>

<div id="outline-container-org100cb08" class="outline-4">
<h4 id="org100cb08"><span class="section-number-4">3.1.94</span> Add the ability to cast an enum to the underlying type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-94">
<p>
As per stack overflow, is now not easy to convert an enum to its
underlying type. However, it also proposes some simple solutions:
</p>

<p>
C++ 11:
</p>

<pre class="code"><code><span style="color: #339CDB; font-weight: bold;">template</span> <span style="color: #C586C0;">&lt;</span><span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #35CDAF;">E</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #339CDB; font-weight: bold;">constexpr</span> <span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #339CDB;">std</span>::<span style="color: #339CDB;">underlying_type</span><span style="color: #C586C0;">&lt;</span><span style="color: #35CDAF;">E</span><span style="color: #C586C0;">&gt;</span>::<span style="color: #35CDAF;">type</span> <span style="color: #D9DAA2;">to_underlying</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">E</span> <span style="color: #85DDFF;">e</span><span style="color: #C586C0;">)</span> <span style="color: #339CDB; font-weight: bold;">noexcept</span> <span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">return</span> <span style="color: #339CDB; font-weight: bold;">static_cast</span><span style="color: #DB8E73;">&lt;</span><span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #339CDB;">std</span>::<span style="color: #339CDB;">underlying_type</span><span style="color: #579C4C;">&lt;</span><span style="color: #35CDAF;">E</span><span style="color: #579C4C;">&gt;</span>::<span style="color: #35CDAF;">type</span><span style="color: #DB8E73;">&gt;(</span>e<span style="color: #DB8E73;">)</span>;
<span style="color: #C586C0;">}</span>
<span style="color: #339CDB;">std</span>::cout &lt;&lt; foo<span style="color: #C586C0;">(</span>to_underlying<span style="color: #DB8E73;">(</span><span style="color: #339CDB;">b</span>::B2<span style="color: #DB8E73;">)</span><span style="color: #C586C0;">)</span> &lt;&lt; <span style="color: #339CDB;">std</span>::endl;
</code></pre>

<p>
C++ 14:
</p>

<pre class="code"><code><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #C586C0;">&lt;</span><span style="color: #DB8E73;">type_traits</span><span style="color: #C586C0;">&gt;</span>

<span style="color: #339CDB; font-weight: bold;">template</span> <span style="color: #C586C0;">&lt;</span><span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #35CDAF;">E</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #339CDB; font-weight: bold;">constexpr</span> <span style="color: #339CDB; font-weight: bold;">auto</span> <span style="color: #D9DAA2;">to_underlying</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">E</span> <span style="color: #85DDFF;">e</span><span style="color: #C586C0;">)</span> <span style="color: #339CDB; font-weight: bold;">noexcept</span>
<span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">return</span> <span style="color: #339CDB; font-weight: bold;">static_cast</span><span style="color: #DB8E73;">&lt;</span><span style="color: #339CDB;">std</span>::<span style="color: #35CDAF;">underlying_type_t</span><span style="color: #579C4C;">&lt;</span><span style="color: #35CDAF;">E</span><span style="color: #579C4C;">&gt;</span><span style="color: #DB8E73;">&gt;(</span>e<span style="color: #DB8E73;">)</span>;
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
We could easily add these methods to our enums.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/8357240/how-to-automatically-convert-strongly-typed-enum-into-int">How to automatically convert strongly typed enum into int?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8c8b25a" class="outline-4">
<h4 id="org8c8b25a"><span class="section-number-4">3.1.95</span> Add <code>enum</code> size constant for all enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-95">
<p>
A common use case is to declare an array of the size of an
enumeration. It should take into account that invalid is not a valid
value. We could declare a const named after the enum that contains the
size. In fact we could declare with and without invalid.
</p>

<p>
Actually for our use case we need to remove invalid, so this is not
needed. Just total count will do. In terms of the name, SO says:
</p>

<div class="epigraph"><blockquote>
<p>
Length() tends to refer to contiguous elements - a string has a length
for example.
</p>

<p>
Count() tends to refer to the number of elements in a looser
collection.
</p>

<p>
Size() tends to refer to the size of the collection, often this can be
different from the length in cases like vectors (or strings), there
may be 10 characters in a string, but storage is reserved for 20. It
also may refer to number of elements - check source/documentation.
</p>

<p>
Capacity() - used to specifically refer to allocated space in
collection and not number of valid elements in it. If type has both
"capacity" and "size" defined then "size" usually refers to number of
actual elements.
</p>

</blockquote></div>

<p>
C# calls it <code>Length</code>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/300522/count-vs-length-vs-size-in-a-collection">count vs length vs size in a collection</a></li>
</ul>
</div>
</div>

<div id="outline-container-org61b38ce" class="outline-4">
<h4 id="org61b38ce"><span class="section-number-4">3.1.96</span> Improve referencing status&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-96">
<p>
We did a very quick hack to move inclusion status into the physical
model. However, there are a number of things that need looking at:
</p>

<ul class="org-ul">
<li>we should make referability a meta-data parameter so that we can use
profiles. We should also do the same for
<code>wale_template_reference</code>. There is no advantage of using an
attribute and we can save a lot of time by using profiles.</li>
<li>note also that some archetypes are intrinsically non-referable:
<code>cpp</code>, <code>CMakeLists</code> etc. Perhaps we could make this a property of
the kind as well.</li>
</ul>
</div>
</div>

<div id="outline-container-org8c62d03" class="outline-4">
<h4 id="org8c62d03"><span class="section-number-4">3.1.97</span> Consider renaming <code>wale</code> to <code>mustache</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-97">
<p>
We need to rename all of the wale templates to mustache.
</p>

<p>
Merged stories:
</p>

<p>
<b>Consider renaming <code>wale</code> to <code>tangle</code></b>
</p>

<p>
Wale and stitch are remnant from the sewing days. Whilst stitch is
still vaguely appropriate, we can't even remember what wale stands
for. We should use a more domain-specific term such as weave or
tangle. In fact, we probably should rename <code>stitch</code> to <code>weave</code> given
it weaves text with code, and find a better name for wale. Its not
"tangling" (given tangling, as we understand it from org-mode, is just
another name for weaving). We need to look into logic-less templates
terminology.
</p>

<p>
Actually this is a mistake. Wale is just a poor-person's mustache and
will be replaced by a proper implementation of mustache as soon as we
can. We should instead start calling it mustache and explain this is
just a temporary fix.
</p>

<p>
<b>Consider renaming logic-less templates</b>
</p>

<p>
Originally we though this was a good name because it was used by some
domain experts, but it seems it generates more confusion than
anything. It may just be a term used by mustache and other niche
template groups. We should probably rename it to text templates given
most domain experts know what that means.
</p>

<p>
In addition, the templates should be specific to their types; we need
to know if its a mustache template or a stitch template because the
processing will be very different. The templates should be named after
their type in the logical model. Rename these to wale templates.
</p>

<p>
Actually its not yet clear if the existing logic could not be extended
to other template types. We should wait until we implement it front to
back and then make a decision.
</p>

<p>
The most obvious thing is just to call the templates after their
actual name: mustache.
</p>
</div>
</div>

<div id="outline-container-org7a036a5" class="outline-4">
<h4 id="org7a036a5"><span class="section-number-4">3.1.98</span> Merging of collections does not overwrite keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-98">
<p>
In variability, given a profile with a collection C and an element
with a collection K, the merge of the two collections will result in
duplicate keys if an entry exists on both C and K. We should take K.
</p>
</div>
</div>

<div id="outline-container-orge11449a" class="outline-4">
<h4 id="orge11449a"><span class="section-number-4">3.1.99</span> Referability and logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-99">
<p>
We have modeled referability as a physical property but in reality its
a combination:
</p>

<ul class="org-ul">
<li>at the logical model level, we know if a model element can be
referred or not. We also know that referability works in sets:
classes of elements can refer to each other but not across other
classes. This requires building a proper taxonomy for referability.</li>
<li>at the physical level we inherit the logical referability
properties, but then in addition, we need to state that for each
facet and each logical model element, there exists one and only one
default archetype.</li>
</ul>

<p>
The domain model should reflect these findings.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we already have some kind of concept for this because we use this in
the resolver. Investigate how its being used.</li>
</ul>
</div>
</div>

<div id="outline-container-org646b28e" class="outline-4">
<h4 id="org646b28e"><span class="section-number-4">3.1.100</span> Remove empty tracing directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-100">
<p>
At present when you add regexes for tracing filtering, we create a lot
of empty directories. It doesn't seem easy to stop the directory
generation but perhaps we could add the tracing directory to the file
transforms and run the "remove empty directories" transform over it.
</p>
</div>
</div>

<div id="outline-container-org2b1ad41" class="outline-4">
<h4 id="org2b1ad41"><span class="section-number-4">3.1.101</span> Split enablement features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-101">
<p>
At present we are instantiating the <code>enabled</code> feature across the
entire <code>masd</code> template instantiation domain. This is a very
"efficient" way to do it because we only define one feature. However,
it also means its now possible to disable a facet or backend at the
element level. And worse, the binding point is global:
</p>

<pre class="example">
#DOGEN masd.variability.default_binding_point=any
#DOGEN masd.variability.generate_static_configuration=false
#DOGEN masd.variability.instantiation_domain_name=masd
</pre>


<p>
The right thing to do is to create four separate features, one for
the backend, one for the features and one for the archetype
(global). Then another one for the archetype, locally. Each with the
correct binding point.
</p>
</div>
</div>

<div id="outline-container-org2fe00d6" class="outline-4">
<h4 id="org2fe00d6"><span class="section-number-4">3.1.102</span> Dimension vs view vs perspective&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-102">
<p>
We need to find the definition for how these terms are used within
UML and see which one is more appropriate for MASD.
</p>
</div>
</div>

<div id="outline-container-org56852f7" class="outline-4">
<h4 id="org56852f7"><span class="section-number-4">3.1.103</span> Private and public includes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-103">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to hide some internal types from
users so that I don't increase coupling for no reason.
</p>

</blockquote></div>

<p>
NOTE: We should use the terms <code>internal</code> and <code>external</code> to avoid
confusion with C++ scopes. This follows Microsoft terminology for C#
assemblies.
</p>

<p>
At present we are making all headers in a model public. However, for
models such as cpp this doesn't make any sense since only one type
should be available to the outside world. What we really need is a
separation between public and private headers, a functionality similar
to <code>internal</code> in C#. In conjunction with using shared objects, this
should improve build times.
</p>

<p>
In order to do this:
</p>

<ul class="org-ul">
<li>add a new config parameter: default visibility to private or default
visibility to public. This is just so we don't have to mark all
types manually - instead we just need to mark the exceptions.</li>
<li>add two new stereotypes: <code>public</code> and <code>private</code>.</li>
<li>add enum to sml: <code>visibility_type</code> (check with .Net for
names). Valid values are <code>public</code>, <code>private</code>. Objects, enumerations,
etc will have this enum.</li>
<li>locator will now respect this value when producing an absolute file
path. If public files go under <code>include/public</code>, if private files go
under <code>include/private</code>.</li>
<li>CMakelists for the component will add to the include path the
private directory. Same for the spec CMakelists. Need to check that
this not add to the global include path.</li>
<li>CMakelists for the include files will only package the public
headers.</li>
<li>mark all the types accordingly in all our models. fix all the
ensuing breakage. we will probably need to move forward on the IoC
front in order for this to work as we don't want to expose
implementations - e.g. <code>workflow_interface</code> will be public but
<code>workflow</code> will be private; this means we need some kind of factory
to generate <code>workflow_interface</code>.</li>
</ul>

<p>
More thoughts on this:
</p>

<ul class="org-ul">
<li>we don't really need to have different directories for this; we
could just put all the include files in the same directory. At
packaging time, we should only package the public files (this would
have to be done using CPack).</li>
<li>also the GCC/MSVC visibility pragmas should take into account these
options and only export public types.</li>
<li>the slight problem with this is that we need some tests to ensure
the packages we create are actually exporting all public types; we
could easily have a public type that depends on a private type
etc. We should also validate yarn to ensure this does not
happen. This can be done by ensuring that a type marked as external
only depends on types also marked as external and so forth.</li>
<li>this could also just be a packaging artefact - we would only package
public headers. Layout of source code would remain the same.</li>
<li>when module support is available, we could use this to determine
what is exported on the module interfaces.</li>
</ul>
</div>
</div>

<div id="outline-container-org08e3dea" class="outline-4">
<h4 id="org08e3dea"><span class="section-number-4">3.1.104</span> Associate includes with model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-104">
<p>
The right solution for the formatter includes is to supply them as
meta-data in the model element. This has the advantage that we can
then make use of profiles. At present we have one way to supply
includes: the primary and secondary includes:
</p>

<pre class="example">
"masd.generation.cpp.io.class_header.primary_inclusion_directive": "&lt;boost/property_tree/json_parser.hpp&gt;",
"masd.generation.cpp.io.class_header.secondary_inclusion_directive": "&lt;boost/algorithm/string.hpp&gt;",
</pre>


<p>
This does a part of the job: we can associate up to two include
directives with one facet and element. However:
</p>

<ul class="org-ul">
<li>by using this machinery we are effectively replacing the original
include.</li>
<li>the includes will occur for anyone who references the type. Though
however, since the includes are applicable only to the class
implementation this is less of a problem. Technically its still
incorrect though because these are not the includes needed to use
the type but the includes needed to define the type.</li>
</ul>

<p>
For formatters, we kind of need to make the includes only happen when
we are building the formatter. If we could have a similar machinery,
but without adding to types referencing the type, this would give us a
way to declare all of the formatters dependencies. Then, we could
switch to building all of the stitch boilerplate outside of stitch and
supplying it as a KVP.
</p>
</div>
</div>

<div id="outline-container-org7dcca98" class="outline-4">
<h4 id="org7dcca98"><span class="section-number-4">3.1.105</span> Simplify the get for optional features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-105">
<p>
At present we do something like this for optional features:
</p>

<pre class="example">
if (s.has_configuration_point(fg.archetype_overwrite)) {
    a.enablement_properties().archetype_overwrite(
        s.get_boolean_content(fg.archetype_overwrite));
}
</pre>


<p>
We could simply generate an extra get method which returns an optional
(<code>get_optional_...</code>). The main use case appears to be enablement.
</p>
</div>
</div>

<div id="outline-container-org8d1dfe0" class="outline-4">
<h4 id="org8d1dfe0"><span class="section-number-4">3.1.106</span> Enable logging in unit tests from the environment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-106">
<p>
At present in order to enable logging we need to change the macros
used in unit tests. It would be much nicer if one could setup a
environment variable with the log level. This would mean that in the
future when we have org-babel integration we could set the variable
from the org-file and have a link to the log from the org-file.
</p>
</div>
</div>

<div id="outline-container-org09cb4ac" class="outline-4">
<h4 id="org09cb4ac"><span class="section-number-4">3.1.107</span> Name clashes between generated code and non-generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-107">
<p>
We named a type <code>archetype_generator</code>. This caused it to be redefined
because we also use that name in <code>test_data</code> facet. These clashes
should not really happen. The main problem is that we did not want to
use different namespaces in facets. We should then at least tell users
when they are about to create a name clash. For this we need a way to
get all the "registered" names and then compare the names the user
wants to define against those.
</p>
</div>
</div>

<div id="outline-container-orgcd9167b" class="outline-4">
<h4 id="orgcd9167b"><span class="section-number-4">3.1.108</span> Conversion does not validate missing options&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-108">
<p>
When we fail to add the mandatory options in conversion, we don't get
a sensible error:
</p>

<pre class="example">
$ ./dogen.cli convert dogen.logical.dia dogen.logical.org
Error: Extension cannot be empty.
Failed to execute command.
</pre>
</div>
</div>

<div id="outline-container-org10f6a0d" class="outline-4">
<h4 id="org10f6a0d"><span class="section-number-4">3.1.109</span> Cross-compilation for all targets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-109">
<p>
We need to move to cross-compilation to avoid having to have builds on
all supported OS's. We need to also be able to run all tests so for
this we need something like Wine. We should use clang on all OSs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/ruslo/polly">GH repo</a>: Collection of CMake toolchain files and scripts for
cross-platform build and CI testing (GCC, Visual Studio, iOS,
Android, Clang analyzer, sanitizers etc.)</li>
<li><a href="https://github.com/darlinghq/darling">darling GH</a>: Wine but for OSX. Can be used to run DMGs (see readme).</li>
</ul>
</div>
</div>

<div id="outline-container-orgaa6e04e" class="outline-4">
<h4 id="orgaa6e04e"><span class="section-number-4">3.1.110</span> Merge visitor with object&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-110">
<p>
At present we are violating the principle that all meta-model elements
must be present in the user model; we are injecting visitors. However,
it can be argued that visitor is just a physical projection of the
object logical element. If we did this we would solve the
inconsistency without needing to add another element to user models.
</p>
</div>
</div>

<div id="outline-container-org6474b1d" class="outline-4">
<h4 id="org6474b1d"><span class="section-number-4">3.1.111</span> Consider creating meta-types for transform, chain and context&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-111">
<p>
These are clearly an established pattern within dogen. It would be
nice to make them visible. Advantages:
</p>

<ul class="org-ul">
<li>we could have templates that define the class layout.</li>
<li>we wouldn't have to define "typeable" everywhere, we can make sure
there are only two archetypes for it.</li>
<li>it would automatically be set to override.</li>
<li>we would have different colours for transforms and chains.</li>
<li>if the users supply the context and model we could automatically
generate the correct includes, and add these to the apply
method. This can either be done as a hack (as we do for say
archetypes, etc) or we could add support for proper operations. It
could be done via meta-data.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the <code>transform</code> meta-type should include dependencies so that we
could compute the transform graph as part of the generation
process. We need to rework all chains so that they can be code
generated.</li>
</ul>
</div>
</div>

<div id="outline-container-org72abbdd" class="outline-4">
<h4 id="org72abbdd"><span class="section-number-4">3.1.112</span> Consider creating a container for profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-112">
<p>
At present we have placed all profiles in the profiles model and made
it non-generatable. This means we can use regular packages. However,
if we wanted to place profiles in a model which generates code and if
those profiles were placed in a package we would generate an empty
package. Ideally, we should be able to have a profile-specific
container for profiles which does not have an expression at the
physical level.
</p>
</div>
</div>

<div id="outline-container-org17df1e3" class="outline-4">
<h4 id="org17df1e3"><span class="section-number-4">3.1.113</span> Consider creating a container for features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-113">
<p>
At present we have regular namespaces containing features. Perhaps it
makes more sense to have a specialised container that stops users from
adding other types? Note that we don't have the same requirement as we
do for profiles, this is just to make things "neater".
</p>
</div>
</div>

<div id="outline-container-org87b87f3" class="outline-4">
<h4 id="org87b87f3"><span class="section-number-4">3.1.114</span> Allow convert output to <code>std_out</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-114">
<p>
It would be nice to be able to supply the injector destination instead
of a full path to destination, and dump the ouptut to <code>std::out</code>. Its
painful when trying to create a new converter to have to deal with
files.
</p>
</div>
</div>

<div id="outline-container-orgd547428" class="outline-4">
<h4 id="orgd547428"><span class="section-number-4">3.1.115</span> Consider creating a org-mode based tracing format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-115">
<p>
We've already seen the power of org-mode for representing a code
generation model. This opens an intriguing question: is org-mode also
a good tracing format? At present we are tracing with JSON. This
works OK but we always have to JQ the result and the JSON mode in
emacs is not the most performant. If we could instead look at trace
files from org-mode we would have the full power of org-mode:
</p>

<ul class="org-ul">
<li>we could create "indexes" with links to all dumps: a top-level org
file with links to the chains and top-level files, which then link
to other files.</li>
<li>we could add clock tables to time each transform (through since we
are serialising its not obvious if this has any purpose.</li>
<li>we could use other org-mode tools for analysis such as org-roam.</li>
<li>we could create tables to organise useful information such as
timings.</li>
<li>we could add links to the log file and all other files produced.</li>
<li>we could add a link to the target model and reference models.</li>
</ul>

<p>
In effect, org-mode would provide us with a navigable (and diffable)
set of documents that provide a complete description of each run.
</p>

<p>
This work should wait for the PDM refactor as we do not want to have
to create helpers for all of the PDM types (lists, vectors, etc).
</p>

<p>
This could also be very useful as a logging format if we could
compress it to a single line as we do with JSON, but then expand it to
multi-line via a trivial conversion (e.g. as we do with JQ). For
example, if we escaped newlines, tabs etc, it should be possible to
trivially reconstruct the original org-mode document via simple
elisp. In this case, we could switch IO to use org-mode, as long as
there is an "escape" flag somewhere.
</p>

<p>
In addition, if we have a pointer, we could replace those with
org-mode links to take us back to the original definition of an
object. We could simply hash the pointer and use it as a property in
org-mode; then for all links, we just hash the pointer and create a
link. In addition, if the user provides suitable annotations, we could
do the same thing for IDs. That is, say we have a primitive
representing the qualified name for an entity; if we could somehow
know that, we could then create a link back to the entity (though,
sadly, not via the hash pointer).
</p>

<p>
If we had support for sizes, we could also create org-tables giving us
a breakdown in terms of size. This could use a gnuplot block or an R
block for graphical representation.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://emacs.stackexchange.com/questions/53416/draw-pie-chart-from-orgmode-table">SO: Draw pie chart from orgmode table</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5da5f35" class="outline-4">
<h4 id="org5da5f35"><span class="section-number-4">3.1.116</span> Consider allowing representation of namespaces in file names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-116">
<p>
Languages like .Net represent namespacing using dots rather than
separate folders. Perhaps we should support a mode of operation where
all files are placed in a single folder but have the namespacing
encoded in the file name. For example:
</p>

<pre class="example">
/a_project/types/a.cpp
/a_project/io/a_io.cpp
</pre>


<p>
would become:
</p>

<pre class="example">
/a_project/types_a.cpp
/a_project/io_a_io.cpp
</pre>


<p>
or, using dot notation, so we can distinguish namespaces from
"composite" names:
</p>

<pre class="example">
/a_project/types.a.cpp
/a_project/io.a_io.cpp
</pre>


<p>
We do not have a use case for this yet, but it should be fairly
straight forward to add it. We just need meta-data support to enable
the feature and then take it into account when generating the file
names (e.g. instead of using <code>/</code> as a separator, use <code>.</code>).
</p>

<p>
Actually this is <span class="underline">almost</span> already possible: we provide a facet folder
meta-data that is always used to generate a new folder. If however
there was a way for it to not generate a folder we could achieve
this. For example, say we had to supply:
</p>

<pre class="example">
/types/
</pre>


<p>
as the facet folder. Then the user could simply supply instead:
</p>

<pre class="example">
types_
types.
</pre>


<p>
And no folder would be created.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>see also the story on destinations.</li>
<li>consider splitting this story into two: one is about how folder
layout (physical) may need to match namespace layout (logical);
another is related to allowing users to flatten facet
directories. They have some connection, but its not obvious how much
they overlap.</li>
</ul>
</div>
</div>
<div id="outline-container-org5a13d0e" class="outline-4">
<h4 id="org5a13d0e"><span class="section-number-4">3.1.117</span> Handling of model name is incorrect&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-117">
<p>
At present we are handling all containers in one way, and model names
in another. For model names we check for the presence of the model
name on both model modules and simple names. For all other cases,
including containers, we do not have the container name in the
internal module path; we just append the simple name when flattening
or when building a file name. We should be able to use the exact same
logic for model names, but this will likely result in a lot of
breakage. We need to change it once we have finished the locator clean
up.
</p>
</div>
</div>

<div id="outline-container-orga9b13de" class="outline-4">
<h4 id="orga9b13de"><span class="section-number-4">3.1.118</span> Product family projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-118">
<p>
Just like it makes sense to operate at the product level (e.g. add
components, packaging, building, etc) there are certain operations
that may make sense at the product family level. For example, take the
Dogen product family:
</p>

<ul class="org-ul">
<li>dogen</li>
<li>C++ and C# reference models</li>
<li>PDMs (possibly 3 or 4 products at present)</li>
</ul>

<p>
And so forth. A typical use case is that we make a change to one
product such as:
</p>

<ul class="org-ul">
<li>updates to README structure</li>
<li>updates to valgrind rules (however, remember that we want to be able
to compose valgrind rules in the future)</li>
<li>update to CMakeFiles (for example changing code coverage flags,
spanning across CMake, CTest and scripts)</li>
</ul>

<p>
In this case we want to be able to make this change, test it in a
product and then regenerate the product family. One way to achieve
this is to say that we have a special git repo that houses the product
family. This has the product family model. When we load the product
family model, we can them operate on all products in one go. This
could be done by having relative product paths:
</p>

<pre class="example">
product_family_repo
product_a
product_b
...
</pre>


<p>
Alternatively we could support git modules in the product family
repo. This would allow us to do one single checkout for the entire
family. The downside is that we then start building inside of the
sub-repos (we never want to build at the product family level). This
may not necessarily be a bad thing.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li><p>
we now have a clear understanding of the complete product model. Its
hierarchical structure is as follows:
</p>

<ul class="org-ul">
<li>organisation</li>
<li>product family</li>
<li>product</li>
<li>component: primary or secondary. Git repos at this level.</li>
<li>backend: primary technical space (C++, C#), secondary technical
spaces (CMake, Visual Studio).</li>
<li>part: implementation (src), public headers (include)</li>
<li>facet: types, etc.</li>
<li>archetypes.</li>
</ul>

<p>
Its possible for a component and a backend to have facets and/or
archetypes. Facets are a form of "relative" partitioning of the
physical space, by "topics".
</p></li>
<li>the text model will have an instantiation of the MASD product model,
from product onwards.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Introduce dogen projects</b>
</p>

<p>
At present we are manually configuring each dogen target, adding each
separately to the build system. Perhaps a better approach is to have a
dogen project file where one can configure all of the targets in one
go. We dont necessarily have to call dogen directly  perhaps another
command line tool is responsible for invoking dogen? The problem here
is that wed end up with all dogen models in memory.
</p>

<p>
At any rate, the project file would contain all models for a given
product. We could possibly run with all or specific whereby the
user would supply one or more projects to code generate. For all
properties that are common, wed defined them only once somehow
(common regexes, log level, etc).
</p>

<p>
One interesting thing is that once we have support for projects we can
make things slightly more efficient:
</p>

<ul class="org-ul">
<li>cache all system models and other data from filesystem;</li>
<li>load exomodels only once for all references; first check to see if
there is a cached version and if not execute the exomodel chain
again. Actually we may even be able to go up the endomodel chain all
the way up to merging.</li>
</ul>

<p>
These should be called "product models" rather than projects. We
should also consider how "product families" fit in this architecture.
</p>
</div>
</div>

<div id="outline-container-org8fc755a" class="outline-4">
<h4 id="org8fc755a"><span class="section-number-4">3.1.119</span> Add enablement test in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-119">
<p>
At present we have probably broken enablement in C# due to the hackery
around physical space expansion. However all tests are green. We need
to define a profile in C# that disables a facet in order to ensure we
test enablement before we start hacking around with the enablement
transforms. It will most likely be red - we need to add the pruning
hack to get rid of disabled artefacts as we do in C++.
</p>
</div>
</div>

<div id="outline-container-org80fbc6a" class="outline-4">
<h4 id="org80fbc6a"><span class="section-number-4">3.1.120</span> Investigate goxygen's functionality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-120">
<p>
Seems like an interesting project:
</p>

<div class="epigraph"><blockquote>
<p>
Goxygen aims at saving your time while setting up a new project. It
creates a skeleton of an application with all configuration done for
you. You can start implementing your business logic straight
away. Goxygen generates back end Go code, connects it with front end
components, provides a Dockerfile for the application and creates
docker-compose files for convenient run in development and production
environments.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Shpota/goxygen">GitHub</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0bcb66b" class="outline-4">
<h4 id="org0bcb66b"><span class="section-number-4">3.1.121</span> Throw on invalid stereotypes for all model elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-121">
<p>
At present we seem to throw on invalid stereotypes but not for all
modeling elements. We need to ensure we check this for all model
elements. For example, add the following to a <code>masd::enumeration</code>:
</p>

<pre class="example">
some::crap
</pre>


<p>
This will not throw.
</p>
</div>
</div>

<div id="outline-container-orga71b154" class="outline-4">
<h4 id="orga71b154"><span class="section-number-4">3.1.122</span> Consider adding valgrind suppressions to PDMs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-122">
<p>
We have a number of suppressions that are coming from boost log. Its a
bit painful to have to add the same suppressions to all products. It
would be nice if we could supply the suppressions as part of the
utility PDM and then have all products that depend on utility
automatically include it. Valgrind supports multiple suppression
files:
</p>

<pre class="example">
--suppressions=/path/to/file.supp one or more times.
</pre>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://valgrind.org/docs/manual/manual-core.html#manual-core.suppress">Suppressing errors</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfa2e38b" class="outline-4">
<h4 id="orgfa2e38b"><span class="section-number-4">3.1.123</span> Configuration binds to element types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-123">
<p>
At present we can check bindings for at most the "kinds" of elements
in the logical meta-model. However, in many cases we have features
that only make sense for certain meta-model elements. We could do this
fairly simply:
</p>

<ul class="org-ul">
<li>add a "tag" to configurations that tell us what meta-model elements
we have.</li>
<li>add a "tag" to features that tell us what meta-model elements they
support.</li>
</ul>

<p>
This approach could be generalised to support all binding types. It
just requires some thinking: <code>all</code> must match any tag, <code>global</code> must
match only one specific element, etc. We could perhaps have two levels
of tagging, or - even better - have multiple tags. So if all elements
are tagged with all, we could match on all. So effectively the binding
point becomes just a series of strings. This is very powerful because
now we do not have to know anything about the geometry of logical
space and yet we still are able to have very fine-grained checks on
bindings.
</p>

<p>
Once we have stereotypes in the <code>ident</code> model we can then bind to
them.
</p>
</div>
</div>

<div id="outline-container-orgf600ca3" class="outline-4">
<h4 id="orgf600ca3"><span class="section-number-4">3.1.124</span> Consider adding cartridge M2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-124">
<p>
At present we are creating CMake scripts to call ODB. This kind of
makes sense because we see ODB as an external code generator. However,
we then have several issues:
</p>

<ul class="org-ul">
<li>ODB files are not known to dogen. We could create some expectations
of what these files are and where they will be located, but if the
user changes anything problems will occur.</li>
<li>if the user chooses a different build system, we need to add more
targets to run ODB.</li>
</ul>

<p>
One can imagine that these problems will be common to all external
code generators we add in the future (e.g. protobuf, XSD tool etc). A
slightly different take on this would be to call the external tools
from within dogen. We would add meta-model concepts for these (not
exactly clear what those should be, to be fair). The gist of it is
that we would have a "cartridge formatter", with the following
responsibilities:
</p>

<ul class="org-ul">
<li>shelling out and calling the tool with the correct environment
setup;</li>
<li>gather the generated files and place then in the right directories;</li>
<li>gather the errors and report them back to the user.</li>
</ul>

<p>
The advantage of this approach is that we can then run other parts of
the pipeline on the generated files (e.g. perform any formatting that
may be required). For each cartridge we would have to teach dogen on
how to invoke it and what the expectations are.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>config file should tell dogen about the application location if not
in path.</li>
<li>extensions should be registered as archetype kinds in the
meta-model.</li>
<li>we could probably decomission the ODB options files, which would be
nice as they are a bit awkward. We could either generate them on the
fly or not even bother to generate them at all and supply the
options directly to ODB's command line. Basically we would need
meta-model elements to capture the command line invocation for each
element. We could even allow users to supply overrides to command
line such as <code>--include-regex-trace</code>.</li>
<li>we could also detect when files need to be rebuilt, although this is
probably not trivial. Basically, by following the element
dependencies we could determine if there is a need to call ODB or
not. Alternatively, we could follow the include graph. Either way we
need to make sure we rebuild when we should and this is like
replicating a make inside of dogen. This is where a deep integration
with build2 would be nice (e.g. via <code>libbuild2</code>).</li>
<li>we can also add this to the new post-processing framework. In this
case, the ODB post-processor (formatter) will run ODB, generate the
files in the simplest possible way (e.g. all in the same directory)
then load them up into the artefact for further processing. These
files can be generated in a temp directory somewhere. The
post-processor will generate N artefacts for one file.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_72_0/doc/html/process.html">Boost.Process</a>: we could use this library to start external
processes.</li>
<li><a href="https://github.com/build2/build2">https://github.com/build2/build2</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Analysis on the modeling of generated files</b>
</p>

<p>
We have a principle that states that any file that is a part of a
project must have a meta-model element that models it. However, there
are cases where this break down:
</p>

<ol class="org-ol">
<li>stitch templates. In this case we have one stitch template per
<code>.cpp</code> file we generate. It would be cumbersome to have to have 2
model elements, one for the template and one for the output file
since they will be near identical. However, if we did have it then
we could allow associating stitch templates with <b>any</b> facet, which
would be very convenient - not that we have a use case for this,
mind you. In this scenario, you would create a stitch template as a
proper template and then create the meta-model element and then
within the element you would associate the template with the
element on a given archetype. This is 100% correct, but then we
will end up with 2N elements. For models such as <code>m2t.cpp</code> and
<code>m2t.csharp</code>, this could mean more than 50 additional elements. A
different way to look at this is to say that there is only one
modeling element and then there are multiple facets; the stitch
template is itself a facet. Or perhaps to allow files to live in
the same directory, we could say there are multiple archetypes. In
this case, we are saying that an archetype a0 could generate
another a1 via a function f0. This could also be generalised so
that we could generate a set A rather than just one file. If this
could be an external process, we could then call ODB directly
inside of Dogen. Though not sure this is a good idea.</li>
<li>wale templates.</li>
<li>ODB files.</li>
</ol>

<p>
Actually both 1 and 2 have now been modeled correctly so the only
problem is now ODB files. These will be handled by the cartridge
story.
</p>

<p>
Merged stories.
</p>

<p>
<b>Ignore ODB files automatically</b>
</p>

<p>
At present we are adding the following regular expressions to knitter
whenever we are using ODB with dogen:
</p>

<pre class="example">
--ignore-files-matching-regex .*sql
--ignore-files-matching-regex .*-odb.*)
</pre>


<p>
We should inject the ODB files automatically into the list of expected
files. For a given element <code>foreign_key</code>, we will have a dogen file
</p>

<pre class="example">
foreign_key_pragmas.hpp
</pre>


<p>
We will also have the following ODB files:
</p>

<pre class="example">
foreign_key-odb.cxx
foreign_key-odb.hxx
foreign_key-odb.ixx
</pre>


<p>
The first file can either be on the <code>include/odb</code> directory or on the
<code>src/odb</code> directory (it is moved by the ODB target). All other files
are placed in the <code>include/odb</code> folder. Note that at present we are
using <code>cpp</code> extension rather than <code>cxx</code>.
</p>

<p>
In addition, on a multi-database environment we also have:
</p>

<ul class="org-ul">
<li><code>repository-odb-oracle.hxx</code></li>
<li><code>repository-odb-pgsql.hxx</code></li>
<li>&#x2026;</li>
</ul>

<p>
Ideally we should also add the ODB include files to the master
includes. However, we probably need a separate master include file
just for ODB files.
</p>

<p>
One of the amazing side-effects of this approach is that we will
automatically delete any ODB files which are no longer required
(because we will not generate ignores for them). At present we are
manually deleting them.
</p>

<p>
This also means we can add the ODB files to the visual studio project
even before they get generated.
</p>

<p>
We should have meta-data configuration that describes the ODB files:
</p>

<ul class="org-ul">
<li>their extension</li>
<li>the location of headers and implementation</li>
<li>the need to move the files</li>
</ul>

<p>
We should generalise this problem so that when we are using other
cartridges such as protobuf/grpc, we can extend it for these use
cases - expected cartridge files?
</p>
</div>
</div>

<div id="outline-container-orgf4f0e63" class="outline-4">
<h4 id="orgf4f0e63"><span class="section-number-4">3.1.125</span> Consider making a separation between userspace and masd space&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-125">
<p>
Userspace is actually quite a good name to represent the users of MASD
(copied from kernel land). However, we don't really have a
kernel-space. We need an equivalent (and it can't be modeling-space
because user space is also about modeling.
</p>
</div>
</div>

<div id="outline-container-orga4ef38a" class="outline-4">
<h4 id="orga4ef38a"><span class="section-number-4">3.1.126</span> Integration of configuration and variability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-126">
<p>
There are several threads going on in different stories that can be
unified. These are related to variability and configuration. We need
to find all of these stories and merge them at some point. The key
finding seems to be that the variability we are experiencing in dogen
as configuration is the same as the configuration all applications
require - e.g. app.config, INI files, etc. Because Dogen has
configuration embedded into models, its not very obvious that we are
doing the same thing. What this means is the following:
</p>

<ul class="org-ul">
<li>we could, very easily, create a serialisation format for
features. These would look a bit like the JSON format we had some
sprints ago. However the key difference is that this time <i>we would
generate the JSON files from models</i>. We would have a new part for
Dogen: <code>configuration</code>. Under this part, we would store the
serialised format for feature models. Note that these are the
features, not their instances. The file names could be something
really simple such as <code>[MODEL_name].features.[FORMAT]</code>,
e.g. <code>dogen.variability.features.json</code> or
<code>dogen.variability.features.ini</code> (probably not INI as I think its
not rich enough to carry the features). We could then aggregate all
of these files and place them in the dogen package. At start up
Dogen would look for this directory and if found would load all of
the features from there. This is exactly the same as having the
features in code.</li>
<li>the second aspect is access to configurations. Now, for dogen, the
configurations live in dynamic instances of variability
objects. This is fine. We could create a wrapper, very similar to
what we are doing at present, that reads data from these objects and
presents the developer with a c++ object. However, the key thing is
that this is a very special case. In almost all cases, what we
really have is a config file such as <code>app.config</code>, INI etc. The
profile (as we call it at present) is the instance of the config
file. The feature model is the type information required to generate
a class that can read the config file and present an idiomatic
object to the consuming user. Nothing stops us from allowing users
to define feature bundles, then using those to generate classes that
know how to read those features from config sources; and then
serialising profiles into config sources. Finally, at run time, the
code would merely read the serialised config source.</li>
<li>all of this, of course, sounds extremely convoluted for the simple
case. But the power of it is the more complex cases. We can now
quite trivially create a consul loader that takes a config file and
populates the KVP store. Similarly, we could also create a consul
client that retrieves the config from the KVP store, always getting
latest. We could even support both, depending on environment
variables.</li>
<li>configuration sources allow us to support many configuration
backends: boost property tree, environment variables, etc. However,
we can't have these as facets. We probably need to define an
interface and then multiple implementations, with associated
factories.</li>
<li>note that the generation of JSON/INI files for the features is also
only a dogen requirement. For the "userspace" cases we can define
the features in a diagram and then create the instantiations in the
same diagram as profiles and then code-generate the profiles as both
INI files and c++ code to read the files (e.g. we only need to code
generate the configuration). However, for dogen this is not possible
(by design).</li>
<li>while we're at it, we should also create the notion of
"configuration sets". These are multiple instantiations of the
feature model and could be used to model environments.</li>
<li>one way to flatten and aggregate both features and profiles to make
them suitable for code generation on a single file is the creation
of a meta-model element that gathers them. We could create a
transform that finds all features in a model and populates the new
meta-model elements with them (like say a feature initialiser at
present). This would also allow for a clean way to distinguish
between models that use features without code generation and models
that require code generation.</li>
<li>configuration is strictly a KVP model. It should not support object
graphs.</li>
</ul>

<p>
With this approach we can finally unify the world of code generation
variability with the world of application variability.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/oliora/ppconsul">ppconsul GitHub</a>: C++ client for Consul (<a href="http://consul.io">http://consul.io</a>)</li>
<li><a href="https://github.com/david-antiteum/consulcpp">consulcpp GitHub</a>: A C++ library that implements the Consul API</li>
<li><a href="https://github.com/oatpp/oatpp-consul">oatpp-consul GitHub</a>: oatpp client for consul <a href="https://oatpp.io/">https://oatpp.io/</a></li>
<li><a href="https://www.consul.io/api/libraries-and-sdks.html">Consul - Client Libraries &amp; SDKs</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgedfd59a" class="outline-4">
<h4 id="orgedfd59a"><span class="section-number-4">3.1.127</span> Rename main Dogen package in Debian&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-127">
<p>
At present we seem to have called our package <code>dogen-applications</code>:
</p>

<pre class="example">
$ apt-cache search dogen-applications
dogen-applications - The Domain Generator - Generates source code for domain driven development.
</pre>


<p>
We should try to call it just <code>dogen</code>.
</p>

<p>
Merged stories:
</p>

<p>
<b>Rename debian package</b>
</p>

<p>
At present our package is called <code>dogen-applcations</code>. Since there will
only be one dogen application/package, this is a confusion name. We
should rename it. Names:
</p>

<ul class="org-ul">
<li>masd-dogen</li>
</ul>
</div>
</div>

<div id="outline-container-org9624e6d" class="outline-4">
<h4 id="org9624e6d"><span class="section-number-4">3.1.128</span> Rename facets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-128">
<p>
We originally called our support for <code>std::hash</code> just <code>hash</code> and our
support for <code>boost::serialization</code> just <code>serialization</code>. The problem
is:
</p>

<ul class="org-ul">
<li>we may want to also support <code>boost::hash</code>.</li>
<li>we may want to support other serialisation types.</li>
</ul>

<p>
We should rename these. Perhaps:
</p>

<ul class="org-ul">
<li><code>std_hash</code></li>
<li><code>boost_serialization</code>: a tad verbose, but quite explicit.</li>
</ul>

<p>
In addition, <code>io</code> is very misleading as the facet is not supposed to
do I/O proper (e.g. serialisation) but more pretty-printing or debug
dumping. So perhaps <code>pretty_print</code>.
</p>

<p>
Test data is a strange name. We need something slightly more idiomatic
such as perhaps sequence? We need to look into STL generator
terminology. We should also look into Rx and transducers - these
should be pluggable into these. Ranges also come to mind.
</p>

<p>
Merged stories:
</p>

<p>
<b>Rename the <code>io</code> facet</b>
</p>

<p>
IO is a very bad name for this facet. Everyone knows this as
"pretty-printing". We should call it pretty-printing and use <code>pp</code> as
the short name (folders, etc).
</p>
</div>
</div>

<div id="outline-container-org7658a99" class="outline-4">
<h4 id="org7658a99"><span class="section-number-4">3.1.129</span> Add merging code generation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-1-129">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to manually change some code in
generated files so that I can add functionality that is missing in
dogen.
</p>

</blockquote></div>

<p>
At present it is not possible to manually add methods to a class that
was code generated; one must stop code generating the class and
maintain the whole class manually. This is made even more painful by
the fact that one cannot add support for IO etc for these types
manually.
</p>

<p>
However, in a lot of cases it makes sense to have a combination of
manually generated and code generated code:
</p>

<ul class="org-ul">
<li>value objects need helper methods such as for example boolean
properties (e.g. <code>is_empty</code>) that make use of other properties, or
simple methods such as population etc that really belong in the
object rather than an external service;</li>
<li>services sometimes need state and it would be good if we could
manage that via code generation.</li>
</ul>

<p>
For this we need a merging code generator: that is, a code generator
that is aware of code that was crafted manually and does not overwrite
it - but instead "intelligently" merges manual with code generated
code.
</p>

<p>
From the beginning we avoided this because we thought it would be too
complicated for dogen. However, its becoming apparent that this is a
needed feature for the real world - there are many cases where we are
working around this deficiency. A few solutions are possible:
</p>

<ul class="org-ul">
<li>let the code generator manage the header file and create two types
of CPP files, one which includes the other: a manual and an
"automatic" one. This would effectively separate the two types of
code. For this dogen would have to be able to generate complex types
in operations (e.g. we'd have to solve the lack of support for
<code>const std::string&amp;</code>).</li>
<li>use clang to do the merging. this probably means adding some kind of
attribute to every method - possibly using C++ attribute support
(e.g. <code>[ [generated ] ]</code> and/or <code>[ [ manual ] ]</code> (spaces due to org
mode). We could then say to clang: read current state of the file,
grab every non-generated method and copy them across to the newly
code generated file. Merging could be the final stage before
writing. In addition, we should also have some dynamic extensions to
determine which files require merging. The dynamic extension could
be populated automatically (e.g. grep for the manual attribute) or
manually. Note that using clang to do merging will make things a lot
slower so we probably want to know up front which files need to be
merged to avoid doing spurious work.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>include management would be a mix of manual versus automatically
generated. This is not possible because there will be no way to
determine which one is which. To solve this problem we need to allow
users to add include files from the dynamic extensions and get those
processed like all the other includes. In the new world this means
adding includes to the formatter settings. These are local
settings. As at present, we cannot identify a use case for adding an
include file for all types, so there is no need to support this
feature at the global settings level. Thus this fits nicely with the
existing settings infrastructure.</li>
<li>merging could be done without needing clang, which would also make
it cross language. All that is required is for the language to
support some kind of meta-data to mark a method as "manually
generated". This could even be done using comments but this is not
ideal. The process would then be: dogen would open up an existing
source file and locate the attribute; then look for a open brackets
to indicate the start of the method (<code>{</code>) and then find the matching
close brackets (<code>}</code>). We could keep a counter and increment it when
a new open bracket is found and decrement it when a close bracket is
found. When its zero we are done. All the code from the attribute to
the close brackets would be lifted. A very simple regex matching
would be done to find the method name - or perhaps some trivial
parsing could be done, but it should be kept as simple as
possible. The objective is simply to figure out the method name. The
method is copied across and stored in the <code>cpp</code> model, in the
correct method. When code generating, if a method is marked as
"manually generated" and if there is implementation content, we dump
that; otherwise we generate the skeleton of the method as if it was
not "manually generated". We could also create a very simple spirit
parser that only knows of comments, function names and function
bodies.</li>
<li>merging could be done as part of yarn, in meta-data. That is, we
could annotate the merged method into language specific properties
in the meta-data and then query those in the language specific model
generation. We could have another yarn workflow to look for files;
it could use the meta-data for file path. The extension will tell it
what "function parser" to use. We could literally look through the
meta-data extensions looking for file path, and for each run the
"function parser"; it will return a set of "manual" functions. These
we can then slot into the meta-data and reuse later on. Actually, we
can't use meta-data for this given the existing convention that
meta-data is constant. However, nothing stops us from adding the
required properties to yarn directly (e.g. we could have an
<code>operation</code> which has a language specific container of
implementations), to be used by formatters. Interestingly, this then
seems to share some logic with method helpers. That is, if we could
supply the stitch template as an operation (per facet, per
language) and if we could annotate the operation somehow as
"external" to the object, helper methods could use the same
infrastructure. But perhaps this doesn't make a lot of sense since
for helper methods we need to run the formatter whereas for merging
we already have the final form of the code and we just need to carry
it along to dump it in the formatter.</li>
<li>the proper technical name for methods that can be manually edited is
"protected regions". Merging is not a technical term according to
MDSD at least.</li>
<li>the act of checking the generated files vs the user edited files is
called "model synchronisation" and its part of incremental
transformation (according to <a href="https://pdfs.semanticscholar.org/7eca/ca8db190608dc4482999e19b1593cc6ad4e5.pdf">Czarnecki and Helsen</a>)</li>
</ul>

<p>
We should also address the MDSD comment:
</p>

<div class="epigraph"><blockquote>
<p>
If, for performance reasons, or because the target language doesnt
offer any options for consolidating different artifacts, handwritten
code must be inserted into generated code directly, the introduction
of protected areas is inevitable. Please do this only if such
exceptional conditions require this approach!
</p>

</blockquote></div>

<ul class="org-ul">
<li>We will need to support multiple merging strategies, depending on
the use case:
<ul class="org-ul">
<li>simple extension: when we just want to add a method or two to an
otherwise generated object. For this, protected regions at the
function level is probably enough.</li>
<li>large extensions: when we want to add lots of functionality but
there is a small component of code generation. For this we want
some large blocks of protected regions that the user manages
(includes, anonymous namespace, class, etc. The user can then put
whatever it wants in those).</li>
<li>private inheritance: we could create a private/internal base class
with all of the generated code and then inherit privately from it
in a hand-crafted file. Only available on C++.</li>
<li>partial classes: one definition is code generated, the other
hand-crafted. Only available in C#.</li>
</ul></li>

<li>interestingly, it seems that merging is a variation of a wale
template. Basically we can generate the file, slot in the GUIDs for
the protected regions as wale keys, then read the protected regions
from the file system into a wale KVP container and then instantiate
the generated file as if it was a wale template.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://arxiv.org/pdf/1509.04498.pdf">A comparison of mechanisms for integrating handwritten and generated
code for object-oriented programming languages</a></li>
<li><a href="https://gitlab.com/mtekman/org-tanglesync.el">org-tanglesync GH</a>: "A package to pull external changes into an
org-mode source block if that block is tangled to an external file."</li>
<li><a href="https://github.com/xieyuheng/tangle-rs">tangle-rs GH</a>: "A collection of tools to do tangle in rust."</li>
<li><a href="https://emacs.stackexchange.com/questions/45164/does-org-have-any-inverse-tangle-operations-e-g-for-collaborating-with-non-or">Does org have any inverse-tangle operations e.g. for collaborating
with non-org users?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1123746" class="outline-4">
<h4 id="org1123746"><span class="section-number-4">3.1.130</span> Consider renaming profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-130">
<p>
The correct MDE terminology for feature selection is configuration. We
have used this term within the variability model with a similar
meaning. We tried to avoid reusing the name so that its meaning is not
dependent on context, but it seems its worthwhile giving end users the
canonical MDE term and using something else internally.
</p>

<p>
In "Systems variability modeling : a textual model mixing class and
feature concepts", the authors describe the following concepts:
</p>

<ol class="org-ol">
<li>Meta-Features Model. Previous researches did not mention the
Meta-Models Clearly; they mentioned it as features that may contain
more than one sub features.</li>
<li>Features Meta-Model; this model is predefined and domain
independent. It defines different domain features with their
relations.</li>
<li>Feature Model: Compact model of features diagram and feature
constrains. It is an instance of the Features Meta Model.</li>
<li>Feature diagram; Graphical representation showing each feature and
its relations with its subs. And</li>
<li>Features configuration; Set of selected features producing a
release in SPL. Configuration is permitted with feature model and
preserves features constrains.</li>
</ol>

<p>
This may mean that we should have a features meta-model and a features
model, therefore resolving the issue of the naming; we are in the
meta-model dimension within the variability model, and in the model
dimension when instantiating a user model.
</p>

<p>
One way to understand features in Dogen is as follows:
</p>

<ul class="org-ul">
<li>the variability model is a features meta-model because it defines
the shape of all features that can be created within Dogen.</li>
<li>feature bundles and templates are a feature model - that is, they
are instances of the feature meta-model.</li>
<li>the configuration model is an instance of the feature model and is
implemented as profiles and profile templates. From a SPL
perspective, the configuration model is associated with a product.</li>
<li>the product component models makes use of the configuration model
defined for a product. All products must follow dogen's product
meta-model.</li>
</ul>
</div>
</div>

<div id="outline-container-org068c301" class="outline-4">
<h4 id="org068c301"><span class="section-number-4">3.1.131</span> Consider renaming feature bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-131">
<p>
It seems that the approach used by OOFM could be used to improve the
terminology in the variability model. We need to read this paper:
</p>

<p>
V. T. Sarinho and A. L. Apolinario (2010), Combining feature modeling
and Object Oriented concepts to manage the software variability, IEEE
International Conference on Information Reuse and Integration (IRI),
pp. 344-349.
</p>
</div>
</div>

<div id="outline-container-orgeb88e84" class="outline-4">
<h4 id="orgeb88e84"><span class="section-number-4">3.1.132</span> Consider generating dependency injection code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-1-132">
<p>
If one could mark constructors as <code>injectable</code> in a diagram, we could
then generate something like a castle windsor container and do all of
the management of dependency injection from generated code. We also
have access to all interfaces and their implementations so a lot of
the clever logic done at run time by castle/guice etc could be done in
the generated code.
</p>

<p>
For this to work we need some kind of DI library with a generic
interface; we can then do as we do in C# and have a number of
"installers" per library which add classes to the container, against
an interface. Dogen is basically responsible for:
</p>

<ul class="org-ul">
<li>creating a top-level installer in the executable which calls all of
the installers of all dependent libraries (internal and external to
the current product, but dogen generated). We could have a flag to
tell us if a model requires installers or not.</li>
<li>creating each library's installer. For this we need two things: mark
a type as an interface and split out registration code from the
hand-crafted class. Instead we should just have all of the classes
that need registering against an interface doing it in the
installer, which we code generate. We also need to mark the
interface as "dependency injectable" so we know we need to generate
DI code.</li>
<li>finally, from a consumption perspective, we can then call the DI
container and request all instances of the interface we require. We
should not use DI for all construction; just for the cases where an
interface is used. The binary creates the container and supplies it
to whomever needs to resolve an interface.</li>
</ul>

<p>
Actually, another way to think of this is that DI is a meta-pattern
and not a pattern; one of the biggest problems with Castle is the
amount of run-time trickery it does, making it really difficult to
understand what is happening behind the scenes and why things are not
working. For the vast majority of use cases, we know all of the
information at compile time and all we want to avoid is to manually
generate the code wiring things up. It would be a much better approach
if dogen generated this code, making it look just like regular code
which can be inspected and debugged, and move the DI to a compile time
phenomenon. We would still require all of the elements of castle, but
now they become meta-entities describing the relationships between
types. We then generate code that instantiates types in the correct
order. We could simply create factories that call the appropriate
constructors and have these factories be completely
code-generated. This also means that users must declare the
constructors correctly in dogen models in order to get the factory to
work; note that we will be doing this mostly for hand-crafted code. We
need to do an analysis of the different components in Castle in order
to model them.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/boost-experimental/di">Boost.DI</a>: not part of boost yet <a href="https://github.com/boost-experimental/di/issues/229">and not clear when it will be.</a></li>
<li><a href="http://wallaroolib.sourceforge.net/">wallaroo</a> (more run-time DI)</li>
<li><a href="https://github.com/google/fruit">fruit</a> (tutorial <a href="https://github.com/google/fruit/wiki/tutorial:-getting-started">here</a>)</li>
<li><a href="https://gpfault.net/posts/dependency-injection-cpp.txt.html">Dependency Injection in C++ Using Variadic Templates</a></li>
<li><a href="https://github.com/ybainier/hypodermic">hypodermic</a> (more run-time DI)</li>
<li><a href="https://riptutorial.com/Download/castle-windsor.pdf">Castle Windsor tutorial</a></li>
<li><a href="https://github.com/castleproject/Windsor/blob/master/docs/installers.md">Windsor docs on installers</a>. See also <a href="https://github.com/castleproject/Windsor/blob/master/docs/ioc.md">ioc</a> and the docs directory in
general.</li>
</ul>
</div>
</div>

<div id="outline-container-org09f25d0" class="outline-4">
<h4 id="org09f25d0"><span class="section-number-4">3.1.133</span> Formatters can only belong to one facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-133">
<p>
Up to know there was an agreement that generation space was
hierarchical and formatters could only belong to one facet. This has
been true until now, but with the addition of CMake support to tests,
we now have an exception: we need to honour both the tests facet and
the cmake facet. If either of them are off, then we should not emit
the CMake file. This means that we need to somehow map one formatter
to multiple facets. For now we just hacked it and used one of the
facets. It means that if you disable CMake but enable testing you'll
still end up with the testing CMake file.
</p>
</div>
</div>

<div id="outline-container-org57387d5" class="outline-4">
<h4 id="org57387d5"><span class="section-number-4">3.1.134</span> Model "types" and element binding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-134">
<p>
It seems clear that we will have different "types" of models:
</p>

<ul class="org-ul">
<li>product models, describing entire products.</li>
<li>component models, which at present we call "models". These describe
a given component type such as a library or an executable. Thus,
they themselves have sub-types.</li>
<li>profile models: useful to keep the configuration separate. However,
it may make more sense to place them in the product model, since its
shared across components?</li>
<li>PDMs: these describe platforms.</li>
<li>generative models: generate extensions to code generators.</li>
</ul>

<p>
At present there is no concept of model types, so any meta-model
element can be placed in any model. This is convenient, but in the
future it may make things too complicated: users may end up placing
types in PDMs when they didn't meant to do so, etc. What seems to
emerge from here is that, just as with variability, there is a concept
of a binding point at the model level too. That is, meta-model
elements are associated with specific model types (binding element?).
</p>

<p>
In an ideal world, we should have a class in the meta-model that
represents each model type. We then instantiate this class within one
of the dogen models to register the different model types. Its
code-generation representation is the registration. It also binds to
all the meta-model elements it binds to. This can be done simply by
creating a feature that lists the stereotypes of the elements
(remember that these are then registered too, because we will generate
the meta-class information as we generate the assets model). Then, we
can ask the model type if a given element is valid (check a set of
stereotypes).
</p>

<p>
Formatters are themselves meta-model elements, and they bind to other
meta-model elements (which raises the question: which meta-model
elements are bindable? we can't allow a formatter to bind to a
formatter&#x2026;). Perhaps we need another type of model, which is a
"generation model". This is where we can either declare new technical
spaces or add to existing technical spaces; and declare new facets and
formatters. We should be able to add to existing facets and TSs by
allowing users to specify the TS/facet when declaring the
formatter. If not specified, then the user must declare a facet in the
package containing the formatter. Similarly with TSs.
</p>

<p>
Note also that the formatter binding code is "inserted" directly
during generation into the CPP file. Its not possible to change
it. Same with the includes. This ensures the user cannot bypass the
model type system by mistake. Also, by having a formatter meta-model
type, we can now declare the header file as we please, and ensure the
shape of the implementation. Now, the stitch template can be
restricted to only the formatting function itself; the rest is
code-generated. We no longer need wale templates. This will of course
require the move to PDMs and the removal of the helper code. This also
means that anyone can declare new meta-model elements; they will
register themselves, and correctly expand across archetype
space. However, we do not have the adaption code nor do we have
containers for these modeling elements. We need a separate story for
this use case.
</p>

<p>
Destinations are meta-model elements too. In the generation.cpp model
we will declare all the available destinations:
</p>

<ul class="org-ul">
<li>global</li>
<li>src</li>
<li>include</li>
<li>tests</li>
</ul>

<p>
etc. The formaters bind into destinations. Formatters belong to facets
in the archetype space, which express themselves as directories in the
artefact path when we project from archetype space into artefact
space. More generally: assets in asset space are projected into the
multidimensional archetype space. Archetypes are projected into
artefact space, but the dimensions of archetype space are flattened
into the hierarchy of the filesystem.
</p>

<p>
We also need a concept of artefact types. These mainly are needed for
file extensions, but conceivably could also be used for other
purposes.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the binding should be done at the streotype level, not model
element.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Model types and element binding</b>
</p>

<p>
Once we introduce the concept of model types (e.g. product, component,
possibly different types of components), we should also take into
account that some model types don't support some model elements. It
should be possible to declare which model types support which element
types such that if a user tries to use an invalid model type, we get a
sensible error. In effect, this is a binding problem at the meta-model
level.
</p>

<p>
One of the component model types should be "generative
components". These are used to augment the code generator. We need to
look at the thesis on generative development to look for terminology.
</p>

<p>
We should also have model types for terraform, etc.
</p>

<p>
One way to implement this is to add a feature at the element (once we
have a way of expressing dogen meta-elements) that lists the supported
model types for a given element.
</p>

<p>
<b>logical models could have a model classification</b>
</p>

<p>
Consider creating an enumeration for model classification (e.g. type
of the model):
</p>

<ul class="org-ul">
<li>relational model</li>
<li>core domain model</li>
<li>generic sub-domain model</li>
<li>segregated core model</li>
</ul>

<p>
This still requires a lot of analysis work. This is kind of a model
level stereotype which can be used by the code generator for example
to determine which models are compatible. It could also be used to
determine what facets can be enabled/disabled.
</p>

<p>
<b>Merged with modes of operation story:</b>
</p>

<p>
Create "modes" of operation: relational, object-oriented and
procedural. they limit the types available in yarn. relational only
allows built-ins plus relational commands (FK and PK; FK is when
using a model type, PK is a marker on a property). procedural only
allows built-ins plus model types. we will need pointer support for
this. object oriented is the current mode. the modes are validated in
the middle end.
</p>
</div>
</div>

<div id="outline-container-orgc35a74e" class="outline-4">
<h4 id="orgc35a74e"><span class="section-number-4">3.1.135</span> Project layout analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-135">
<p>
We should probably look at the layout of a few projects and see if our
meta-model covers these cases.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html">Canonical Project Structure</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/8qzepa/poll_c_project_layout/">Poll: C++ project layout</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/996q8o/prepare_thy_pitchforks_a_de_facto_standard/">Prepare thy Pitchforks: A (de facto) Standard Project Layout</a></li>
<li><a href="https://github.com/vector-of-bool/pitchfork">Pitchfork is a Set of C++ Project Conventions</a></li>
<li><a href="https://mariuszbartosik.com/directory-structure-for-a-c-project/">Directory Structure for a C++ Project</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfd478d5" class="outline-4">
<h4 id="orgfd478d5"><span class="section-number-4">3.1.136</span> Consider moving compatibility mode to feature model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-136">
<p>
Given that compatibility mode only really applies to features, we
should just have the flag in the feature model itself?
</p>
</div>
</div>

<div id="outline-container-orga4a34a6" class="outline-4">
<h4 id="orga4a34a6"><span class="section-number-4">3.1.137</span> Model SQL scripts as meta-model entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-137">
<p>
At present we are adding SQL scripts to the relational model under the
<code>sql</code> directory. These should be part of the model. We need meta-types
to represent these files. For now they just need to generate an empty
file - or perhaps just the SQL modeline and decoration. They should
also be marked as handcrafted. We also need to add a part for SQL.
</p>
</div>
</div>

<div id="outline-container-orgf26feff" class="outline-4">
<h4 id="orgf26feff"><span class="section-number-4">3.1.138</span> Model lisp scripts as meta-model entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-138">
<p>
We are using lisp scripts in the dia and templating projects. These
need to be modeled and generated. Generation can have just decoration.
</p>
</div>
</div>

<div id="outline-container-org7d6730b" class="outline-4">
<h4 id="org7d6730b"><span class="section-number-4">3.1.139</span> Consider adding descriptions to feature bundles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-139">
<p>
It would be nice if we could add the feature bundle as an entry into
dumpspecs, with an associated description. For example, say for
<code>masd.generation.decoration</code>, explaining what a decoration is.
</p>
</div>
</div>

<div id="outline-container-org6aba1b9" class="outline-4">
<h4 id="org6aba1b9"><span class="section-number-4">3.1.140</span> Move models into the project directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-140">
<p>
At present we have a models directory in each component of a
product. However, perhaps it makes more sense to have it as a
subdirectory of the component itself. This is because in an ideal
world, we should create a package for the component with the model and
the header files as well as the binaries, allowing users to consume
it:
</p>

<ul class="org-ul">
<li>in the Dogen case, it means users can create plugins for Dogen;</li>
<li>in the PDM case, it means users can make use of the PDM in their own
models;</li>
<li>for user models, it means you can consume a product in another
product by referencing its models.</li>
</ul>

<p>
However, one downside of this approach is that we then need to have
many directories in the include path for models. If we take the
include headers as an example, there are a small number of directories
in the path:
</p>

<ul class="org-ul">
<li>compiler specific directories</li>
<li><code>/usr/include</code></li>
<li>&#x2026;</li>
</ul>

<p>
Maybe we have two separate issues here:
</p>

<ul class="org-ul">
<li>when creating a product, where should the models be placed? If we
keep in mind that models are themselves an asset like any other and
as such require a meta-model representation, it would be logical to
keep the model with the component it generates (just like we keep
the product model within the product it generates). This means for
instance that we could easily initialise a component via the command
line and create a "template" blank model (in dia or JSON) with a
number of things already set. We probably also need a way to avoid
deleting multiple files (e.g. if we have both a dia and a JSON
model, we need to know to ignore both of them). This means that when
building a product we need multiple include directories for models,
just as we do for headers. This work should be done as part of
adding products to the asset model because models will be in the
same namespace. The dia and JSON directories are then the facets for
the model. This also means that we can now add the targets for
generation, conversion etc directly into each component. So,
somewhat paradoxically, when we create a model, we need to have a
model of the model in it (or maybe two models of the model, Dia and
JSON). Interestingly, now that we have a model of the model, we can
suddenly move all of the keys that we have placed at the top-level
into this modeling element. We can aslo associate it with a profile
via stereotypes, removing the need for
<code>masd.variability.profile</code>. And if we take it to the next leve, then
perhaps references are themselves also modeling elements. Its not
clear if this is an advantage though.</li>
<li>from a "consumption" perspective, perhaps we could have a single
<code>shared/dogen/models</code> directory, just like we will also place all of
the PDM's includes under <code>/usr/include</code> and the SO's under
<code>/usr/lib</code>. We could split it into Dia and JSON if need be.</li>
<li>the product model itself should be at the top-most directory of the
git repository. We also need a "models" directory to store models
which are not expressed as source code (profiles, PDMs, etc). Then,
for each component, we should have the models at the root directory
of the component. Whilst this is not in line with our OCD, it is
required in order for the product model to be able to locate the
component models. An alternative is to have a convention that we
always look into a "models" directory (which can be renamed via a
meta-data parameter) for models, plus any additional directories in
the "model path". We must inject the model file names to dogen so
that we do not delete the models.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need a model element for the model itself.</li>
</ul>
</div>
</div>

<div id="outline-container-orgea48576" class="outline-4">
<h4 id="orgea48576"><span class="section-number-4">3.1.141</span> Add support for product skeleton generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-141">
<p>
Now that dogen is evolving to a MDSD tool, it would be great to be
able to create a complete product skeleton from a tool. This would
entail:
</p>

<ul class="org-ul">
<li>directory structure. We should document our standard product
directory structure as part of this exercise. Initial document added
to manual as "project<sub>structure.org</sub>".</li>
<li>licence: user can choose one.</li>
<li>copyright: input by user, used in CMakeFiles, etc. added to the
licence.</li>
<li>CI support: travis, appveyor</li>
<li>CMake support: top-level CMakefiles, CPack. versioning
templates, valgrind, doxygen. For CTest we should also generate a
"setup cron" and "setup windows scheduler" scripts. User can just
run these from the build machine and it will start running CTest.</li>
<li>vcpkg support: add "ports" code? user could point to vcpkg directory
and a ports directory is created.</li>
<li>agile with first sprint</li>
<li>README with emblems.</li>
</ul>

<p>
Name for the tool: dart.
</p>

<p>
Tool should have different "template sets" so that we could have a
"standard dogen product" but users can come up with other project
structures.
</p>

<p>
Tool should add FindODB if user wants ODB support. Similar for EOS
when we support it again. We should probably have HTTP links to the
sources of these packages and download them on the fly.
</p>

<p>
Tool should also create git repo and do first commit (optional).
</p>

<p>
For extra bonus points, we should create a project in GitHub, Travis
and AppVeyor from dart.
</p>

<p>
We should also generate a RPM/Deb installation script for at least
boost, doxygen, build essentials, clang.
</p>

<p>
We should also consider a "refresh" or "force" statement, perhaps on a
file-by-file basis, which would allow one to regenerate all of these
files. This would be useful to pick-up changes in travis files, etc.
</p>

<p>
One problem with travis files is that each project has its own
dependencies. We should move these over to a shell script and call
these. The script is not generated or perhaps we just generate a
skeleton. This also highlights the issue that we have different kinds
of files:
</p>

<ul class="org-ul">
<li>files that we generate and expect the user to modify;</li>
<li>files that we generate but don't expect user modifications;</li>
<li>files that the user generates.</li>
</ul>

<p>
We need a way to classify these.
</p>

<p>
Dart should use stitch templates to generate files.
</p>

<p>
We may need some options such as "generate boost test ctest
integration", etc.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li><a href="https://github.com/elbeno/skeleton">Skeleton</a>: project to generate c++ project skeletons.</li>
<li>split all of the configuration of CMake dependencies from main CMake
file. Possible name: ConfigureX? ConfigureODB, etc. See how find<sub>X</sub>
is implemented.</li>
<li>detect all projects by looping through directories.</li>
<li>fix CMake generation so that most projects are generated by Dogen.</li>
<li>add option to Dogen to generate test skeleton.</li>
<li>detect all input models and generate targets by looping through
them.</li>
<li>add CMake file to find knitter etc and include those files in
package. We probably should install dogen now and have dogen rely on
installed dogen first, with an option to switch to "built" dogen.</li>
<li>generate git ignore files with common regexes. See <a href="https://github.com/github/gitignore">A collection of
useful .gitignore templates</a>. We could also model it as a meta-model
object with associated options so that the user does not have to
manually edit the file.</li>
<li>generate top-level CMake, allowing user to enter dependencies and
their versions (e.g. Boost 1.62 etc) and CMake version.</li>
<li>inject dogen support automatically to CMake (on a feature switch).</li>
<li>determine the list of projects by looking at the contents of the
input models directory.</li>
<li>user to enter copyright, github URL.</li>
<li>we probably need to create a kernel for dart due to the
peculiarities of the directory structure.</li>
</ul>

<p>
We should copy the approach from <code>dotnet</code>:
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new">dotnet new</a>: we could have an equivalent dogen new. We could also
copy the approach of templates (e.g. CMake template, Visual Studio
template, etc). We could also supply the packaging sources (though
this needs better modeling).</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-sln">dotnet sln</a>: we need an equivalent option to specify
components. List, add, remove.</li>
<li>we should search predefined directories (<code>modeling</code> etc).</li>
</ul>

<p>
<b>Directory Themes</b>
</p>

<p>
It seems obvious no one in C++ will agree with a single way of
structuring projects. The best way out is to start a taxonomy of these
project layouts (directory structure themes?) and add this to the
project generator as a theme. At present there are several already
available:
</p>

<ul class="org-ul">
<li><a href="https://github.com/vector-of-bool/vector-of-bool.github.io/blob/master/_drafts/project-layout.md">Project Layout</a>: see also discussion in <a href="https://old.reddit.com/r/cpp/comments/996q8o/prepare_thy_pitchforks_a_de_facto_standard/">reddit</a>. Also: <a href="https://vector-of-bool.github.io/2018/09/16/layout-survey.html">Project
Layout - Survey Results and Updates</a></li>
<li><a href="https://build2.org/">Build2</a>: the packaging system seems to have a preferred directory
layout. In particular, see <a href="https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#proj-struct">Canonical Project Structure</a>.</li>
<li>GNU: gnu projects seem to have a well-defined structure, if not the
most sensible.</li>
<li><a href="https://www.reddit.com/r/cpp/comments/cvuywh/structuring_your_code_in_directories/">Structuring your code in directories</a></li>
<li><a href="https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs#src.layout">The Pitchfork Layout (PFL)</a></li>
<li><a href="https://www.boost.org/development/requirements.html#Organization">Boost: Organization</a></li>
<li><a href="https://hiltmon.com/blog/2013/07/03/a-simple-c-plus-plus-project-structure/">A Simple C++ Project Structure</a></li>
</ul>

<p>
<b>Product Model</b>
</p>

<p>
Actually we have been going about this all wrong. What we've called
"orchestration" is in fact the product model. It is just lacking all
other entities in the product meta-model such as:
</p>

<ul class="org-ul">
<li>injection/coding models: injection/coding models are themselves
modeling elements within the product meta-model. However, to avoid
having to load an entire coding/injection model, a product coding
model can contain only the key aspects of the injection/coding
models we're interested in: a) file or path to the model b)
references c) labels: these allow us to group models easily such as
say "pipeline" or "injection" etc. d) references: with this we can
make a product graph of model dependencies. We can also avoid
rereading models. we can also figure out what packages needed by the
model graph.</li>
<li>build systems: visual studio, msbuild, cmake</li>
<li>ctest</li>
<li>CI: travis, appveyor.</li>
<li>kubernetes support, docker support.</li>
<li>valgrind</li>
<li>compiler: clang, gcc, msvc, clang-cl. Version of the compiler. This
is used in several places such as the scripts, CI, etc.</li>
<li>operative system: windows, linux. used in installation scripts, CI,
etc.</li>
<li>dependencies for install scripts; these are sourced from the
component models.</li>
<li>manual: org mode, latex</li>
<li>org agile: product backlog, sprints, vision, etc.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>a product may be associated with one or more primary technical
spaces (e.g. support for say C# and C++ in the same model). This
would have an impact at the product level.</li>
<li>a product could have some simple wale templates so that when you
initialise a product you would get a trivial dia model with a simple
entry point (for executables) or a library with maybe no types.</li>
<li>when generating a product we can generate all models (product and
component), generate just the product, generate a specific component
or generate a label (which groups components).</li>
<li>we need a "init" command that initialises a product. It needs a
product name and maybe some other parameters to determine what to
add. Maybe it just makes a product model and asks the user to fill
it in instead.</li>
<li>there are several types of component models: 1) models that do not
generate anything at all. these are useful for defining templates,
configurations, etc. 2) regular component models 3) product
models. 4) platform definition models that are used to adapt
existing libraries into MASD.</li>
<li>in this sense, we have two different models: product and
component. Both of these need to be projected into artefact space
(because we have multiple facets in products as well). This means we
somehow need to use archetypes from both models.</li>
<li>the product model should have meta-elements describing the component
models (perhaps <code>masd::component_model::target</code>, with a matching
<code>masd::component_model::reference</code> in the component models).</li>
<li>See aslo the story about directories in dogen: <a href="#org6aba1b9">Move models into the
project directory</a>.</li>
<li>we could create separate chains for product and component
model. This would imply a need for distinct model types. On the
product model, we would locate all of the meta-elements representing
a component model, and for each of these, run the product model
chain. For other meta-model elements we just run their associated
transforms - hopefully not many as these are expected to be very
simple elements. We should also make use of injection model caching
to avoid reloading models.</li>
<li>as with component models, we should also have templates for product
models so that we could simply do a "dogen new product" or some such
incantation and that would result in the creation of a dogen product
model and possibly its initial generation. One slight problem is
that if we do a "dogen new component" we still have to manually add
the component to the product model.</li>
<li>we need to have a separate injection adapter for product models so
that we filter out "invalid" meta-elements for the model
type. Similarly, in the component injection adapter, we should
filter out product model meta-elements (travis build files, etc).</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/bkaradzic/GENie">GENie - Project generator tool</a></li>
<li>see <a href="https://github.com/cginternals/cmake-init">cmake-init</a> for ideas.</li>
<li><a href="https://github.com/premake/premake-core">Premake: powerfully simple build configuration.</a></li>
<li><a href="https://jgcoded.github.io/CMakeStarter/">CMake Starter</a>: "This website is a simple tool to help C++ developers
quickly start new CMake-based projects. The tool generates an entire
C++ project with boiler-plate CMake files and source code, and the
generated project can be downloaded as a zip file."</li>
<li><a href="https://awfulcode.io/2019/04/13/professional-zero-cost-setup-for-c-projects-part-1-of-n/">Professional, zero-cost setup for C++ projects (Part 1 of N)</a>:</li>
</ul>
</div>
</div>

<div id="outline-container-org1944d13" class="outline-4">
<h4 id="org1944d13"><span class="section-number-4">3.1.142</span> Add support for the static/dynamic pattern&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-142">
<p>
A common use case in Dogen is the "static/dynamic" pattern. It must
exist somewhere in a pattern catalogue. It is as follows:
</p>

<ul class="org-ul">
<li>base class has a virtual method, say <code>id()</code>.</li>
<li>descendants implement the virtual method, but we know at compile
time what the values should be. So we create a <code>static_id()</code> and
then implement <code>id()</code> in terms of <code>static_id()</code>.</li>
</ul>

<p>
Ideally we want to code-generate this infrastructure. A twist to this
is when we have some elements where the descendant may not have a
static ID.
</p>

<p>
Use cases:
</p>

<ul class="org-ul">
<li>meta-model names.</li>
<li>formatter names.</li>
</ul>
</div>
</div>

<div id="outline-container-org1ecda7f" class="outline-4">
<h4 id="org1ecda7f"><span class="section-number-4">3.1.143</span> Add additional reference directories&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-143">
<p>
At present we expect the reference models to be either on the data
directory (for system models) or on the same directory as the
target. Presumably, users may also want to have models on other
directories. For example, if one were to extend Dogen with a different
project, it would be required to load models from the dogen
directory.
</p>

<p>
We could simply add a command line argument for reference directories;
if the reference is not found in the target model directory, we would
then try all available reference directories.
</p>

<p>
We should implement this as a <code>-I</code> parameter akin to compilers. We
should also have a command to output the current include path - check
GCC to see what command they use for this.
</p>

<p>
This will be a requirement in order to support PDMs because we shall
have many directories with models. We will need the concept of "system
include directories" for this. We need to look into how compilers do
this. We must also dump these in dumpspecs.
</p>

<p>
Merged Stories:
</p>

<p>
<b>Add additional data files directories</b>
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want dogen to use my own private data
libraries so that I don't have to supply them as diagrams.
</p>

</blockquote></div>

<p>
Users should be able to provide directories for their own JSON
models. We just need to add a new parameter to the knitter and
transport it all the way to OM's workflow.
</p>

<p>
In the future, when everything is a model, data file directories and
reference directories will become one and the same.
</p>
</div>
</div>

<div id="outline-container-org8c665f5" class="outline-4">
<h4 id="org8c665f5"><span class="section-number-4">3.1.144</span> Add version support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-144">
<p>
At present we are generating the product version file as part of some
CMake hackery. In reality, this is really a property of a MASD product
and possibly component. We could even consider it to be a meta-model
element.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>there should be a meta-model element for version. It should be
usable in either product or component models. In product models, we
still need to figure out where the file with the details should be
placed.</li>
<li>version can then be used for details such as travis/appveyor
version, CMake version, DLL/SO version, assembly properties, etc.</li>
<li>however, we need to figure out how components will be able to see
product level elements.</li>
<li>this can also be used for <a href="#org02d6eb5">serialisation versioning</a>.</li>
<li>the version is a property of the product itself, so perhaps we
should just make it a meta-data element. Then, if you would like the
version to come out as a header file you need to create a "product
version" element. This will use the product version (in a yet to be
defined manner). This would allow users to decide where they want
the header file to be created. A similar approach can be taken for
components as well.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Supply dogen version as a configuration parameter</b>
</p>

<p>
At present we are using the <code>config.hpp</code> file in several places in
dogen to determine the dogen version. This makes things complicated
when we don't actually care about the particular version such as in
tests. We should supply the version as part of the initial
configuration and then reuse it from there.
</p>
</div>
</div>

<div id="outline-container-org0443b3d" class="outline-4">
<h4 id="org0443b3d"><span class="section-number-4">3.1.145</span> Allow dropping facet postfix for an element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-145">
<p>
We sometimes need to suppress the facet postfix. For example, when
outputting tests, at present we have:
</p>

<pre class="example">
cpp_ref_impl.boost_model/generated_tests/main_tests.cpp
</pre>


<p>
We may want it just to be called:
</p>

<pre class="example">
cpp_ref_impl.boost_model/generated_tests/main.cpp
</pre>


<p>
However, we don't want all files on that facet to drop their postfix,
just main.
</p>
</div>
</div>

<div id="outline-container-org700c5ff" class="outline-4">
<h4 id="org700c5ff"><span class="section-number-4">3.1.146</span> Add "is abstract" to profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-146">
<p>
Some profiles are created to be inherited from and are not meant to be
instantiated. We should have an "is abstract" flag on profiles and
error if a user attempts to instantiate a profile.
</p>

<p>
For now, by convention, we have marked these profiles as abstract in
Dia.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we should let the user know when they create a stereotype against an
abstract profile, or conversely when they create a non-abstract
profile which does not have a stereotype.</li>
</ul>
</div>
</div>

<div id="outline-container-org63c7975" class="outline-4">
<h4 id="org63c7975"><span class="section-number-4">3.1.147</span> Detect non-configurable fields&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-147">
<p>
Some stereotypes cannot be placed in a configuration. Placing them
there will only cause confusion and hard to debug errors. List:
</p>

<ul class="org-ul">
<li><code>injection.dia.comment</code>: this is only applicable to the UML note in
dia.</li>
<li><code>injection.reference</code>: as we need these to load models, it would
cause cycles if placed in configuration.</li>
<li><code>injection.input_technical_space</code></li>
<li>all fields needed to load the configuration itself, as it would
cause cycles.</li>
</ul>

<p>
We should have a property in the field such as "supports
configuration" or configurable or some such. When reading the
configuration, we need to validate that none of the entry templates
contain fields with this value set to false.
</p>

<p>
Its not quite "supporting configuration", more like " supporting
unbound configurations". All features are by definition configurable.
</p>

<p>
A related problem is the converse: some fields <span class="underline">can</span> be placed on a
configuration. In this case, we should not read the fields prior to
performing configuration expansion. This can probably be detected
quite easily: say we can have a flag that tells us if we have expanded
the configuration. If the flag is false, we should throw when we
attempt to read fields that can be placed in profiles. In effect we
are saying configurations exist in one of two states:
</p>

<ul class="org-ul">
<li>pre-expansion, in which only fields that are "pre-expansion" can be
read;</li>
<li>post-expansion, in which only fields that are "post-expansion" can
be read.</li>
</ul>
</div>
</div>

<div id="outline-container-org676c8c4" class="outline-4">
<h4 id="org676c8c4"><span class="section-number-4">3.1.148</span> Replace variability enum mapper with lexical casts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-148">
<p>
Its not clear what value the mapper adds now we can just lexical cast
enums from strings.
</p>
</div>
</div>

<div id="outline-container-orgc9c3bfb" class="outline-4">
<h4 id="orgc9c3bfb"><span class="section-number-4">3.1.149</span> Enablement problem is in the variability domain&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-149">
<p>
Up to now we have considered the enablement problem as a generation
model problem, but this is incorrect. The enablement problem is
basically the idea that if I set a type to be hashable (for example),
the system should implicitly determine all other types that need to be
hashable too. This means that if I have descendants, they should also
be hashable, and if I have properties, the type of those properties
must also be hashable. In reality this is just a variability
problem. We need to tell the variability model about:
</p>

<ul class="org-ul">
<li>features that require "propagation across model elements". We need a
good name for this, without referencing model elements.</li>
<li>the relationship between bound configurations. This can be copied
from the model element (the bound configuration has the exact same
name as the model element).</li>
</ul>

<p>
Then, we can simply build a DAG for the feature model using only bound
configurations (e.g. at present, binding type of "not applicable") and
then DFS the DAG setting properties across this relationship. Call the
relationship R between a and b, where a and b are configurations; all
properties that have the "propagate" flag on will be copied across
from a to b as is (due to R). If done after building the merged model
and after stereotype expansion this will work really well:
</p>

<ul class="org-ul">
<li>we don't really care how a got into the state it is at present, we
just copy the relevant properties across.</li>
<li>there is no solving, BDD, etc. However, R must not have cycles. We
probably need to first see how many cycles we find with inheritance
and associations.</li>
<li>we may need a way to switch this off. Say we really want to
introduce a cycle; in that case, the bound configurations should be
ignored.</li>
</ul>

<p>
Note that we will probably need to store pointers to the configuration
in order for this to work, or else we'll end up doing a lot of lookups
and copying around (to get the configurations from the model elements
into variability, the DAG etc and then back into the model at the
end).
</p>

<p>
Interestingly, this also means that we should not move the
global/local enablement computations into archetypes as we had planned
earlier. Instead, we need to explore if it is possible to generalise
the notion of "local" and "global" configurations, with overrides and
default values. This would work as part of the configuration binding
via implicit relationships - its just that the global configuration is
not really a relationship inferred from the underlying model. We then
need to look at the cleverness that we are using for overwrite as
well. Whilst we only need this logic for enablement, it may be useful
for other fields as well in the future. We also need some kind of way
of declaring certain fields as "cloneable" (for want of a better
term). In this case, we start off with a list of these fields, and if
there is no configuration point for them locally, we take the global
configuration point; if none exists, we take the default value.
</p>

<p>
Actually its more like "hierarchical copy" because we need to take
into account the hierarchy. In addition, we don't particularly care
about say backend, facet, etc at the element level, we just want the
archetype. So we need to encode these rules as a type of bind. It can
even be hacked as a bind "special" just for this purpose, its still a
better approach.
</p>

<p>
Another interesting issue is that of "reverse references". That is,
the fact that a model m is referenced by a set of models S; each of
these models may enable facets on elements that are associated with
elements from model m. On a first pass, we need to be able to consider
the configuration requirements as "non-satisfiable". The user
requested a configuration on the target model which cannot be
satisfied unless we alter the configuration of a referenced model. On
a second pass, when we have product level support, we could consider
adding "referenced" models to each model. This means that when we are
building m we have visibility of how m is used in the product and we
can take those uses into account when building the DAG.
</p>

<p>
We should really read up on OMG's CVL and associated technologies, as
it seems they have done much of the analysis required here.
</p>

<p>
Merged stories:
</p>

<p>
<b>Propagate <code>fluent</code> stereotype</b>
</p>

<p>
It would be nice to be able to mark an object template called say
Message with <code>dogen::fluent</code> and then have all of the classes that
instantiate that template set to fluent.
</p>

<p>
This is a variation on the general problem of feature propagation
(e.g. hashing, etc).
</p>

<p>
It would also be nice to have a meta-data parameter to determine if
the "auto-propagation" is on or off.
</p>

<p>
<b>Computation of enablement values</b>
</p>

<p>
Note: this story is still <b>very</b> sketchy.
</p>

<p>
At present we have a very simple way of determining what formatters
are enabled: if a facet has been enabled by the user then all
formatters on that facet are enabled. This is a good starting point
but results in a lot of manual work:
</p>

<ul class="org-ul">
<li>if we add a type which does not support all facets, we will generate
invalid code. Users should be able to mark which facets are
supported and then the graph of dependencies should do the right
thing, propagating the disabled status.</li>
<li>we are enabling all formatters in a facet. For hashing and forward
declarations, it would make more sense to have a "dependency based
enablement": if we determine that someone in the model needs that
feature, we enable it, if not its disabled. Users can always
override this and force it to be globally enabled.</li>
<li>if a user creates a "service", all facets other than types are
disabled. Ideally we should be able to define "enablement profiles"
and then set an element's enablement profile. Each enablement
profile is made up of a set of enabled facets. They could be
supplied as a KVP. In fairness we probably just need "types and io"
or "default".</li>
</ul>

<p>
One way to think of this problem is to imagine a matrix for each
element in element space. Each matrix is two-dimensional: one
dimension is the facets and the other are "dependent elements". These
are effectively made up of all attributes for each element, with a
name tree expansion. Each value of the matrix can either be 0
(disabled), 1 (enabled) or 2 (not computable). Not computable is a
hack to cope with cycles in the graph of dependencies.
</p>

<p>
Each value is computed by looking up an element's matrix and looking
for zeros. If there is one or more zero against a facet, the element's
value for that facet is zero. If there is a two we need to do a
two-pass whereby we first compute the matrix ignoring all the two's;
then, for each cycle we create a list of all the elements on that path
and the pair of elements that causes the cycle. We then compute the
enablement for this pair with a simple table (OR the computed
enablement values). We then traverse the cycle in reverse, updating
the twos to real values.
</p>

<p>
We could start with one large matrix with rows by element and columns
by feature. All values on this matrix are set to 1. We would then
multiply it against the global enablement matrix. We would then
multiply it by the local enablement matrix, for each element. We would
then compute the dependency matrices for all elements only taking into
account facets that are still enabled. We need to find the linear
algebra operation that takes a column with zeros and ones and returns
one if all rows are one and zero otherwise.
</p>

<p>
This produces the enabled facets. We then need to worry about the
formatters. There are a few sources of information:
</p>

<ul class="org-ul">
<li>the facet enablement.</li>
<li>the user local or global decision for that formatter.</li>
<li>some kind of default formatter property (e.g. disabled by default).</li>
<li>dependencies.</li>
</ul>

<p>
For these we need to create a "get dependencies" method in
each formatter which returns dependent formatters. For example, the
visitor formatter depends on the forward declarations formatter. This
is a static dependency. The more complex case is where there are
dynamic dependencies. For example, if hashing is detected for a given
type, we then need to enable the hashing facet for the containee. We
should probably hard-code this scenario for now.
</p>

<p>
We may want to make these computations disableable. For example: a)
all: no computation, everything is enabled b) all supported: all that
is supported is enabled c) by dependencies.
</p>

<p>
Requested help from FB. Core of the email:
</p>

<div class="epigraph"><blockquote>
<p>
Lets start with the simple case. Let G be a DAG. For each vertex of G
there is an associated vector over a field F. Now I would say F is
GF(2), which suits my needs (as you will see below). The objective is
to compute, for each vertex, the value of its associated vector, as
follows:
</p>

<ul class="org-ul">
<li>first we go through the vertices in any order and setup its initial
values according to a predetermined heuristic. Different nodes will
have different values, and the heuristic has no dependency on G.</li>
<li>then we iterate through G using DFS. If a vertex has no children
then the final value of its vertex is the initial value. If a vertex
has children, the value of its vector is obtained by multiplying the
initial value against the values of the vectors of its child
vertices. Multiplication under GF(2) is just a logical AND which is
great for my purposes.</li>
</ul>

<p>
Just to make sure I'm explaining my self correctly, lets look at it in
layperson's terms: if a vertex has a 1 at position zero of its vector,
and all of its children also have a 1 at position zero, then the final
value for position zero will be 1. If there is a 0 anywhere at
position zero then the value is 0. So far so good, this works as
expected.
</p>

<p>
However! The problem is, G is actually not always a DAG. Sometimes
there may be cycles, which are detectable during DFS. My question is:
is there anything I can do to still perform this heuristic (or some
approximation of it) with a graph that has cycles? For example:
</p>

<ul class="org-ul">
<li>record the path to the cycle and perform several passes. This seems
to breakdown when there are several cycles because I seem to hit
some kind of recursive problem.</li>
<li>ignore the cycle. Of course, the problem with this approach is that
if there was a zero at either side of the cycle, I would be
incorrectly computing the node, but maybe that's the best one can
do?</li>
</ul>

</blockquote></div>

<p>
Actually maybe we are looking at this the wrong way. Lets imagine that
for each element there is a vector v in GF(2) called the initial
vector. The objective is to compute u, the output vector. The output
vector is made up of the initial vector of the element, times the
output vectors of all the elements the element depends on. However,
these can be formulated in terms of initial vectors too (e.g. the
initial vector of the depended element times the initial vectors of
the elements it depends on times the initial vectors of the elements
they depend on and so forth). Thus for each element there is an
expansion that just relies on initial vectors. For the cases where
there are cycles: its not a problem since multiplying n times by
the same vector (in GF(2)) produces the same result as multiplying
just once.
</p>

<p>
It would still be useful to have a graph though, to find all of the
initial vectors for a given element. We just need to stop DFS'ing when
we find a cycle. We can also cache the initial vectors for each
element.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we can greatly simplify this story if we do not allow for cycles. We
can simply create a graph of all dependencies and then iterate the
graph from the leaves. Call Ev the enablement vector for each
element; we can descend the graph and perform an OR of Ev at each
level. Consider element e0, which is a child of a set of elements E;
for each entry in the set, we'd OR the element vector of e0 (and of
all of its descendants). As a result, its values would be the
superset of all of the enabled values on each leaf element.</li>
<li>since we do not allow cycles, we should detect them and break with
an error. We should provide the cycle path to the user and then
allow users to remove certain types from this computation via
meta-data. If a type is set not to contribute to the graph, we can
simply skip it. The user is then responsible for manually setting
that type.</li>
<li>since we can only alter generatable types, we should detect when we
reach an element which is not generatable. If the OR'ing of that
element does not produce its current enablement vector we should
simply error and tell the user the current enablement requirements
are not satisfiable. The user is then responsible for addressing the
issue by either changing enablement requirements, ignoring types,
updating reference models manually or providing helper types. To
make life easier we could state what are the enablement requirements
that have not been met so that users can quickly decide what to do.</li>
<li>once we compute the dependency graph we can also check to see what
types are on it. Any type which is absent can be removed from the
model. We could also compute the models that are on the graph and
compare them to the list of references. If the list of references at
present only includes references of the target model, we can figure
out any unnecessary references. Sadly we cannot do the opposite:
(lost the train of thought).</li>
<li>it would be nice to have "enablement requirements". For example, if
the user used <code>std::unordered_map</code> against a dogen type, it should
trigger the generation of hash for that type (and all dependent
types). Similarly, for <code>std::map</code> it should trigger the creation of
<code>operator&lt;</code>. If we could declare upfront that a type's types facet
depends on another facet, this could be computed.</li>
</ul>

<p>
<b>Formatters need different <code>enabled</code> defaults</b>
</p>

<p>
We should be able to disable some formatters such as forward
declarations. Some users may not require them. We can do this using
dynamic extensions. We can either implement it in the backend or make
all the formatters return an <code>std::optional&lt;dogen::formatters::file&gt;</code>
and internally look for a <code>enabled</code> trait.
</p>

<p>
We need to be able to distinguish "optional" formatters - those that
can be disabled - and "mandatory" formatters - those that cannot. If a
user requests the disabling of a mandatory formatter, we must
throw. This must be handled in enabler.
</p>

<p>
This story was merged with a previous one: Parameter to disable cpp
file.
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to disable cpp files so that I don't
generate files with dummy content when I'm not using them.
</p>

</blockquote></div>

<p>
It would be really useful to define a implementation specific
parameter which disables the generation of a cpp file for a
service. This would stop us from having to create noddy translation
units with dummy functions just to avoid having to define exclusion
regexes.
</p>

<p>
In some cases we may need a "enable by usage". For example,
it would be great to be able to enable forward declarations only for
those types for which we required them. Same with hash. We can detect
this by looking at the generated include dependencies. However,
because the include dependency only has a directive, we cannot tell
which formatter it belonged to. This would require some augmenting of
the directive to record the "origination" formatter.
</p>

<p>
<b>Disable facets on element state</b>
</p>

<p>
In certain cases it may not make sense to enable a facet. The main use
case is for testing: we should not bother testing an object if there
are no attributes. This can be achieved with a small hack: add a
container in archetype repository of all archetypes that require
objects to have properties. Then, augment <code>is_element_disabled</code> to
perform this check. We just need formatters to supply this information
when building the repository.
</p>

<p>
A much more robust version would be to have formatters return a
function that takes in the element and returns true or false. We could
default all formatters to just return true. However, we do not have
support for boost/std function so this would mean manually coding the
repository. We'd have a similar problem if we add an interface.
</p>

<p>
<b>Add support for facet dependencies</b>
</p>

<p>
At present we left it as an exercise to the user to ensure facets are
enabled to meet dependencies. In reality we need a solver for
this. Look for other solver story in backlog. In addition, we also
need to have a way to declare facet dependencies:
</p>

<ul class="org-ul">
<li>all facets other than types depend on types.</li>
<li>tests depends on at least types and test data.</li>
</ul>

<p>
Actually what we really need is a model to declare all entities in the
archetype space and their relationships:
</p>

<ul class="org-ul">
<li>archetypes</li>
<li>facets</li>
<li>formatters</li>
<li>kernels</li>
</ul>

<p>
The annotations model can then depend on this model. It should have
facilities for registration of kerneles, etc. However, note that this
has nothing to do with model to text transforms - its just declaring
the lay of the land for the archetype space. We called this generation
space up to know but generation is concerned with the mapping of
coding entities into archetype space, not with defining the geometry
of that space. We need a good name for this model:
</p>

<ul class="org-ul">
<li><code>masd.dogen.archetypes</code></li>
</ul>

<p>
This also makes it clear why annotations had a need for locations in
archetype space: its because the configuration is the configuration of
formatting functions which are responsible for mapping coding elements
into archetypes. Of course we have configuration that is not related
to archetypes as well. We need some kind of way of stating this at the
archetype model level so that we don't have to associate all features
with a location on archetype space when none exists.
</p>

<p>
<b>Add support for formatter and facet dependencies</b>
</p>

<p>
Once we are finished with the refactoring of the C++ model, we should
add a way of declaring dependencies between facets and between
formatters. We may not need dependencies between facets as these are
actually a manifestation of the formatter dependencies.
</p>

<p>
These are required to ensure users have not chosen some invalid
combination of formatters (for example disable serialisation when a
formatter requires it). It is also required when a given
facet/formatter is not supported (for example when an STL type does
not support serialisation out of the box).
</p>

<p>
Note that the dependencies are not just static. For example, the types
facet depends on the hash facet if the user decides to add a
<code>std::unordered_map</code> of a user defined type to another user defined
type. We need to make sure we take these run-time dependencies into
account too.
</p>
</div>
</div>

<div id="outline-container-orgae4d389" class="outline-4">
<h4 id="orgae4d389"><span class="section-number-4">3.1.150</span> Invalid stereotypes outside of objects are not detected&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-150">
<p>
At present we are only checking for invalid stereotypes (e.g. those
which are neither static stereotypes, nor profiles nor object
templates) on objects and object templates. We need to add a validator
that checks all other element types. This should be easy, if we ended
up with any dynamic stereotypes we should error.
</p>

<p>
In fact we should generalise this processing: object templates should
mark their stereotypes as bound and then we will check every element
for any unbound stereotypes using the traversal.
</p>

<p>
We should solve this problem as part of the logical meta-model, by
creating some form of binding between the declared stereotypes and the
meta-model elements.
</p>
</div>
</div>

<div id="outline-container-org4b34d23" class="outline-4">
<h4 id="org4b34d23"><span class="section-number-4">3.1.151</span> Setting include and source directory to empty&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-151">
<p>
At present it does not seem possible to set either the include or
source directories to empty. This probably just requires annotations
to understand empty values, e.g.
</p>

<pre class="example">
a.b.c=
</pre>
</div>
</div>

<div id="outline-container-orgeff6eb7" class="outline-4">
<h4 id="orgeff6eb7"><span class="section-number-4">3.1.152</span> Throw on unsupported stereotypes for specific kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-152">
<p>
In some cases we may support a feature in one language but not on
others like say ORM at present. If a user requests ORM in a C# model,
we should throw.
</p>

<p>
If we are in compatibility mode, however, we should not throw.
</p>

<p>
Note that we are already throwing if a stereotype is totally
unknown. The problem here is that the stereotype is known, but not
supported for all kernels. This is a bit trickier.
</p>

<p>
We also need to check the existing code in stereotypes transform to
stop trowing if compatibility flag is on.
</p>

<p>
This means we need some kind of way of attaching a feature to a
technical space and a TS version.
</p>
</div>
</div>

<div id="outline-container-org89b425b" class="outline-4">
<h4 id="org89b425b"><span class="section-number-4">3.1.153</span> Add support for multi-components in a model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-153">
<p>
In the world of cross-model transformations (see story), we need lots
of separate models just because they need to generate their own
libraries or executables. It is a bit of a shame that we need to have
a number of "modelets", each for its own component. An alternative
would be to support multiple components from a single model, but this
would be a bit tricky. Thoughts:
</p>

<ul class="org-ul">
<li>the model would have a multi-component mode, set at the top. No
model elements are allowed at the top level.</li>
<li>each package has a stereotype of <code>dogen::component</code> (not the best of
names given it conflicts with UML component diagrams). Dogen
generates each of these namespaces as a separate component
(e.g. shared library or executable).</li>
<li>the top-level model name becomes the first model name, the package
name the second model name. Interestingly, this should mean dogen
will generate all components on the top-level directory without any
additional work.</li>
<li>the easiest thing to do in terms of the existing pipeline is to
create the concept of components at the meta-model level and then
create a transform that takes a component based model and generates
one model per component and processes them one at a time with the
existing pipeline. However, we need to be careful because one model
will contain all of the business logic whereas the other models are
simple references to it. This could be addressed by having
references, based on the existing model references.</li>
</ul>
</div>
</div>

<div id="outline-container-org0e79ed6" class="outline-4">
<h4 id="org0e79ed6"><span class="section-number-4">3.1.154</span> Create "opaque" kernel and element properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-154">
<p>
As part of the element container, we can have a set of base classes
that are empty: <code>opaque_element_properties</code>. This class is then
specialised in each kernel with the properties that are specific to
it. We probably need an equivalent for:
</p>

<ul class="org-ul">
<li>kernel level properties</li>
<li>element level properties</li>
<li>attribute level properties.</li>
</ul>

<p>
We then have to do a lot of casting in the helpers.
</p>

<p>
Once we got these opaque properties, we can then create "kernel
specific expanders" which are passed in to the yarn workflow. These
populate the opaque properties.
</p>
</div>
</div>

<div id="outline-container-org0a8ccf9" class="outline-4">
<h4 id="org0a8ccf9"><span class="section-number-4">3.1.155</span> Consider creating a "variant" meta-model type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-155">
<p>
Variants are a pain in the backside to define because they result in
really large elements. It would be much nicer to have a meta-model
element that encapsulates the definition of the variant, where each
attribute is a valid value of the variant (say
<code>masd::structural::variant</code>). We could then take one of several
approaches:
</p>

<ul class="org-ul">
<li>generate a "typedef" for the variant as a file. This is the easiest
way to fit in the existing framework. It could even include support
for serialisation, etc.</li>
<li>"convert" the variant into a name tree and replace the existing
mentions with it. This is not as nice.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we could also generate visitors for the variant. See <a href="#orgb298589">this story</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org20446b1" class="outline-4">
<h4 id="org20446b1"><span class="section-number-4">3.1.156</span> Consider changing variability value into a variant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-156">
<p>
Really all we are doing is adding a lot of infrastructure to be able
to store different types of values. This is what the variant is
designed to do. In addition, we then have all of the complexities
around selection that are already handled by variant.
</p>

<p>
If we did this then the declaration of feature bundles would have
native types and we would not need to have any mapping. This would
simplify a lot the variability work and also would then mean we don't
need two different kinds of mappings (fixed and extensible). The only
slight concern is how we handle the processing of values at present:
we need to know the type in order to cast it correctly. For most cases
this is simply hard-coded, but for key value pairs and for containers
we need to take the appropriate action. Perhaps we could resolve this
by using SFINAE? Basically provide implementations for each of the
valid values.
</p>
</div>
</div>

<div id="outline-container-orgb1230a1" class="outline-4">
<h4 id="orgb1230a1"><span class="section-number-4">3.1.157</span> Come up with a name for models that contain "meta-elements"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-157">
<p>
At present we created a number of models called "profiles"; these have
only the profiles for configuring specific products. However,
conceivably we want them to also store the generation markers and
possibly licences, modelines, etc. Basically all of the shared
meta-infrastructure. We need a name that reflects this.
</p>

<p>
Ideas:
</p>

<ul class="org-ul">
<li>configuration</li>
</ul>
</div>
</div>

<div id="outline-container-orgffdb610" class="outline-4">
<h4 id="orgffdb610"><span class="section-number-4">3.1.158</span> Use of binding points in profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-158">
<p>
At present we have the concept of a binding point in a feature. This
allows us to determine how a feature can be bound to a modeling
element in a configuration. For example, take feature <code>X</code> with a binding
point of <code>global</code>; this feature can only be configured in the root
module because it does not make sense to exist anywhere else.
</p>

<p>
This concept was already present in the old annotations model, where
we checked that a "scope type" of a field matched the scope type of
the element. However, this was present haphazardly in profiles; we had
the notion of a "scope type" on a profile as a property but the
profile hydrator never populated it; in addition, the profiler only
set the annotation scope:
</p>

<pre class="example">
pc.annotation().scope(scope_types::not_applicable);
</pre>


<p>
We probably started thinking about this but stopped half-way. So, if
we try to retrace our steps logically:
</p>

<ul class="org-ul">
<li>a profile could conceivably have a binding point. It would be used
to validate that all profiles it merges against also have the same
biding point (or similar; say <code>any</code> or <code>module</code> for <code>global</code>). It
could also be used to validate that the feature templates referred
to in its configuration point templates are also compatible.</li>
</ul>

<p>
At present we have preserved the old logic of having a binding point
in a profile as a feature, and left the initial feature processing
support in the adaptor transform, but:
</p>

<ul class="org-ul">
<li>we did not add it to the profile template and profile classes;</li>
<li>consequently we are missing all of the validation logic defined
above.</li>
</ul>

<p>
We did some work on this for sprint 25:
</p>

<ul class="org-ul">
<li>profiles now have binding points in the logical model, and meta-data
is now being read to obtain the value of the profile.</li>
<li>we did not hook in the profile conversion when adapting the logical
profile to the variability profile (in <code>profile_adapter</code>) because
when we tried, it caused all profiles to break. Apparently we have a
number of inconsistencies in the way we are using features in
profiles. This requires some investigation. However, this work
should way until we do the terminology clean up of the variability
model.</li>
</ul>
</div>
</div>

<div id="outline-container-org047bfcc" class="outline-4">
<h4 id="org047bfcc"><span class="section-number-4">3.1.159</span> Investigate current implementation of the origin transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-159">
<p>
Do we need to have the origin transform? can we not just supply the
origin type to the adapter directly?
</p>

<p>
Actually this cannot be done. The problem is we still need to
distinguish between dogen models and non-dogen models; we need to
register all dogen models. This is done via meta-data. We cannot use
the meta-data until we have converted into a logical model. We could
consider having a flag at the injection level for this - it is a
concept at this level - but we still need to map it to origin
types. However, it is perhaps cleaner to express this concept at the
logical level rather than the injection level given we are saying
there are two different kinds of injection models: proxyness is a
fundamental property of an injection model. If we do this we can then
do the mapping in flight as we transform from injection to logical
model.
</p>

<p>
This story is directly connected to "model types".
</p>
</div>
</div>

<div id="outline-container-org616dc16" class="outline-4">
<h4 id="org616dc16"><span class="section-number-4">3.1.160</span> Add <code>ignore</code> meta-model element for VCS ignore files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-160">
<p>
It would be nice if we had a meta-model element to represent ignore
files for version control. For extra bonus points we should support
multiple version control systems. We should also have out of the box
ignore collections. These could link in via technical spaces. We
should also be able to use composition (e.g. C++ with CMake and Visual
Studio). It should also be possible to generate a user defined
collection.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/github/gitignore">gitignore</a>: A collection of useful .gitignore templates. We should
use this project, unmodified; perhaps by adding a PDM model which
imports the git ignore files they provide. The downside is having to
create meta-model elements for each file.</li>
</ul>
</div>
</div>

<div id="outline-container-org0083770" class="outline-4">
<h4 id="org0083770"><span class="section-number-4">3.1.161</span> Consider creating meta-entity for root module&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-161">
<p>
At present we are supplying model properties via a "special" comment
in a model. Items such as model<sub>modules</sub> etc are read from this
comment. We then generate the root module and use these properties to
configure model-wide variability. However, according to the rule that
there are no implicit model elements, we should have a meta-model
element representing the root module. The properties of this element
should reflect those on the "special" comment.
</p>

<p>
Or perhaps a case can be made that the root module is special and it
is the only implicit element.
</p>

<p>
Actually this can be explained via projections from spaces - e.g. the
model projects as a namespace into the physical model. However, the
only inconsistency is that we have both the notion of a model as well
as the notion of the root module. For consistency we should not
require the root module in the logical domain.
</p>
</div>
</div>

<div id="outline-container-org7db29f5" class="outline-4">
<h4 id="org7db29f5"><span class="section-number-4">3.1.162</span> Handling of "derived meta-types"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-162">
<p>
In the past we had the notion of "element extensions". This was
basically a way to allow a meta-element to have more than one
associated representation. For example: many elements can give rise to
forward declarations in C++, so it would be nice to transform these
"source" elements into a second (common) element that reflects this
(say a "forward declaration" meta element). Then we can easily create
a simple template. However there were numerous problems with this
approach:
</p>

<ul class="org-ul">
<li>we had two distinct elements occupying the same point in modeling
space. Due to this we made elements contain elements (effectively,
though it wasn't explicit in the design).</li>
<li>we then had the notion that an archetype associated with a was no
longer a "complete" location in archetype space; this is because
until you know the facet for which you are creating the forward
declaration for you cannot know your location in archetype space.</li>
<li>code was rather complex in order to handle all of these special
cases.</li>
</ul>

<p>
To solve this problem we made forward declarations an archetype,
projected across facets. This made the design much neater but now we
have a second problem: we need to duplicate all of the formatting
logic for e.g. objects, enumerations, etc and worse, for each facet as
well.
</p>

<p>
The existing state was just too complex so we just "fixed it" at the
time. However, we now have a very similar problem with ODB "object"
options. These are only applicable to a facet, at least, but we still
need them for more than one element (primitive, object).
</p>

<p>
One possible solution is to use the same approach as we did for
helpers, but in a much simpler way. We could:
</p>

<ul class="org-ul">
<li>create simple functions that just take an assets type design for the
template (e.g. forward declaration, element ODB options).</li>
<li>the element itself would contain these types, which are created as
part of the transforms.</li>
<li>the existing facet level templates simply call the helper function,
supplying the type.</li>
</ul>

<p>
We still have to create all of the duplicate machinery for the
formatter, but once all of that is code-generated, this won't be too
much of a problem. This way there is no duplication of formatting
code, but also no meta-model complexity. Conceptually, these are just
facets, but at the implementation level they are implemented
differently. This also means we do not violate the rule of making
implicit meta-model elements explicit.
</p>
</div>
</div>

<div id="outline-container-orgc695f5a" class="outline-4">
<h4 id="orgc695f5a"><span class="section-number-4">3.1.163</span> Make vistor a proper meta-model element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-163">
<p>
At present we use the stereotype of <code>visitable</code> to emit a
visitor. This violates the principle of making all types
explicit. Instead, we should:
</p>

<ul class="org-ul">
<li>create a new stereotype <code>masd::visitor</code>. It triggers the creation of
the visitor meta-model element.</li>
<li>visitor must have a target via meta-data. This points to the element
to visit.</li>
</ul>

<p>
We need to make sure we don't break cross model visitation with this
change - i.e. derived models must also explicitly create their own
visitors.
</p>
</div>
</div>

<div id="outline-container-orgae157f9" class="outline-4">
<h4 id="orgae157f9"><span class="section-number-4">3.1.164</span> Create a README meta-type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-164">
<p>
Once we have a product generation framework, it makes sense to have
the README as a meta-type, with its contents as markdown. We could
then generate all of the emblems. These can be properties that we
enable or disable in the meta-type as required (e.g. visual studio
version, etc).
</p>

<p>
This should be done when support for products has been implemented.
</p>
</div>
</div>

<div id="outline-container-org70f6499" class="outline-4">
<h4 id="org70f6499"><span class="section-number-4">3.1.165</span> Schema name in ORM should be transitive&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-165">
<p>
At present when we define the schema name on a top-level namespace, we
don't "inherit" it from child namespaces. The problem is compounded by
the fact that we need the schema name in order to output ODB pragmas
(separate bug). It seems more logical to propagate the schema name to
child namespaces.
</p>
</div>
</div>

<div id="outline-container-org2bde602" class="outline-4">
<h4 id="org2bde602"><span class="section-number-4">3.1.166</span> ODB pragmas not populated when schema name is not set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-166">
<p>
At present we have a bug whereby not setting the schema name results
in not having most ODB pragmas set. We should always populate them
even if the schema name is not set. To be precise, the problem is not
directly related to the schema name - we just require some ORM
property to be set. AS it happens, it normally tends to be the schema
name, because it makes sense to set it when defining a relational
model. This is why we never bumped into this problem before.
</p>
</div>
</div>

<div id="outline-container-org68b7b2d" class="outline-4">
<h4 id="org68b7b2d"><span class="section-number-4">3.1.167</span> Assorted improvements to CMake files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-1-167">
<p>
It seems we are not using proper CMake idioms to pick up compiler
features, as explained here:
</p>

<ul class="org-ul">
<li><a href="http://unclejimbo.github.io/2018/06/08/Modern-CMake-for-Library-Developers/">Modern CMake for Library Developers</a></li>
<li><a href="https://cliutils.gitlab.io/modern-cmake/">An Introduction to Modern CMake</a></li>
<li><a href="http://www.slideshare.net/DanielPfeifer1/cmake-48475415">CMake - Introduction and best practices</a></li>
<li><a href="https://datascience.lanl.gov/data/151208-LANL-Hoffman-Science.pdf">Building Science with CMake</a></li>
<li><a href="http://voices.canonical.com/jussi.pakkanen/2013/03/26/a-list-of-common-cmake-antipatterns/">A list of common CMake antipatterns</a></li>
<li><a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/">The Ultimate Guide to Modern CMake</a></li>
<li><a href="https://github.com/crezefire/cxp">CXP: C++ Cross Platform</a>: A template project for creating a cross
platform C++ CMake project using modern CMake syntax and transitive
dependencies.</li>
<li><a href="https://cgold.readthedocs.io/en/latest/">CGold: The Hitchhikers Guide to the CMake</a></li>
<li><a href="https://polly.readthedocs.io/en/latest/index.html">Polly: Collection of CMake toolchains</a></li>
<li><a href="https://github.com/sblumentritt/cmake_modules">GH cmake<sub>modules</sub></a>: "This repository provides a wide range of CMake
helper files."</li>
</ul>

<p>
We need to implement this using proper CMake idioms.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>Add version and language to project.</li>
<li>start using <a href="https://cmake.org/cmake/help/v3.3/command/target_compile_options.html">target compile options</a> for each target. We will have to
repeat the same flags; this could be avoided by passing in a
variable. See also <a href="http://stackoverflow.com/questions/23995019/what-is-the-modern-method-for-setting-general-compile-flags-in-cmake">What is the modern method for setting general
compile flags in CMake?</a></li>
<li>define qualified aliases for all libraries, including nested
aliasing for <code>dogen::test_models</code>. Ensure all linking is done
against qualified names.</li>
<li>use target include directories for each target and only add the
required include directories to each target. Mark them with the
appropriate visibility, including using <code>interface</code>. We should then
remove all duplication of libraries in the specs.</li>
<li>try replacing calls to <code>-std=c++-14</code> with compiler feature
detection. We need to create a list of all C++-14 features we're
using.</li>
<li>remove all of the debug/release compilation options and start using
<code>CMAKE_BUILD_TYPE</code> instead. See <a href="http://pastebin.com/jCDW5Aa9">this</a> example. We added build type
support to our builds, but as a result, the binaries moved from
<code>stage/bin</code> to <code>bin</code>. There is no obvious explanation for this.</li>
<li>remove <code>STATIC</code> on all libraries and let users specify which linkage
to use. We already have a story to capture this work.</li>
<li>remove the stage folder and use the traditional CMake
directories. This will also fix the problems we have with
BUILD<sub>TYPE</sub>.</li>
<li>consider buying the CMake book: <a href="https://crascit.com/professional-cmake/">https://crascit.com/professional-cmake/</a>.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Usage of external module path in cmakelists</b>                       :story:
</p>

<p>
It seems like we are not populating the target names
properly. Originally the target name for test model all built-ins was:
</p>

<pre class="example">
dogen_all_builtins
</pre>


<p>
When we moved the test models into <code>test_models</code> the target name did
not change. It should have changed to:
</p>

<pre class="example">
dogen_test_models_all_builtins
</pre>
</div>
</div>

<div id="outline-container-orgf32bb4d" class="outline-4">
<h4 id="orgf32bb4d"><span class="section-number-4">3.1.168</span> Support for cmake components and groups&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-168">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I need to integrate the generated models
with my existing packaging code.
</p>

</blockquote></div>

<p>
We recently added support for creating multiple packages from a single
source tree. We need generated models to have a new top-level cmake file:
</p>

<pre class="example">
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/src)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/tests)

install(
    DIRECTORY include/
    DESTINATION include
    COMPONENT headers
    FILES_MATCHING PATTERN "*.hpp")
</pre>


<p>
And the <code>src</code> cmake file:
</p>

<pre class="example">
install(TARGETS dia ARCHIVE DESTINATION lib COMPONENT libraries)
</pre>
</div>
</div>

<div id="outline-container-org39c0f09" class="outline-4">
<h4 id="org39c0f09"><span class="section-number-4">3.1.169</span> Warn on transitive references to models used directly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-169">
<p>
At present, when we reference a model B, we get all of the models it
references. However, if model A (the target) is using types of say
model C, it should reference it directly rather than via B. If B
changes, A will break. It would be nice to have a warning for these
types of referencing.
</p>
</div>
</div>

<div id="outline-container-org061c05d" class="outline-4">
<h4 id="org061c05d"><span class="section-number-4">3.1.170</span> Mapping of third-party dependencies (PDMs)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-170">
<p>
System models should follow the physical structure of
dependencies. That is, we should not have a "boost" system model, but
instead a boost-test etc. Each of these can then have mappings
(e.g. vcpkg name, build2 name, etc). Users must declare these
references just like they do with user models. Dogen can then create
code for:
</p>

<ul class="org-ul">
<li>cmake targets, properly linking against libraries;</li>
<li>vcpkg install, at product level, by de-duplicating component
dependencies;</li>
<li>possibly distro dependencies.</li>
</ul>

<p>
We should only have a mandatory dependency, which is the STL. In
addition, we need different models for each version (e.g. c++ 03,
etc). This makes it easier to include the right types.
</p>

<p>
Note that each model must have an associated version. The version
should be part of the file name. However, maybe we need to distinguish
between TS version (11, 17, etc) from library version.
</p>

<p>
One way of solving this regularity problem (e.g. having
masd::std::string is the real name but its annoying to have to have
users typing this) is to support "using" statements at the model
level. If a user could type something like <code>using masd</code> and this would
allow us to find all types as if we had typed <code>masd::</code> then users
could still type <code>std::string</code> and find <code>masd::std::string</code>. We'd
solve both the regularity and the "look and feel". The downside is
that this could have important ramifications in resolution:
</p>

<ul class="org-ul">
<li>how does this work in the presence of merged models? do we merge
usings? will this find types we're not supposed to find?</li>
</ul>

<p>
Needs some more thinking.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>utility model must be split into multiple models: the PDMs should go
with their own models. The real utilities should stay on a utility
product. This can then be reused by dogen (for example, if logging
is enabled it uses the logging setup from this model). Users should
be able to switch it off though.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Platform description models</b>
</p>

<p>
We should consider integrating all of the information regarding
"platforms" into platform description models (PDMs). These include:
</p>

<ul class="org-ul">
<li>all types available in a library (proxy models) and their mapping in
terms of aspects. We could make the mapping a bit clearer by
designing platform description models that are not part of
modeling. We don't really need support for attributes, operations
etc. However, we need some kind of "adaptor" that extracts all the
type information (or some other way of making resolution work across
different model types).</li>
<li>name of the library, supported language (e.g. for Boost, C++ etc),
versions of the library. We must associate the types with a version
(e.g. introduced on version X, deprecated on version Y) so that when
the user is using a given version it errors if a type is not
available.</li>
<li>packaging support: mapping to the name used on most common packaging
systems such as DEB, RPM etc. Also, mapping on language specific
package managers such as build2, vcpkg, conan, nuget, etc. User can
decide what package manager to use overall or for a specific library
(e.g. possible to mix-and-match package manager). It should also
have a mapping for CMake support that includes "in CMake library
from version X" and "available on an external source" with a URL. If
the user selects the latter, Dogen can download the CMake file (or
maybe Dogen should include the external CMake files to guarantee a
stable behaviour).</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>with this we can now move away from the bad modeling used with proxy
models, where it was not quite clear what they were. We can create
a different file format (e.g. <b>.pdm</b> )that can share some
similarities with existing JSON models but is not stuck with all the
baggage needed to represent user models.</li>
<li>however, PDMs are just regular models. Users should be able to make
use of the PDM stereotypes to define PDM types in a regular UML
model. Interestingly, a PDM from this perspective is similar to a
named configuration. The difference is that it introduces a new type
into the type system rather than a new stereotype. But with this we
can now make use of named configurations, making PDMs a lot less
verbose (e.g. define a named config and share it across multiple
types, like SmartPointer etc). We could even share it across
multiple platform models!</li>
<li>PDMs should be organised by language (e.g. folder for cpp, etc). Top
level directory is PDM rather than library.</li>
<li>users declare references to PDMs just like normal models. PDMs have
an attribute for "auto-loading". If on, we load regardless. Else it
must be referenced. This is useful for say STL, hardware types.</li>
<li>users can supply their own PDMs, although they are encouraged to
submit them if they are general enough.</li>
<li>if users choose CMake as the build system, we automatically add all
the boilerplate required to add the library to CMake. In an ideal
world, the PDM should contain the CMake snippets, with "macros"
where required (e.g. version, etc). This would mean we wouldn't have
to change templates when new libraries are added. We could also have
a "standard" CMake snippet that works for most libraries.</li>
<li>different libraries may have different types of support (e.g. a
library may not exist in a package manager, etc)</li>
<li>we could now create an installation script that sets up all
dependencies (e.g. DEB/RPM). It cannot be a target because the build
would fail (e.g. CMake would not find all dependencies).</li>
<li>now that <code>library</code> can be renamed to <code>pdm</code>, we could call the
top-level directory <code>library</code>.</li>
</ul>

<p>
<b>Adding linking libraries is not handled</b>
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to link against libraries without
having to manually generate CMakeFiles.
</p>

</blockquote></div>

<p>
At present whenever a model requires additional link library targets
we need to disable CMake generation and do it by hand. However:
</p>

<ul class="org-ul">
<li>for well-known dependencies such as boost we could create a
convention (e.g. assume/require that the CMake boost libraries flags
are set via find boost). Alternatively, the types should contain
meta-data that has information about linking requirements; e.g. if
you use a type from a boost model, it should provide you with
linking information in its meta-data. Each boost type could have
different information depending on which boost library they come
from.</li>
<li>for user level dependencies we should add dynamic extensions at the
model level. Also, references provide sufficient information to link
against other dogen models.</li>
</ul>
</div>
</div>

<div id="outline-container-org494644e" class="outline-4">
<h4 id="org494644e"><span class="section-number-4">3.1.171</span> Add support for object templates that work cross-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-171">
<p>
We've implemented support for cross-model inheritance in sprint 87 but
we did not cover object templates. Most of the approach is the same,
but unfortunately we can't just reuse it.
</p>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>we need a refines field which is a text collection.</li>
<li>we need refinement settings, factory etc.</li>
<li>update parsing expander.</li>
</ul>

<p>
Merged Stories:
</p>

<p>
<b>Cannot make qualified references to concepts</b>
</p>

<p>
At present it is not possible to consume concepts defined in a
referenced model, nor is it possible to refer to a concept in a
different module from the module in which the element is in, e.g.: say
concept C0 is declared in module M0; all types of M0 can have C0 as
stereotype and that will resolve. However any types on any other
module cannot see the concept.
</p>

<p>
One suggestion is to allow scoped names in stereotypes:
<code>module::Concept</code>.
</p>

<p>
The heuristic for concept resolution is then:
</p>

<ul class="org-ul">
<li>external modules are never part of the scoped name;</li>
<li>on a scoped concept with M names, we first start by assuming that
the first name is the model module and M-2 is/are the internal
module(s). We try this for all names in M-2, e.g. first two names
are model modules and M-3 names are internal modules and so forth.</li>
</ul>

<p>
<b>Add support for using object templates across models</b>
</p>

<p>
At present it is not possible to make use of a concept across models
or even modules in the same model. We have two problems:
</p>

<ul class="org-ul">
<li>resolution will probably fail;</li>
<li>even if resolution does work, the elements of the concept will be
invalid. This is because they will have relative references to types
(e.g. <code>Nameable</code> concept in <code>yarn::meta_model</code> assumes it is in
that module and so makes use of <code>name</code> rather than
<code>yarn::meta_model::name</code>).</li>
</ul>

<p>
For this to work we could:
</p>

<ul class="org-ul">
<li>create a flat resolution for concepts, whereby all concepts are
resolved from the stereotypes just by the simple name rather than
the qualified name. This means we cannot have two concepts with the
same name across all loaded models. The alternative is to force
users to fully qualify concepts,
e.g. <code>yarn::meta_model::Nameable</code>. In which case we should probably
stop using the upper case convention,
e.g. <code>yarn::meta_model::nameable</code>.</li>
<li>actually the second problem may even be moot; if concept resolution
is performed before we merge attributes, all references will be
fully qualified by then. We need to test this.</li>
</ul>

<p>
Final conclusion: if somehow one was able to fully qualify concepts as
part of the stereotype, this would work out of the box.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we did some work on this previously: <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/v1/sprint_backlog_00.org#concepts-cannot-be-placed-inside-of-packages">Concepts cannot be placed
inside of packages</a>. This solved some of the problems such as
allowing concepts to be placed in packages. We just need to test
this. It may be that we are not merging object templates.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcdd2dba" class="outline-4">
<h4 id="orgcdd2dba"><span class="section-number-4">3.1.172</span> Rename validators to checkers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-172">
<p>
In the literature, model validators seems to be called
"checkers". There are global checkers and local checkers. We need to
go through our validation logic and see if we can follow the pattern
of the literature. In particular we need a definition for what a
checker is and what global/local means. Also, should there be checkers
associated with model elements? For example, check that an enumeration
has enumerators, that these have distinct names, etc.
</p>

<p>
We should have a documented set of rules for this, like compiler
errors. We need to classify these by severity:
</p>

<ul class="org-ul">
<li>warning</li>
<li>error</li>
<li>information</li>
</ul>

<p>
The result of the checker should be a list of "events" at different
levels which can then be handled by the user interface - e.g. for the
command line output errors like clang/gcc so that we can integrate
with emacs.
</p>

<p>
Checkers also include meta-data validation, such as missing fields,
fields with incorrect types, etc.
</p>

<p>
We also need to understand the difference between model checking and
model verification.
</p>

<p>
We also need to look at EVL: <a href="https://www.eclipse.org/epsilon/doc/evl/">Eclipse Validation Language</a>. See Chapter
4 of the <a href="https://www.eclipse.org/epsilon/doc/book/">Epsilon book</a>.
</p>
</div>
</div>

<div id="outline-container-org32a0359" class="outline-4">
<h4 id="org32a0359"><span class="section-number-4">3.1.173</span> Add stereotypes support at the attribute level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-173">
<p>
At present dia does not have stereotypes in attributes. This means
things like ORM primary keys etc are being supplied as tagged values;
in reality, its more natural (from a UML perspective) to supply them
as stereotypes. We could add some meta-data that creates a tagged
value for stereotypes.
</p>

<p>
This also lines up with the story we had where we question our use of
attributes. In reality we have created a notion of "property". We need
a stereotype for this.
</p>
</div>
</div>

<div id="outline-container-org7c332af" class="outline-4">
<h4 id="org7c332af"><span class="section-number-4">3.1.174</span> Rename types that clash with reserved keywords&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-174">
<p>
When we added the new validation rules, yarn did not pass
validation. This is because <code>module</code> and <code>concept</code> are reserved on
current C++ TS's. Since we know these features will land in C++ sooner
or later, we should rename these types to avoid problems. Namestorm:
</p>

<ul class="org-ul">
<li>module: package (clashes with java?)</li>
</ul>
</div>
</div>

<div id="outline-container-org5a1af9f" class="outline-4">
<h4 id="org5a1af9f"><span class="section-number-4">3.1.175</span> The <code>types</code> facet should always be on&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-175">
<p>
At present users are given the option to enable or disable the
<code>domain</code> facet; this is not very wise because all facets depend on
it. It must always be on. We should remove these options.
</p>

<p>
In addition the facet is incorrectly named: when we performed the
rename of <code>domain</code> to <code>types</code> we left the command-line facet. We
should rename it to <code>types</code> too.
</p>

<p>
We should probably create a notion of "mandatory" facets to make this
more general.
</p>

<p>
Actually, we did find <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#consider-c-itself-as-a-front-end">one use case</a> where types needs to be off.
</p>

<p>
In general, this is a variation of the problem of the graph of
dependencies between facets at the element level.
</p>
</div>
</div>

<div id="outline-container-org0d74e6f" class="outline-4">
<h4 id="org0d74e6f"><span class="section-number-4">3.1.176</span> Improving use of exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-1-176">
<p>
Exceptions in dogen are not providing enough contextual
information. The problem is that we just see the information available
at the throw site, not the context regarding the processing
pipeline. Boost exception has the required tooling for this, but we
are not making use of it correctly. Ideally we need to know:
</p>

<ul class="org-ul">
<li>model currently being processed</li>
<li>element</li>
<li>attribute</li>
<li>name tree</li>
<li>name in name tree</li>
<li>phase in the yarn pipeline (e.g. injection, etc)</li>
<li>phase in the quilt.cpp pipeline (e.g. building properties,
formatting, etc).</li>
<li>file and line where the element was defined in the frontend.</li>
</ul>

<p>
Not all of these make sense at the same time. What would be ideal is:
</p>

<ul class="org-ul">
<li>create a base exception for each model with all the attributes we
need to capture.</li>
<li>add support for automatic generation of Boost Exception tags for
each attribute.</li>
<li>add support for exception logging via IO.</li>
<li>change all throw paths to fill in the attributes by catching
exceptions and augmenting them. This seems quite involved
overall. In some cases, we probably just need to locate a few select
entry points (pipeline etc), but for others such as attributes etc
this will be hard.</li>
<li>log the exception only at the final catch point. We no longer need
to log at throw because the catch will have all the information (and
more).</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Provide contextual error messages during validation</b>
</p>

<p>
As per the validator story, we need to ensure the model we are
processing is valid. However, the validator must provide contextual
validation error messages:
</p>

<pre class="example">
error 1: properties must have a non-null name
in model 'my_model' (Dia ID: O0)
in object 'my_object (Dia ID: O0)
property 'my_property' has empty name.
</pre>


<p>
We should also try to make this compatible with compiler errors so
that we can go to the file where the error occurred:
</p>

<pre class="example">
file.dia:5:10: properties must have a non-null name
</pre>


<p>
For this to work we need to label everything with a file, column and
line. We can't call this class a <code>location</code> since we already use that
name for positions in model space. We could probably call it
<code>source_location</code> like <a href="http://clang.llvm.org/doxygen/classclang_1_1SourceLocation.htlm">clang does</a>. We can use <a href="https://developer.apple.com/library/prerelease/content/documentation/Darwin/Reference/usr_APIs/tree/index.html">XML<sub>GET</sub><sub>LINE</sub></a> to get
information about the line number of dia documents. We need something
similar for JSON.
</p>

<p>
The context should be provided using Boost Exception diagnostics and
dumped into <code>std::cerr</code> at the very top.
</p>

<p>
<b>Improve file importer errors</b>
</p>

<p>
It would be nice if one could know the file, line and column where an
error has occurred when importing any imported file. Even for Dia,
this would make troubleshooting much easier. We need to add some
information to the meta-model to keep track of the source of the
types: file, line start, line end perhaps.
</p>
</div>
</div>

<div id="outline-container-org44c7a05" class="outline-4">
<h4 id="org44c7a05"><span class="section-number-4">3.1.177</span> Attributes versus properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-177">
<p>
At present we have assumed that all attributes in objects should be
generated as properties. This is not quite the right thing to do; one
may actually want to generate a member variable which is not a
property. One solution would be to create a dynamic extension at the
class level that defaults all attributes to properties (or to member
variables). This could be the default for objects but not for
services. The right thing would be to have attribute stereotypes but
dia does not support these.
</p>

<p>
We would have to extend assets to understand member variables as well
as properties.
</p>

<p>
Actually we should just have a meta-model concept for a masd property,
which knows about getters and setters; these are associated with masd
object's and object templates. Attributes, if required, need their own
meta-model representation. This also means that we should determine
the getter/setter settings within coding (for example, if immutable
disable setter etc).
</p>

<p>
We can then create the notion of a "pojo", where all attributes are
automatically mapped to properties.
</p>
</div>
</div>

<div id="outline-container-orgf139815" class="outline-4">
<h4 id="orgf139815"><span class="section-number-4">3.1.178</span> Replace boost property tree with real JSON support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-178">
<p>
Once we support JSON fully we should go through all of the uses of
JSON we have at present and replace them with the JSON serialised
version of the types.
</p>
</div>
</div>

<div id="outline-container-org09a5ff0" class="outline-4">
<h4 id="org09a5ff0"><span class="section-number-4">3.1.179</span> Handling of inclusion constants needs reviewing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-179">
<p>
At present we hard-coded "inclusion<sub>constants</sub>" in C++ formatters for
common includes such as string, etc. However, what we are really
trying to say is that a given model type for a given facet should have
a resolver level dependency against a type on a PDM.
</p>

<p>
This is not so straightforward: up to now the idea was that you'd
declare the types level dependency between types. In effect, we have
one big upfront association between types at the coding level and
then we use that to determine what it means in terms of associations
between facets. Now, we already have some hacks to deal with the
relationships between facets:
</p>

<ul class="org-ul">
<li>types needs types;</li>
<li>most other facets need themselves and types, but not all.</li>
</ul>

<p>
This is handled via the <code>inclusion_dependencies</code> functions in each
formatter, which also injects additional includes via
inclusion<sub>constants</sub>. However, the problem with this approach is that
we have a silent dependency against models such as boost model and
system model. The right solution would be something like:
</p>

<ul class="org-ul">
<li>formatters know what models they require and at the beginning of
processing we inject all model references from the formatters.</li>
<li>coding has a new type of association: implicit dependencies. These
are functions with a name and a facet that map to a facet. Example:
serialisation requires (<code>std::string</code>, types). The formatter injects
all of these relationships to each object (by meta-type).</li>
<li>this container is taken into account when computing the includes.</li>
<li>it is also taken into account when resolving names.</li>
<li>coding could provide an interface against which the formatters could
register to provide this information. This is somewhat similar to
what we do with dynamic transforms.</li>
<li>logging (if really required) is another special case. This is
because for each model we'll have a different logging
implementation. We need to somehow map to it.</li>
</ul>
</div>
</div>

<div id="outline-container-org4fdc5d4" class="outline-4">
<h4 id="org4fdc5d4"><span class="section-number-4">3.1.180</span> Consider adding an indent JSON transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-180">
<p>
Once we start making use of a proper JSON library, we should output
indented JSON models as part of conversion. We always have to indent
manually anyway. For extra bonus points, it would be nice if the
indent could cope with our invalid JSON (not deleting duplicate keys).
</p>

<p>
We could even expose it as an activity/command so that we could indent
external files without going through conversion; this would be useful
for library models.
</p>
</div>
</div>

<div id="outline-container-orged463f3" class="outline-4">
<h4 id="orged463f3"><span class="section-number-4">3.1.181</span> Update copyright notices&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-181">
<p>
We need to update all notices to reflect personal ownership until DDC
was formed, and then ownership by DDC.
</p>

<ul class="org-ul">
<li>first update to personal ownership has been done, but we need to
test if multiple copyright entries is properly supported.</li>
</ul>
</div>
</div>

<div id="outline-container-org481db5a" class="outline-4">
<h4 id="org481db5a"><span class="section-number-4">3.1.182</span> Remove empty default values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-182">
<p>
At present we have a number of default values in feature bundles set
to the empty string <code>""</code>. It makes more sense not to have a default
value and have the client code handle its absence.
</p>

<p>
Once we do this, we can then remove the spurious quotes we added to
all feature templates and do that directly in code-generation. It was
added only because we needed to distinguish between the empty case and
the "empty" string.
</p>
</div>
</div>

<div id="outline-container-org978e2bf" class="outline-4">
<h4 id="org978e2bf"><span class="section-number-4">3.1.183</span> Add logging support to generated tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-183">
<p>
At present generated tests are not writing to the log file. This is
because we wanted to keep them clean so that users could generate
tests for their models without having to pull in dogen
headers. However, for dogen tests this is a bit painful; if a test
fails we can't just look at the log file to see why. We could have a
flag to generate tests with logging.
</p>

<p>
The other problem is we need to move utility into its own library as a
PDM before we can do this because otherwise the logging will be in
different locations (i.e. dogen vs reference model).
</p>

<p>
We should add some meta-data flag to suppress/enable logging.
</p>
</div>
</div>

<div id="outline-container-org0fc8e95" class="outline-4">
<h4 id="org0fc8e95"><span class="section-number-4">3.1.184</span> Move ORM camel-case and databases into assets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-1-184">
<p>
We should handle this property at the ORM level, rather than at the
ODB level.
</p>

<p>
Similarly, we should move the ODB databases into yarn and make that a
ORM-level concept.
</p>
</div>
</div>
</div>

<div id="outline-container-org09f14dd" class="outline-3">
<h3 id="org09f14dd"><span class="section-number-3">3.2</span> Feature Heap</h3>
<div class="outline-text-3" id="text-3-2">
<p>
New features for this release. These are more nice to haves rather
than mandatory work.
</p>
</div>

<div id="outline-container-org2842c1b" class="outline-4">
<h4 id="org2842c1b"><span class="section-number-4">3.2.1</span> Licence compatibility errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reviewing">reviewing</span>&#xa0;<span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
If we correctly annotate all PDMs with a licence, as well as all model
code, we could define "compatibility relationships" between
licences. For example we could say that a model M with a proprietary
licence including a PDM P with GPL licence is an error. This could
come up as any other error would. We could have a "compatible with"
field in licences for this.
</p>
</div>
</div>

<div id="outline-container-orgd9bf6b5" class="outline-4">
<h4 id="orgd9bf6b5"><span class="section-number-4">3.2.2</span> Add support for operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to specify operations via the
frontend so that I dogen can generate the header file and I can
manually add the implementation.
</p>

</blockquote></div>

<p>
This story is a requirement in order to implement merging support.
</p>

<p>
We now have in place almost all building blocks needed to implement
operations. Note that operations should be the only use case for
code-merging. Anything more complicated than this should just be
handcrafted. The basic idea is that we define operations just like we
define attributes (see simplified parsing below). We then code
generate the function signature for the operation on the header and
implementation files. In the implementation c++ file we add markers
like so:
</p>

<pre class="code"><code><span style="color: #35CDAF;">void</span> <span style="color: #339CDB;">some_class</span>::<span style="color: #D9DAA2;">some_func</span><span style="color: #C586C0;">()</span> <span style="color: #C586C0;">{</span>
<span style="color: #5F7F5F;">// </span><span style="color: #579C4C;">{{{ 507ab9d0-d1a5-4fa9-97a9-d78a48a08c3d</span>
<span style="color: #DB8E73;">&lt;</span><span style="color: #35CDAF;">some</span> <span style="color: #85DDFF;">content</span><span style="color: #DB8E73;">&gt;</span>
<span style="color: #5F7F5F;">// </span><span style="color: #579C4C;">}}}</span>
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
Users can freely edit <code>&lt;some content&gt;</code>. During the generation
pipeline, the implementation file will have the UUID written out as a
string, e.g.:
</p>

<pre class="code"><code>507ab9d0-d1a5-4fa9-97a9-d78a48a08c3d
</code></pre>

<p>
Then, when we are generating files, as part of the artefact pipeline,
we first read the file we are about to write and extract any blocks
such as the above (block extraction transform). For each block we
perform a search and replace on the generated file. Then we do the
writing. The org-mode file has a link to the file. This means we have
full LSP support for code writing.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need to handle the initial case. We should create a map of
"required UUIDs".</li>
<li>we also need some meta-data that allows injecting include files for
the operation implementation.</li>
<li>org-mode supports "text search"; see the <a href="https://orgmode.org/manual/External-Links.html#FOOT27">external links</a>
section. This means we can do a link like so:</li>
</ul>

<pre class="code"><code>file:f1.cpp::507ab9d0-d1a5-4fa9-97a9-d78a48a08c3d
</code></pre>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://emacs.stackexchange.com/questions/63391/how-do-i-link-to-an-id-on-a-non-org-mode-file">SO: How do I link to an ID on a non org-mode file?</a></li>
<li><a href="https://github.com/nobiot/org-transclusion/issues/59">Transclusion of non-org mode files #59</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Existing support</b>
</p>

<p>
When we did the expansion and indexing work for properties, we omitted
operations altogether. This is fine for now, as we only have a
half-baked support for them anyway, but will need to be revisited as
we start to use it in anger. In particular:
</p>

<ul class="org-ul">
<li>we need sets of operations: local, inherited, all</li>
<li>we need an operations indexer</li>
</ul>

<p>
Actually we removed the half-baked support.
</p>

<p>
<b>Simplify argument parsing for operations</b>
</p>

<p>
One of the main stumbling blocks for adding support for operations has
been the complexity of parsing all the permutations allowed by
C++. However, for the majority of use cases we have found so far
(particularly for the definition of interfaces), we don't actually
require access to the full expressiveness of c++:
</p>

<ul class="org-ul">
<li>we don't use raw pointers that much;</li>
<li>we always pass types by const reference or const (simple types);</li>
<li>in cases where we need full power, we can always hand-craft those
classes.</li>
</ul>

<p>
If we were to only allow types in arguments to be those already
available for attributes, we could start parsing operations really
easily. Once we have those, a few use cases open up:
</p>

<ul class="org-ul">
<li>generation of skeleton for classes (header and c++);</li>
<li>full generation of interfaces;</li>
<li>we can start work on services/remoting (see other stories)</li>
<li>we can start to consider generating SWIG interfaces,</li>
</ul>

<p>
In addition, Dia has a direction for each parameter (e.g. In, In &amp;
Out, etc) so this can also be leveraged.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we should disable parsing of operations if hand-crafted is on (or do
a shallow parse and just literally copy the string; we have another
story for this in the backlog).</li>
<li>we should make all operations simplified: e.g. not support the
complexities of C++ etc. We only support simple UML like
syntax. Additional information must be conveyed via mapping.</li>
</ul>

<p>
<b>Basic support for operations</b>
</p>

<p>
We could add support for operations without having full parsing
support for all variations in c++. This could be achieved as follows:
</p>

<ul class="org-ul">
<li>do not support LAM to start off with. Mapping of types requires
parsing all expressions on operations and this will not work until
we support pointers, references and const.</li>
<li>treat parameters in operations as a string - e.g. no parsing into
name trees. Because we cannot parse, we also cannot resolve
dependencies (e.g. the includes etc will not be right). One
alternative is to have a hard-coded support for just <code>const</code> and
<code>&amp;</code>, which are the only use cases we have at present. If the parser
could just ignore those we could still build name trees and have
dependency support.</li>
<li>for value objects, associate every operation with a protected
region. For handcrafted objects, they are used just for creating the
initial "class template" or the interface.</li>
<li>when code-generating the operation, merely write the variable name
and type without any transformation at all.</li>
<li>users must associate a GUID with the operation for the protected
region. This has to be done manually to preserve traceability
links.</li>
<li>since the protected region is bounded by function scope, we can
simply look for protected region begin and end markers, and copy the
region into the generated artefact.</li>
<li>the purpose of these operations is just to: a) add trivial behaviour
to value objects b) generate interfaces. It is kept really simple.</li>
</ul>
</div>
</div>




<div id="outline-container-org1072ff6" class="outline-4">
<h4 id="org1072ff6"><span class="section-number-4">3.2.3</span> Add stereotype for IoC containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
At present we are marking IoC containers with either handcrafted or
header only. In reality, they should have their own stereotype and
colours as, in the future, we want to code generate them. However, we
can only do this once we get rid of the initialisers because they are
also a form of IoC containers, but with different requirements.
</p>

<p>
Proposed stereotype: <code>masd::ioc::container</code>.
</p>

<p>
Actually, this is not quite right. We are not creating the IoC
containers themselves, but the wiring code that sets up these
containers. We need to figure out the correct term for
these. Suggestions:
</p>

<ul class="org-ul">
<li><a href="https://github.com/avao/Qart/blob/master/Src/Qart.CyberTester/Bootstrapper.cs">bootstrapper</a>, with a <code>Bootstrapper.CreateContainer</code> method;
e.g. <code>masd::ioc::bootstrapper</code>.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/autofac/Autofac">Autofac GH</a>: Autofac is an IoC container for Microsoft .NET. It
manages the dependencies between classes so that applications stay
easy to change as they grow in size and complexity. This is achieved
by treating regular .NET classes as components.</li>
</ul>
</div>
</div>

<div id="outline-container-org188b556" class="outline-4">
<h4 id="org188b556"><span class="section-number-4">3.2.4</span> Primitives are not comparable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
Our wrapping code around primitives means we can no longer perform
arithmetic operations on them or comparisons. This may be what is
intended (e.g. adding or multiplying <code>customer_id</code> does not make
sense) but it also means we can't delete ranges from the database for
example. It would be nice if there was some meta-data we could add to
primitives to make this possible:
</p>

<ul class="org-ul">
<li><code>comparable</code></li>
<li>etc</li>
</ul>

<p>
With this we would generate the appropriate operators by delegating to
the underlying type.
</p>

<p>
We probably need some way of knowing if the underlying type supports
comparisons. A meta-data flag used to annotate proxy models would be
sufficient.
</p>
</div>
</div>

<div id="outline-container-org4d8522a" class="outline-4">
<h4 id="org4d8522a"><span class="section-number-4">3.2.5</span> Exception classes should allow inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-5">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I need to generate object graphs for my
exception classes so that I can model my domain better.
</p>

</blockquote></div>

<p>
We need to have a form of inheriting from a base exception for a given
model. We also need to be able to inherit from other exceptions in a
model. At present exceptions are not objects so the dependency graph
support is not there.
</p>

<p>
When we do this we need to split relatable into "associatable" and
"generalisable" and get exceptions to model generalisable.
</p>
</div>
</div>

<div id="outline-container-orga5bace1" class="outline-4">
<h4 id="orga5bace1"><span class="section-number-4">3.2.6</span> Add ORM type mapping support to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-6">
<p>
At present we can setup a type map in ORM as follows:
</p>

<pre class="example">
#DOGEN masd.orm.type_override=postgresql,JSONB
</pre>


<p>
However, this is specific to attributes. It would be really nice to
have this at the primitive level as well so that we can map once and
reuse the mapping.
</p>

<p>
More generally, we now have three mechanisms for mapping, which cannot
possibly be a good thing:
</p>

<ul class="org-ul">
<li>extensible mapping: for LAM. Extensible, but not really, as users
need to physically change PDMs.</li>
<li>fixed mapping: extremely limited use, just for the variability
types. Similar in logic to the ORM mapping, but not as flexible (end
users need not be aware of its existence at all).</li>
<li>ORM mapping: at present we are using the default mapping on the
underlying technology (e.g. ODB). In truth though, some LAM like
mapping is happening, we just don't see it. That is, there exists a
SQL model with types, on a per relational database level, and we are
mapping C++ types to these types. The overrides are there for the
case where the user is not happy with this mapping.</li>
</ul>

<p>
We need to create a general mapping mechanism that can handle all
three use cases, including the overrides/extensibility. It could
signal when a mapping cannot be overriden (e.g. "final" mapping) or
when it is extensible. Users should then somehow be able to declare
overrides in their own models.
</p>
</div>
</div>

<div id="outline-container-org851c90e" class="outline-4">
<h4 id="org851c90e"><span class="section-number-4">3.2.7</span> Allow stereotypes in object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-7">
<p>
At present we need to use inheritance to "merge" object
templates. This has served us well, but has one limitation:
composition has to be tree-like. In practice, we have use cases where
composition is more haphazard, not allowing us to draw a clean
inheritance diagram. For example, we have the "properties-like
elements" in coding, that all have:
</p>

<pre class="example">
Documentable, Annotatable, Configurable, Nameable
</pre>


<p>
These could easily be packaged into a object template, but we can't
because its not possible to have two "kinds" of inheritance graphs -
we'd end up with lots of lines intersecting each other. However, a
natural way to solve this problem is to allow dynamic stereotypes in
object templates. These are mapped to parents and processed exactly as
if we had the inheritance relationship. From a practical perspective
this makes a lot of sense, but we need to make sure this is not
frowned upon from a theoretical perspective.
</p>

<p>
The other problem as well is that we need to mix and match dynamic and
static stereotypes (e.g. we need <code>masd::object_template</code> as well).
</p>

<p>
Another example of where this feature would come in handy is with
features and feature templates, which could share an object template
but can't because we also need to inherit from "Documentable,
Configurable, Nameable".
</p>
</div>
</div>

<div id="outline-container-orgaab1b57" class="outline-4">
<h4 id="orgaab1b57"><span class="section-number-4">3.2.8</span> Keep track of which transforms touch which elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-8">
<p>
It would be nice to be able to know, for a given modeling element,
which transforms modified it. We can add a property to element in
assets that is a list of transforms and guids, so that we can
distinguish invocations. This way we can then easily ask the database
for details.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>add a "modified by" container to element. Its a pair of transform ID
and GUID. Add it to models as well.</li>
<li>update every transform to record this information.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc3a3080" class="outline-4">
<h4 id="orgc3a3080"><span class="section-number-4">3.2.9</span> Allow property level bindings to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-9">
<p>
We should map any variability bindings that happen at the
property/attribute level to the anonymous attribute that all
primitives have. This is because its not possible to address the
anonymous attribute in a diagram. At present we are hacking these
features to the <code>any</code> scope just so that we can move on. Affected
features:
</p>

<pre class="example">
masd.orm.type_override
masd.orm.type_mapping
</pre>


<p>
In order for this to work, when we are building configurations from
the original meta-model element, we need to "override" the
type. However, this raises the question: what if we do want to bind
something at the primitive level? What if something binds both to the
property and the primitive?
</p>

<p>
The alternative is to make the attribute explicit. We need to think
about the consequences of this as well.
</p>
</div>
</div>

<div id="outline-container-org43df0fb" class="outline-4">
<h4 id="org43df0fb"><span class="section-number-4">3.2.10</span> Default model modules from filename&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-10">
<p>
It would be nice to be able to not have to supply model modules when
its obvious from the filename.
</p>

<p>
Update hello world to demonstrate this. We basically want to make the
entry use case as simple as possible, requiring little to no
meta-data.
</p>
</div>
</div>

<div id="outline-container-org9dc95a6" class="outline-4">
<h4 id="org9dc95a6"><span class="section-number-4">3.2.11</span> Handcrafted templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-11">
<p>
At present we generate constructors, swap, etc. for handcrafted
classes. Ideally users should be able to create a profile that enables
the things they want to see on a template and then associate it with a
stereotype. For this we will need aspect support.
</p>

<p>
A more interesting approach would be to combine wale (or its proper
replacement, a mustache based solution) with the meta-model: if one
could create <b>any</b> text file that can behave like this kind of
template, we could arbitrarily extend dogen for trivial use cases:
</p>

<ul class="org-ul">
<li>main, entry point.</li>
<li>interface.</li>
<li>other uses users may find. Because they can bind templates against
elements, this would make extensibility easier.</li>
</ul>

<p>
However, this is not a replacement for stitch: it is only helpful for
trivial cases and its not even clear it would work for all - e.g. how
would one loop trough all attributes in an object?
</p>

<p>
Actually, we probably already have enough for this to work, at least
for a few simple cases:
</p>

<ul class="org-ul">
<li>interfaces: wale template with correct constructors, destructors,
etc. For extra bonus points check operations.</li>
<li>trivial main.</li>
</ul>

<p>
We just need to use the wale template to create the first "draft" and
then set overwrite to false.
</p>
</div>
</div>

<div id="outline-container-org06603b4" class="outline-4">
<h4 id="org06603b4"><span class="section-number-4">3.2.12</span> Make use of association relationships&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-12">
<p>
When we start having to create elements such as visitor etc., it would
be nice to rely on the association between visitor and visitable to
figure out what the visitor is visiting. This and other simple cases
can be inferred simply by looking at the end points of the
association. However, we should still allow supplying this
meta-parameter as meta-data because it may not be practical to have
the association. And we need a way to express this in JSON as well.
</p>
</div>
</div>

<div id="outline-container-orgb5df3df" class="outline-4">
<h4 id="orgb5df3df"><span class="section-number-4">3.2.13</span> Consider allowing UML inheritance of object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-13">
<p>
It would be nice if we could infer that an object inherits an
interface from an object template via the "implements" generalisation,
and so does not require the stereotype.
</p>
</div>
</div>

<div id="outline-container-org158ade9" class="outline-4">
<h4 id="org158ade9"><span class="section-number-4">3.2.14</span> Consider inheriting annotations and stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-14">
<p>
At present we need to define the stereotype
<code>masd::cpp_artefact_formatter</code> on every formatter. However, we know
that all classes inheriting from <code>artefact_formatter_interface</code> are
all going to have this stereotype (and thus the same
configuration). It would be nice if it was possible to somehow put
this information into the interface itself and then anyone
implementing the interface would automatically inherit the
stereotypes. However, this should not be done automatically because we
probably have lots of cases where we use inheritance but don't expect
this to happen. Perhaps we could have some specific meta-data for
this:
</p>

<pre class="example">
descendant_stereotypes=xyz
implementer_stereotypes=xyz
</pre>


<p>
Or perhaps "propagate across inheritance". This is in effect, a variation
of IPC (implicit presence conditions).
</p>
</div>
</div>

<div id="outline-container-org86163e1" class="outline-4">
<h4 id="org86163e1"><span class="section-number-4">3.2.15</span> Consider creating shared pointer typedefs for leaves&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-15">
<p>
It would be nice to be able to enable the creation of shared pointer
typedefs for leaves, to simplify code such as:
</p>

<pre class="example">
void operator()(boost::shared_ptr&lt;coding::meta_model::structural::object_template&gt; ot) {
</pre>


<p>
to maybe:
</p>

<pre class="example">
void operator()(shared_object_template ot) {
</pre>


<p>
Users should be able to decide which shared pointer implementation to
use (maybe as a parameter to the meta-model element?). We could use
the forward declarations to define the typedef. Alternatively we could
define the typedefs with the leaf class itself, but then we'd be
pulling in the shared pointer into the header.
</p>
</div>
</div>

<div id="outline-container-org420fd2c" class="outline-4">
<h4 id="org420fd2c"><span class="section-number-4">3.2.16</span> Getter by reference of pointee&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-16">
<p>
A useful use case is, whenever we have a property which is of
pointer-like type (shared pointer, etc), is to return the type pointed
to by const reference. We should be able to configure the generator
for this:
</p>

<ul class="org-ul">
<li>we can already detect if the type is a pointer type;</li>
<li>we would need some meta-data at the property level (generate
de-refenced const/non-const setter). If this is used but the
property type is not a pointer then we should throw.</li>
<li>the generator would look for the meta-data, if enabled it would add
additional setters.</li>
<li>we may even want to suppress the pointer getters as well.</li>
</ul>
</div>
</div>

<div id="outline-container-orge25d803" class="outline-4">
<h4 id="orge25d803"><span class="section-number-4">3.2.17</span> Consider adding stereotypes into profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-17">
<p>
It would be nice to be able to define a profile called "ormable" and
then have it enable:
</p>

<ul class="org-ul">
<li>types</li>
<li>ODB</li>
<li>the appropriate ORM stereotype, e.g. <code>orm::object</code>, etc.</li>
</ul>

<p>
However, at present there is no way to associate a stereotype with a
profile. Note carefully that we do not mean allow binding profiles
against elements via stereotypes (this is what we do
already). Instead, we are saying is: allow defining stereotypes as a
configurable field within a profile and then when applying the
profile, set the stereotype of the element it binds against.
</p>

<p>
For this to work correctly we probably need to be able to at least
validate that the element to which we applied the profile is of the
expected type. Our binding at present is just "element" so it cannot
distinguish between enumerations, etc.
</p>

<p>
As far as just associating stereotypes with profiles, this could
actually be done fairly easily: we could have a dynamic field called
stereotypes and just apply these when expanding profiles. However, we
probably need to think about this very carefully as it could introduce
all sorts of weird and wonderful problems such as cycles in stereotype
resolution (what happens when we apply a stereotype which is actually
a profile name? is that just invalid or should we redo profile
expansion?). Unless we have a very important use case, we probably
should not allow this.
</p>
</div>
</div>

<div id="outline-container-org7a8edcb" class="outline-4">
<h4 id="org7a8edcb"><span class="section-number-4">3.2.18</span> Consider adding "deprecated feature names"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-18">
<p>
One way to allow the renaming of features across releases is to keep
track of the old name; we could create a property in a feature called
"deprecated feature name" or some such and when we fail to find a
feature, we could try to see if the deprecated feature names match. If
they do we could bind to the old name, issue a warning and
continue. By removing the name from deprecated feature field we'd
officially stop supporting the old name.
</p>

<p>
Alternatively we could just process deprecated features in exactly the
same way but issue a warning to users, just like compilers do. We
could also add support for a message deprecation message.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/attributes/deprecated">C++ attribute: deprecated</a></li>
<li><a href="https://stackoverflow.com/questions/295120/c-mark-as-deprecated">SO: C++ mark as deprecated</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfb44e5a" class="outline-4">
<h4 id="orgfb44e5a"><span class="section-number-4">3.2.19</span> Add string view to dogen exception constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-19">
<p>
At present we cannot build an exception if the string passed in is a
string view.
</p>
</div>
</div>

<div id="outline-container-org7a20a50" class="outline-4">
<h4 id="org7a20a50"><span class="section-number-4">3.2.20</span> Mask sensitive fields in io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-20">
<p>
Certain types contain fields that should not be logged by default. For
example, passwords, salt/seeds, etc. It should be possible to mark
these fields as "sensitive" such that when one dumps an object to the
logger the fields are masked out with say <code>****</code>. It should also be
possible to set an environment variable such as
<code>MASD_DO_NOT_MASK_SENTIVE</code> and get the actual values printed.
</p>

<p>
To implement this we need:
</p>

<ul class="org-ul">
<li>a feature for marking fields as sensitive. Add a sensitive default
for each primitive type, e.g. <code>****</code> for strings, <code>1234</code> for
numbers, etc.</li>
<li>a new manipulator in the shared library: <code>masd::unmask_sensitive</code>.</li>
<li>update io for fields marked as sensitive; by default output the
sensitive default unless <code>masd::unmask_sensitive</code> - in which case
output the real value.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>consider adding a warning for fields with certain names such as
"password": mark this field as sensitive?</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Consider adding a global configuration for io</b>
</p>

<p>
It would be nice to have some kind of configuration for IO that could
be accessed globally for the current process. There we could set
things such as floating point display, etc.
</p>

<p>
Actually maybe the right thing to do is to have masd specific
manipulators that you can check for in the streaming functions. We
need to read up on manipulators.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.two-sdg.demon.co.uk/curbralan/papers/WritingStreamManipulators.html">Writing your own stream manipulators</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge4c6a41" class="outline-4">
<h4 id="orge4c6a41"><span class="section-number-4">3.2.21</span> Add models for executables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-21">
<p>
We have now updated all of dogen so that everything is a model,
including the executables. However, we still haven't added high-level
concepts to generate the right targets for both executables and
libraries. We also need a template for entry point.
</p>

<p>
Interestingly, it seems that a dogen component generates multiple
components:
</p>

<ul class="org-ul">
<li>tests executable</li>
<li>library, executable</li>
<li>in a library per facet, multiple libraries</li>
</ul>

<p>
We need to take this into account when we implement this.
</p>

<p>
Merged stories:
</p>

<p>
<b>Allow generating executables from dogen</b>
</p>

<p>
At present dogen always assumes we want to generate a static
library. It would be nice to be able to generate an executable too,
with all of the cmake infrastructure generated.
</p>

<p>
This falls under the "model types" work, though perhaps its not clear
how it maps to libraries/executables. The problem is that at present,
models generate multiple targets: tests, library/executable.
</p>


<p>
<b>Previous understanding</b>
</p>

<p>
At present the executables are all hand-crafted. However, as we want
to move the options into each executable we need them to be in a
model.
</p>

<p>
When we tackle this we should take into account testability as well.
At present we have some hacks around binaries to allow us to test the
code. We manually create a static library that excludes main so that
the tests can include it. We should make this the code-generated
approach when we start generating CMake files for binaries.
</p>

<p>
This is all made much simpler if we use the Build2 approach of merging
all files into a single directory and have multiple targets per
project. However, we may need to manually add files to each target or
at least ensure there is a good way of doing this via regex. For
example, all test files can be <code>.test.cpp</code>. We can then use a regex to
exclude these from the main binary, and exclude <code>main.cpp</code> from the
tests. Or it may make sense to always create a static or shared
library for all files excluding <code>main.cpp</code> and then link against it.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>stereotype: classes annotated with <code>masd::entry_point</code> will only
have a <code>.cpp</code> and have main on it.</li>
<li>users can choose "themes"; for example masd orchestration theme
creates a main that includes orchestrator and executes it. Validator
ensures that there is such a class.</li>
</ul>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>tailor generates names with extensions so we have yarn.dia.json. We
need to drop the .dia part.</li>
<li>references have extensions on them as well. We need to drop all
extensions and then be clever and look for files ending on any of
the supported extensions. If more than one, error.</li>
<li>add meta-data for "model type": library or executable. Defaults to
library. When library, users can make use of the CMake machinery to
determine if static or shared.</li>
<li>create a model for each executable and add the options to the model;</li>
<li>add meta-data to generate an executable instead of a library in
CMake.</li>
<li>generate a main skeleton if one does not exist.</li>
<li>remove options project.</li>
</ul>
</div>
</div>

<div id="outline-container-org046552a" class="outline-4">
<h4 id="org046552a"><span class="section-number-4">3.2.22</span> Support for multiple "generation strategies"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-22">
<p>
It seems we have a requirement to support different kinds of
generation:
</p>

<ul class="org-ul">
<li>full generation: this is what we currently associate with an
<code>pbject</code>, <code>enumeration</code>, etc.</li>
<li>partial generation: this would be useful when associated with
<code>object</code> so that we could add methods. For this we can make use of
protected regions.</li>
<li>skeleton and stub generation (on-off): we use this for handcrafted
types; create the initial structure of the class, but then let the
user manually code it.</li>
<li>no generation: we don't have this at present, but in some cases we
may want to just give the user an empty file.</li>
<li>round-tripping generation: it would be great if the user could mark
a type as round-tripped and then we would automatically update the
model with any manual changes and generate new methods, stubs etc as
the user changes the model. This is conditional on having really
good clang integration. Users should be aware that when using
round-tripping problems may occur (code gets deleted etc).</li>
</ul>

<p>
What is interesting here is that we may need all of these kinds of
generation depending on the particular use case; one model may require
all code generation types. Thus this is not a property of the code
generator but of the model.
</p>

<p>
We could probably call this the "generation strategy". It could be a
property of the model element. However, given that we have multiple
facets, it seems that the generation strategy is also a function of
the facet; certain facets may only support a subset of the generation
strategies.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://link.springer.com/chapter/10.1007/978-3-319-27869-8_7">Integration of handwritten and generated object-oriented code</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Add support for "extensions"*</b>
</p>

<p>
Until we have proper merging support, one feature which would be quite
nice is to mark an element as "extensible"; that would automatically
generate hpp/cpp/cs with an appropriate prefix
(e.g. <code>TYPE_extensions</code>) so that the user can add "extension
methods". In C# this would map to real extension methods, in C++ to
just helper functions.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this could be a stereotype.</li>
<li>we could inject a type with the appropriate name, but then we need
to ensure it uses the handcrafted profile.</li>
<li>for extra bonus points: it would be nice if the extensions could be
made a class with access to private properties in the "extended"
object. This would allow us to encapsulate state.</li>
</ul>
</div>
</div>

<div id="outline-container-org23ba875" class="outline-4">
<h4 id="org23ba875"><span class="section-number-4">3.2.23</span> Additional extraction model post-processing chain transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-23">
<p>
The following transforms can be done after generation of the
extraction model:
</p>

<ul class="org-ul">
<li>clang format</li>
<li>protected regions: read the file on disk, replace contents of the
protected region with the data read from disk.</li>
</ul>

<p>
Note that we need artefacts to have an associated language so that we
can use the correct clang format configuration. If a language is not
supported by clang format (e.g. c#) we should just skip the files. The
text model could group files by language.
</p>
</div>
</div>

<div id="outline-container-org965224f" class="outline-4">
<h4 id="org965224f"><span class="section-number-4">3.2.24</span> Consider adding collections at the meta-model level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-24">
<p>
A very common pattern we've observed is the creation of "container"
classes that have a member which is a container (say
<code>std::list&lt;some_type&gt;</code>) and a set of properties associated with that
container (name, description, etc). We then expose the underlying type
to users directly. However, perhaps it would make more sense to create
a new meta-type (collection? container?) with associated meta-data; in
C++, it would translate to the creation of a class obeying C++
collection concepts such as iterators etc.
</p>

<p>
Once this is in place we get code that expresses the high-level domain
concepts but its still pluggable into the STL machinery such as
algorithms, ranges, etc.
</p>

<p>
This also addresses somewhat the annoying issue with pretty printing
of STL containers because most of the time we would have a domain type
for the STL collection. The approach is akin to C#'s idea of
inheriting from collections, except here we use composition.
</p>

<p>
This also means we can transparently change the underlying collection;
though it would force a recompile, no code should break (e.g. from
list to vector or array).
</p>

<p>
In a way this is very similar to what we already do for primitives. We
should try to unify both approaches, though of course there are
significant differences. The idea is to allow users to model a
container after an existing STL container, but exposing a domain
interface.
</p>
</div>
</div>

<div id="outline-container-org860dede" class="outline-4">
<h4 id="org860dede"><span class="section-number-4">3.2.25</span> Add support for "directory mode" in conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-25">
<p>
The real use case we have for conversion is to point it to a directory
with models and give it a destination "type" (e.g. json) and a output
directory, and then have it convert all models to that type and place
them in the output directory.
</p>

<p>
A second but related use case is to point it to a model, supply a
destination "type" and then output it into a directory, without having
to supply a destination file.
</p>

<p>
In effect, this is a common use case for all commands (generate and
weaving as well). We could probably deduce it: if the user supplied a
directory as a target, we should do it in directory mode.
</p>
</div>
</div>

<div id="outline-container-orgdbbe3e8" class="outline-4">
<h4 id="orgdbbe3e8"><span class="section-number-4">3.2.26</span> Add model sources and sinks in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-26">
<p>
At present we are reading and writing to files inside the
workflows. This means that if we want to use databases in the future
we will have to update the entire code base to cope with this. A
better approach is to perform IO via some interface, which can be
implemented to target either the filesystem or a database, cache, etc.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>add workflow that takes in a string, path, etc and creates a model
set. It will need to read references and language from the model
annotations.</li>
<li>add model source into injection</li>
<li>add model set into injection, with target and references</li>
<li>add model set into coding.</li>
<li>add a new model: coding.injection. Create a class that converts from
one model set to another.</li>
</ul>
</div>
</div>

<div id="outline-container-orgac57983" class="outline-4">
<h4 id="orgac57983"><span class="section-number-4">3.2.27</span> Generate a single type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-27">
<p>
Sometimes, when a model is in a bit of a state, it would be really
useful to be able to generate a single type (or maybe set of
types). We could easily do this by forcing the overwrite flag to false
to all artefacts other than those that belong to this set of
types. This could be a transform performed just before we generate the
extraction model: loop through all elements and those that are not
in this set, set their overwrite flags to false - or maybe even remove
them from the model?
</p>

<p>
Of course, we still need for the model to be in a state good enough to
build. We should wait for a proper use case for this feature.
</p>
</div>
</div>

<div id="outline-container-org227a1b6" class="outline-4">
<h4 id="org227a1b6"><span class="section-number-4">3.2.28</span> Add aliases to enumeration string conversions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-28">
<p>
We often need to cast a enum from a string but the name is not exactly
like the original enumeration. For example, we use enums for
stereotypes but we cannot have the same namespacing structure on the
enum. For these cases it would be nice to be able to supply an alias.
</p>

<p>
The only slight problem is that if we use this approach, the cast will
still work when you supply the simple or qualified enumeration.
</p>

<p>
Perhaps we can have two concepts:
</p>

<ul class="org-ul">
<li>alias. Everything else will still work.</li>
<li>overrides. Only the override is considered valid. Conversions will
now always use the override.</li>
</ul>
</div>
</div>

<div id="outline-container-org8df6c96" class="outline-4">
<h4 id="org8df6c96"><span class="section-number-4">3.2.29</span> Consider adding a <code>to_string</code> facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-29">
<p>
We originally added the boost lexical cast facet, but that requires
boost. The new  C++ approach seems to be to use the conversion methods
<code>to_string</code>. However, there is no equivalent "from string". We could
add it though.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/string/to_string/">to<sub>string</sub></a></li>
</ul>
</div>
</div>

<div id="outline-container-org446974c" class="outline-4">
<h4 id="org446974c"><span class="section-number-4">3.2.30</span> Consider extending lexical casts, <code>to_string</code> to any type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-30">
<p>
Perhaps it is a useful thing to dump an object into a string (via
possibly JSON). We could simply have a default behaviour of if lexical
cast is enabled for an object, dump JSON. This could possibly be
overridable - e.g. supply a parameter that determines the type of
conversion to apply. This is also useful for enums because we could
have several variations: qualified, unqualified.
</p>
</div>
</div>

<div id="outline-container-orgb2821b9" class="outline-4">
<h4 id="orgb2821b9"><span class="section-number-4">3.2.31</span> Add support for ignoring types and models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-31">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to ignore certain types I am working
on so that I can evolve my diagram over time, whilst still being able
to commit it.
</p>

</blockquote></div>

<p>
Sometimes when changing a diagram it may be useful to set some types
to "ignore", i.e. make dogen pretend they don't exist at all. For
instance one may want to introduce new types one at a time. It would
be nice to have a dynamic extension flag for ignoring.
</p>

<p>
We should probably have some kind of warning to ensure users are aware
of the types being ignored.
</p>

<p>
Isn't this just using "enable=false" for all formatters?
</p>

<p>
In a world where we can define bundles of meta-types, and import them
from system models, we could possibly just define a bundle called
<code>Ignored</code> with all formatters set to false.
</p>

<p>
This should be a stereotype to make it really visible. Also, the type
should have a colour that is easy to spot like light gray. Actually
this is ok, we can just add a profile.
</p>

<p>
This is also useful at the model level so that the model is not used
either for tests or for generation. This is more than just formatting:
its basically "act as if this type was not defined in the input" or
"this model did not exist". It should result in resolution failures if
anyone is referring to the model/type.
</p>
</div>
</div>

<div id="outline-container-orgf859284" class="outline-4">
<h4 id="orgf859284"><span class="section-number-4">3.2.32</span> Consider making fully generated files read-only&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-32">
<p>
We could add emacs/vi tags to make fully generated files read-only -
as opposed to partially generated files such as services, which are
expected to be modified by the user. Example:
</p>

<pre class="example">
/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; buffer-read-only: t -*-
</pre>


<p>
There must be a vi equivalent. There is <code>view</code> but its not clear how
to set it into a modeline. The alternative is to write the files as
read only.
</p>

<pre class="example">
/* vim: tw=60: ts=2: view=t: set ro: */
</pre>


<p>
Requires changes  to <code>.vimrc</code>:
</p>

<pre class="example">
set modeline
</pre>


<p>
It would be even better if we could make parts of a file read only, so
that only the protected regions could be written on.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/20023363/emacs-remove-region-read-only">emacs remove region read-only</a></li>
<li><a href="https://www.emacswiki.org/emacs/FoldingMode">Folding mode</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfcb832f" class="outline-4">
<h4 id="orgfcb832f"><span class="section-number-4">3.2.33</span> Pre-includes defines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-33">
<p>
For boost test, we need the ability to define a macro before any of
the includes: <code>BOOST_TEST_MODULE</code>. At present, the decorations have
both the licence and the includes, and its not possible to place
something in between the two. So we are doing the easy thing and
adding the define before the preamble. In an ideal world we should be
able to inject pre and post includes defines. These can be done by the
formatter or even by the user.
</p>

<p>
Actually the right thing to do is to have a meta-model attribute to
represent this. We should avoid words such as "includes" and "defines"
and try to model this in a more general way. For example we could
create a macro meta-element that enables users to define any
macro. This then maps to language specific constructs like C++ macros.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_69_0/libs/test/doc/html/boost_test/utf_reference/link_references/link_boost_test_module_macro.html">BOOST<sub>TEST</sub><sub>MODULE</sub></a></li>
</ul>
</div>
</div>

<div id="outline-container-orge3044f7" class="outline-4">
<h4 id="orge3044f7"><span class="section-number-4">3.2.34</span> Add support for inlining&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-34">
<p>
We should be able to set a model-wide property that tells dogen to
generate inline methods for properties. We could be more flexible and
allow inlining at class level or just for a single property. We don't
have any use cases for these at present.
</p>
</div>
</div>

<div id="outline-container-orgc54f6da" class="outline-4">
<h4 id="orgc54f6da"><span class="section-number-4">3.2.35</span> Create org-mode documentation for <code>cli</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-35">
<p>
We need a way to associate documentation with a model. The ideal
output is something like <code>dotnet</code>:
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-sln">https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-sln</a></li>
</ul>

<p>
In an org-mode world, it would be really nice if we could have the
documentation and the definition of the command line options next to
each other, in the same org-mode model.
</p>
</div>
</div>

<div id="outline-container-orga86ef03" class="outline-4">
<h4 id="orga86ef03"><span class="section-number-4">3.2.36</span> Consider generating program options code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-36">
<p>
If there was a syntax to describe boost program options, we should be
able to generate most of the code for it:
</p>

<ul class="org-ul">
<li>the code that initialises the options;</li>
<li>the domain objects that will store the options;</li>
<li>the copying of values from program options objects into domain
objects.</li>
</ul>

<p>
This would mean that creating a command line tool would be a matter of
just supplying an options file. We could then have a stereotype for
this (name to be yet identified). Marking a type with this stereotype
and supplying the appropriate meta-data so one could locate the
options file would cause dogen to emit the program options binding
code.
</p>

<p>
A similar concept seems to exist for python: <a href="http://docopt.org/">docopt</a>. We should keep
the same syntax. We just need to have a well defined domain object for
these. The aim would be to replace config.
</p>

<p>
For models such as these, the dia representation is just overhead. It
would be great if we could do it using just JSON.
</p>

<p>
Actually even better would be if we could have a text file in docopt
format and parse it and then use it to generate the code described
above.
</p>

<p>
Actually maybe we are just making this too complicated. We probably
just need some very trivial meta-data extensions that express the
required concept:
</p>

<ul class="org-ul">
<li>create a yarn element to model this new meta-class. We basically
need to model the structure of program options with option groups
and options.</li>
<li>define a stereotype for the new yarn elements, say
<code>CommandLineOptionGroup</code>.</li>
<li>for types facet we simply generate the regular c++ code. But in
addition, we also generate a new facet that: a) injects the
propertties into boost program options b) instantiates the c++
objects from boost program options.</li>
<li>this means that instead of creating a new meta-type, we need to
augment <code>yarn::object</code> with command line options stuff.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>create stereotypes for options group, options; allow users to define
members of type options in options group. Or should the options just
be member variables? In which case we could have
<code>command_line::options</code> as the stereotype.</li>
<li>generate the options classes.</li>
<li>inject a hand-crafted validator or consider generating the validator
given the meta-data supplied by the user (mandatory, at most X
times, etc).</li>
<li>generate an options builder that takes on the building
responsibilities from the parser.</li>
<li>generate a parser that hooks the builder and copies data from the
options map into the options.</li>
<li>allow users to supply the help text and the version text as
parameters; these should probably be done in a similar way to what
we do with the modeline etc.</li>
<li>allow users to set default values in the options attributes and set
them in generated code. This is probably just adding default value
support to dogen, for which we have a separate story.</li>
<li>one very useful way in which to use program options is via
projections. That is a given model M0 defines the configuration and
a second model M1 defines the options parsing. In this case the
options defined in M0 already has the required shape:
<ul class="org-ul">
<li>there is a top-level class housing all options, traditionally
called "configuration";</li>
<li>the top-level class contains meta-data with the product blurb;</li>
<li>attributes of that class can be annotated as "modes", "groups" or
nothing. A mode will result in a modal CLI interface. Groups
result in top-level groupings of options. Nothing means the
attribute must be of a simple type and will be a global option
(e.g. <code>help</code>, <code>version</code>, etc).</li>
<li>attributes have a description, etc associated as meta-data. They
also have other useful annotations such as optional, mandatory
etc. These are used in validation. Interestingly this may mean we
can also automatically generate a validator.</li>
<li>dogen generates in M1 a set of chained program option parsers
(assuming a modal interface; otherwise just one) which generate
the M0 options.</li>
<li>in M1, users define a class with attribute
<code>masd::command_line_options</code>, associated with an options class.</li>
<li>users can choose the "backend": boost program options, etc. Each
is implemented as a separate template.</li>
<li>dogen generates a parser with an associated exception
(parser<sub>validation</sub><sub>error</sub>). The exception is simply injected as a
type.</li>
</ul></li>
<li>we should have a look at the existing syntax for defining command
line options and extract the meta-model elements for them. These can
then be injected into our logical model under a suitable namespace.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/abolz/CmdLine2">CmdLine2</a>: alternative library to program options.</li>
<li><a href="https://github.com/p-ranav/argparse">argparse</a>: Argument Parser for Modern C++</li>
</ul>
</div>
</div>

<div id="outline-container-orga242d9f" class="outline-4">
<h4 id="orga242d9f"><span class="section-number-4">3.2.37</span> Code-generate a "one-shot" serialisation API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-37">
<p>
For the dia model we manually generated a class called
<code>diagram_serialization_helper</code>. It provided a simple API to read/write
the dia model:
</p>

<pre class="example">
static void to_xml(std::ostream&amp; s, const diagram&amp; d);
static diagram from_xml(std::istream&amp; s);
</pre>


<p>
It would be nice to have this code-generated and also to cover the
other two archives (text, binary).
</p>

<p>
Users should be able to mark types with some property so that we know
we need to generate these wrappers.
</p>

<p>
Another common use case is to serialise from and to string. It would
be nice to have helpers for strings too.
</p>

<p>
These APIs can then be reused by the caching layer.
</p>

<p>
We could have a stereotype that marks a class as requiring this kind
of serialisation, such as "serialisation entry point".
</p>

<p>
We should code-generate this API. They are equivalent to persisters as
well.
</p>

<p>
Merged stories:
</p>

<p>
<b>Generalise persister and remove serialisation helpers</b>
</p>

<p>
With the move of the knit persister into each model, it became obvious
that users need a way to hydrate and dehydrate certain types by just
supplying a path. The ideal setup would be where each supported
serialisation mechanism registers a number of extensions with an
hydrator / dehydrator and the user can supply a path; the path gets
dispatched to the correct serialisation. In this world we wouldn't
need the XML serialisation helper (in utilities) because we would code
generate a complete serialisation solution. This only works for files
(and not for streams) because we infer the format from the
extension. Having said that, if there was a way to supply an enum or
such-like with the stream, we could create a class for streams and
then implement the file one as an adaptor to the stream class.
</p>

<p>
<b>Persisters only support XML</b>
</p>

<p>
Persister should support all archive types. At present it always
outputs in XML; it should respect the archive type requested by the
user.
</p>

<p>
<b>Persisters should throw on invalid archive types</b>
</p>

<p>
At present we are checking to see if the archive type is invalid, and
if so ignoring it:
</p>

<pre class="example">
 if (at == archive_types::invalid)
    return; // FIXME: should we not throw?

const auto&amp; dp(create_debug_file_path(at, p));
sml::persister persister;
persister.persist(m, dp);
</pre>


<p>
We should:
</p>

<ul class="org-ul">
<li>pass the archive type into persister;</li>
<li>throw if the archive type is not supported.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb2dfdcd" class="outline-4">
<h4 id="orgb2dfdcd"><span class="section-number-4">3.2.38</span> Add visibility to coding attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-38">
<p>
We need to be able to mark yarn attributes as:
</p>

<ul class="org-ul">
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
</div>
</div>

<div id="outline-container-org958e199" class="outline-4">
<h4 id="org958e199"><span class="section-number-4">3.2.39</span> Add support for default values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-39">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to set default values for certain
built-ins so that I can model my domain more accurately.
</p>

</blockquote></div>

<p>
It would be nice to be able to add a default value in Dia and have it
set on the default constructor, if the type is a built-in or a
<code>std::string</code>.
</p>

<p>
These could be added as dynamic extensions; however, they should not
be model specific - the same defaults should apply to all
languages. However, note that in certain cases the default values may
be language specific (e.g. <code>0.0f</code> for float, etc). We should have a
language independent way to express defaults and then interpret them
in language specific ways at the template level.
</p>

<p>
Note also that there are two levels of default values: the type-level
(all built-ins of type <code>x</code> default to <code>y</code>) and the property level
(instances of type <code>x</code> in class <code>z</code> default to <code>y</code>). The meta-data can
be applied at each level to achieve the desired effect.
</p>

<p>
Defaults are also useful with const properties, both if the class is
immutable, or if just the defaulted property is immutable.
</p>

<p>
Validation rules:
</p>

<ul class="org-ul">
<li>property can only have a default value if built-in</li>
<li>property default value must be castable to built-in type.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we have now implemented support for values at the dia and injection
level (not JSON). We just need to propagate it into coding and
express it on the model to text transforms.</li>
</ul>
</div>
</div>

<div id="outline-container-org1b5eae6" class="outline-4">
<h4 id="org1b5eae6"><span class="section-number-4">3.2.40</span> Add support for interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-2-40">
<p>
It would be great to be able to mark a type as an interface, add all
methods that the interface has, and have dogen fully code-generate the
interface, marking all methods as pure virtual, override, etc. We
would want to distinguish this from the abstract base class case,
because we may want to add one or more concrete methods to the ABC.
</p>

<p>
We need support for operations for this to work. We also need support
for pointers, references and const.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add <code>interface</code> meta-model element</b>
</p>

<p>
Even though we can't generate much outside of plain types, we should
already have support for a stereotype of <code>interface</code>. In the future we
may be able to code generate the interface. This should be implemented
in coding as a type on its own right.
</p>

<ul class="org-ul">
<li>add an interface which is: element, operatable, relatable. Not
stateful. We should also have a "is abstract" flag
somewhere. Perhaps in relatable?</li>
</ul>
</div>
</div>

<div id="outline-container-org8f76fae" class="outline-4">
<h4 id="org8f76fae"><span class="section-number-4">3.2.41</span> Add support for private and protected attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-41">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like to define properties as
protected so that I only expose them to derived types.
</p>

</blockquote></div>

<p>
We need to distinguish between public and protected attributes when in
the presence of inheritance. If not, issue a warning.
</p>

<p>
Another interesting use case for protected and private attributes is
extensions. This is not yet supported by C++, but one can envision a
time where it will be possible to extend the code generated classes
with manually crafted code; these extensions may have access to
protected/private state, thus allowing for encapsulation.
</p>
</div>
</div>

<div id="outline-container-orgb08cf17" class="outline-4">
<h4 id="orgb08cf17"><span class="section-number-4">3.2.42</span> Add support for error info augmenting of exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-42">
<p>
When we declare a boost exception, we some times need to augment it
with additional data. This is explained <a href="http://www.boost.org/doc/libs/1_58_0/libs/exception/doc/tutorial_transporting_data.html">here</a>. We should be able to add
these tags to the exception class and have dogen generate the
<code>error_info</code> boilerplate in the exception header.
</p>

<p>
Note that we can have many tags associated with a given
exception. They all need to have meaningful names. They should all
have globally unique names, unless the name makes sense in the context
of more than one exception. We could make the tags a property of the
exception (e.g. inner class). Or we could simply have a global class
that declares all of the application tags in one go. If most tags are
exception specific, then the first approach is better. If many tags
are shared, the latter is preferable.
</p>

<p>
In terms of dia/frontend, we can simply add these as attributes of the
exception and have the code generator do the right thing for
C++. Other languages would/could have different implementations.
</p>

<p>
Once we implement this we need to go through all exceptions and add
all the needed attributes; in many cases we are being lazy and logging
one message but throwing a less informative one. This should really be
captured in the exception type.
</p>

<p>
We should probably support some meta-data to enable/disable this
behaviour, in case someone wants real attributes in an exception.
</p>
</div>
</div>

<div id="outline-container-org28a02a0" class="outline-4">
<h4 id="org28a02a0"><span class="section-number-4">3.2.43</span> Add support for deprecation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-2-43">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to mark certain properties, classes
or methods as deprecated so that I can tell my users to stop using
them.
</p>

</blockquote></div>

<p>
We should be able to mark classes and properties as deprecated and
have that reflected in both doxygen and C++-11 deprecated attributes.
</p>

<p>
Note that at present nothing stops the users from adding the marker
themselves.
</p>

<p>
Perhaps we should add general support for attributes. This would be
useful for languages like C# and Java, to control serialisation, etc.
</p>

<p>
We should make this approach consistent with deprecation of features
as per <a href="#org7a8edcb">this story</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org22240b5" class="outline-3">
<h3 id="org22240b5"><span class="section-number-3">3.3</span> Technical debt and refactoring</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Stories that deal with cleaning up the code base.
</p>
</div>

<div id="outline-container-org03c2472" class="outline-4">
<h4 id="org03c2472"><span class="section-number-4">3.3.1</span> Detect duplicate attributes via validator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
At present if we add two attributes with the same name, we get a weird
exception in the guts of the logical model:
</p>

<pre class="example">
2020-10-01 11:25:07.331325 [TRACE] [logical.helpers.configuration_model_set_adapter] Extracting: tests_directory_name (dogen.physical.entities.project_path_properties.tests_directory_name)
2020-10-01 11:25:07.331328 [TRACE] [logical.helpers.configuration_model_set_adapter] Extracting: tests_directory_name (dogen.physical.entities.project_path_properties.tests_directory_name)
2020-10-01 11:25:07.331331 [ERROR] [logical.helpers.configuration_model_set_adapter] Duplicate qualified name for configuration: dogen.physical.entities.project_path_properties.tests_directory_name
</pre>


<p>
It would be more user friendly if we had a validator, probably even at
the codec level, that throws if there are attributes with duplicate
names.
</p>
</div>
</div>

<div id="outline-container-orge966161" class="outline-4">
<h4 id="orge966161"><span class="section-number-4">3.3.2</span> Use GCC to code generate tests in nightly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
At present we seem to be using the clang binary to code generate the
code for the gcc build (somehow). This means that if clang fails, GCC
will behave strangely (loss of all generated tests, massive drop in
code coverage). We should use GCC for GCC code generation.
</p>
</div>
</div>

<div id="outline-container-orga6de62a" class="outline-4">
<h4 id="orga6de62a"><span class="section-number-4">3.3.3</span> Do not throw when getting attribute value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
At present in <code>processed_object_factory</code> we are getting the attribute
value like so:
</p>

<pre class="example">
template&lt;typename AttributeValue, typename Variant&gt;
boost::optional&lt;AttributeValue&gt; try_get_attribute_value(const Variant&amp; v) {
    AttributeValue r;
    // FIXME: we should probably replace this with a static visitor.
    try {
        r = boost::get&lt;AttributeValue&gt;(v);
    } catch (const boost::bad_get&amp;) {
        return boost::optional&lt;AttributeValue&gt;();
    }
    return r;
}
</pre>


<p>
This is really not ideal and means we can't just do a
</p>

<pre class="example">
catch throw
</pre>


<p>
in gdb when looking for "unexpected exceptions". In general, a <code>catch
throw</code> should only show real problems and not "expected"
circumstances. We need to clean up this code and any other that shows
up when using this command.
</p>
</div>
</div>

<div id="outline-container-org2d40163" class="outline-4">
<h4 id="org2d40163"><span class="section-number-4">3.3.4</span> Resolution needs to segment names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
At present we are resolving any name in modeling space, regardless of
modeling element type. This is not correct. For example:
</p>

<ul class="org-ul">
<li>PIM models should not refer to non-PIM types.</li>
<li>features should only refer to types in the <code>masd.variability</code> model.</li>
<li>archetypes should be able to only refer to logic-less templates.</li>
</ul>

<p>
In addition:
</p>

<ul class="org-ul">
<li>resolution of licences, modeline groups etc is probably using some
bespoke logic or suffers from exactly the same problems.</li>
</ul>

<p>
What we really need is to group "referrable names" by meta-model type
(or groups of meta-model types, more accurately) and then resolve only
using types in those groups. This should only be done after we
simplified name resolution by moving to the <a href="#org5a113c4">list-based approach</a>.
</p>

<p>
Merged stories:
</p>

<p>
<b>LAM name resolution should be PIM only</b>
</p>

<p>
With the current approach, we are not resolving any names until after
we've mapped LAM models into a PSM. This possibly means that users can
provide a model with non-LAM types. Ideally we should not allow
this. Check to see if we are validating this in the present mapping
code.
</p>
</div>
</div>
<div id="outline-container-org5a113c4" class="outline-4">
<h4 id="org5a113c4"><span class="section-number-4">3.3.5</span> Rewrite name resolution in terms of lists&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
Even since we did the external modules / model modules change we broke
code generation; this is because we do not go up the model modules
during name resolution. We did a quick hack to fix this but it needs
to be done properly.
</p>

<p>
Let's walk through a simple example:. Name cames in as:
</p>

<ul class="org-ul">
<li>model module: <code>probing</code></li>
<li>simple: <code>prober</code></li>
</ul>

<p>
We are in model:
</p>

<ul class="org-ul">
<li>model module: <code>dogen.external</code></li>
</ul>

<p>
Expected behaviour is to try all combinations of model modules:
</p>

<ul class="org-ul">
<li><code>dogen.external.probing</code></li>
<li>=dogen.probing</li>
<li><code>probing</code></li>
</ul>

<p>
This highlights a fundamental problem with resolution: we view the
{external, model, internal} modules as if they are separate entities
but in reality, for the purposes of resolution, there is only one
thing that is relevant: the module path. If it matches because of
{external, model, internal} modules, well that is not relevant to
resolution. Other users of <code>name</code> do need to know this information
(for example to generate directories or file names) but not the
resolver.
</p>

<p>
Interestingly, because we are only looking for an id, it doesn't
really matter how we get to it (in terms of the internal composition
of the name), as long as it matches bitwise. This means we can look at
the process slightly differently:
</p>

<ul class="org-ul">
<li>start off with the name as the user provided it. Extract all strings
from it to create a list, in order: external, model, internal,
simple. Try to resolve that. Call it user list.</li>
<li>then create a second list from model / context: external, model,
internal. Call it model list.</li>
<li>try concantenating model list and user list, pretty printing and
resolving it. If it fails, pop model list and concatenate again. Try
until model list is empty.</li>
</ul>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>first add a quick hack just to get the code generator working
again. For example, take the first model module of the model and try
resolving with that. Then worry about fixing this properly. This has
been done with a big hack.</li>
<li>split the conversion of name into list from pretty printer. Printer
should merely take a string or list of strings and do its thing. We
need to find a good location for this method, since (for now) we
cannot place it in the right location which is the name class
itself.</li>
<li>change resolver to obtain the lists as per above. The to list
machinery can be used for this, though we need to handle model names
somehow. We can copy the <code>model_name_mode</code> logic from printer.</li>
<li>drop all of the logic in resolver at present and use the list logic
as per above. Do not check references, etc.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>there are a few useful functions here:
<ul class="org-ul">
<li>subtraction: given a base list, subtract another list. Fro
example, given <code>masd::dogen::annotations::annotation</code>, subtract
<code>masd::dogen::annotations</code>. This is useful when determining the
right qualification inside a class.</li>
<li>addition: concatenate a list with another.</li>
<li>combination: given a base list, create all possible permutations
for a second list. For example: <code>masd::dogen::annotations</code> and
<code>some::type</code>, we want <code>masd::dogen::annotations::some::type</code>,
<code>masd::dogen::some::type</code>, <code>masd::some::type</code>, <code>some::type</code>. We
are iterating upwards the first list.</li>
<li>make id: given a list, generate an ID. This was we don't even need
to go though the whole "name building" exercise, we simply go from
lists into ID's and check the containers.</li>
</ul></li>
<li>we probably should introduce a type for this: <code>flat_location</code>?
something that can be converted from a <code>location</code> (but not the
opposite) and has the properties defined above. Or we could have a
"location flattener" that performs these actions, but this is less
clean as we now need a few of these helpers.</li>
<li>there are two fundamental concepts: a path (which is what we call a
location) and an address (which is what we call an ID). Path implies
an hierarchical space, which is what modeling and generation space
are. Address is flat and unique. There is a function to go from
paths to addresses but not vice-versa. Given two paths we can
generate all possible addresses by performing a "climb" in the
hierarchical space.</li>
<li>we could make addresses URIs, and preserve almost all of the
information: <code>masd://some.model.name/a/b.c</code>. The problem is we
cannot tell the difference between model modules and external
modules. However, we could simplify this and say model modules and
external modules are all the same thing; users can choose to express
external modules as part of the file name or not. (e.g. "express
full path" or some such flag). We can also choose to express
external modules as directories or as a dotted path. URIs may not be
the best of ideas because models exist in contexts (workspaces,
servers, users) rather than in one universal space. However, we
could use URLs as a way to identify resources once we clear up the
REST story.</li>
<li>another very interesting point is that the separation of parsing and
resolution may not be a great idea. At present we parse "unparsed
types" in attributes and create "proto-names"; these have guesses as
to what the different components should be (model module,
etc). However, a slightly different way to look at this is, we could
just create the lists off of the parsing and then send them to the
resolver; the resolver would either resolve them into a name or
fail. There would be no need to have this in-between state of
half-filled names. However, if we do want to separate parsing from
resolution, perhaps the right solution is to create a parallel
structure to the name tree which is made up of nested lists. The
parser populates these and the resolver uses them to create the name
trees. Even better: we can move all of this work into injection. The
parsing into lists can happen in injection and then we just need to
map these into model types in coding (resolution). The creation of
the name tree structure is resolution.</li>
<li>if we do go for the lists approach, perhaps we should also have two
types of name trees: a list based name tree (call these parsed
types) and a names based name tree (resolved types?). List trees are
not really name trees I guess, but they are in the right format for
the resolver to use. This would mean the parser could be simplified,
and the whole "lets guess what this scope is" could be removed. The
job of the parser is just to produce these lists. The resovler then
resolves them into actual names. If we go for this approach, this
should be part of injection: we'd have "value trees" in injection
and "name trees" in assets. Resolution is in effect the conversion
of these two tree types. However, the only slight problem is that,
at present, resolution is done in the middle of the assets pipeline,
after merging. For this to work, we'd need to, somehow, move it to
the injection to assets adaption phase. This is not entirely
inconceivable: we already have all elements with their correct names
at this stage. If we could view the entirety of the model set rather
than just the model when resolving, it would work. In other words,
if we built a single map with all of the element IDs across the
model set and used it to resolve, according to a well-defined set of
rules, it should work. However, the set of rules themselves would
involve some processing: we need to know about module containment
(external, model module and internal). Nonetheless, this is probably
already available at this stage - i.e. the owning element should
have this information as part of the adaption process. And in truth,
this is the only thing we should be using in resolution. That is,
the original lists as obtained from injection, plus the owning name;
we then perform a traversal/climb using the well-defined rules
above, and for each point in the climb, do a look-up in the map. If
found, use the name pointed to by the element. If not found, keep
climbing. The only slight problem we now have is we created a
circular dependency: in order to perform resolution we need access
to all the names in the model set, but these are only generated as
part of the adaption of the injection model to the asset model. We
need to somehow have a two pass approach: first build all the names,
then adapt the elements. This could be done in engine, as part of
the injection to assets chain.</li>
</ul>
</div>
</div>

<div id="outline-container-org0406ea9" class="outline-4">
<h4 id="org0406ea9"><span class="section-number-4">3.3.6</span> Create tests for variability overrides&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-6">
<p>
We've added all the functionality needed to override meta-data, but we
did not update any of the test models to exercise all of its
permutations: update model, element, attribute.
</p>
</div>
</div>

<div id="outline-container-org9bc658c" class="outline-4">
<h4 id="org9bc658c"><span class="section-number-4">3.3.7</span> Simplify implementation of boost serialisation registrar&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-7">
<p>
at present we are using templates on the cpp file, and it is not clear
if the hackery we did is not causing problems. We seem to have trouble
with some of the tests on windows which appear to be related to
registration problems. This could be because of the weird and
wonderful C++ rules around how the linker removes unused code and
templates, etc across different compilers. If possible, we should have
a really simple implementation for each archive type, that is
guaranteed to work on any compiler and any c++ version. Or we could
just create a simple header file for this (see <a href="https://www.boost.org/doc/libs/1_70_0/libs/serialization/doc/serialization.html#registration">registration</a>). In
addition, it seems we now have a new way of exporting classes which is
very simple: <a href="https://www.boost.org/doc/libs/1_70_0/libs/serialization/doc/serialization.html#export">Export</a>. We need to see when this was made available in
boost though.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need to check that we are calling register types for all
references. It seems that, at present, we assume it will be
present. We should check to see that the registrar type exists on
the referenced model first.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfa4c9b1" class="outline-4">
<h4 id="orgfa4c9b1"><span class="section-number-4">3.3.8</span> Merging of profiles and configurations is non-intuitive&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-8">
<p>
As per comments in profile binding:
</p>

<div class="epigraph"><blockquote>
<p>
Finally, merge against the configuration. This must be done in order:
first the accumulating<sub>profile</sub>, the base layer. This ordering is
<b>highly</b> non-intuitive. It derives from the fact that, on a merge, lhs
takes precedence over rhs. If we merge the base layer first, as it is
logical, this would mean that the "overrides" would fail to override
for all of the features that the base layer has already set. Clearly
base layer is not a good name here; its more of a "default feature
configuration" or something of the sort.
</p>

</blockquote></div>
</div>
</div>

<div id="outline-container-org30c4e2f" class="outline-4">
<h4 id="org30c4e2f"><span class="section-number-4">3.3.9</span> Handling of forward declarations on generated types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-9">
<p>
At present, if we disable forward declarations globally (in a profile,
say), the code fails to build with errors on visitors. This is because
we need forward declarations for:
</p>

<ul class="org-ul">
<li>the visitable type;</li>
<li>all of its descendants;</li>
<li>the visitor.</li>
</ul>

<p>
This is a hard requirement because, without these the code does not
make sense. We need some way of "forcing" enablement for some features
where there is such a hard dependency. This is probably something we
need to look at when we implement "computable enablement". We then
need some way of telling the system about these dependencies:
e.g. visitor requires enablement x, y, z. This should done in archetypes
by declaring facet depencies.
</p>

<p>
A second problem is that, at present, there is no way to manually
enable (force) forward declarations on visitors. We can enable them on
all model elements but not on the generated type. Because of this we
are generating forward declarations for all types, for no reason.
</p>

<p>
The more general problem here is the declaration of dependency between
formatters and the ability to take these into account when resolving
enablement.
</p>
</div>
</div>

<div id="outline-container-org3a14725" class="outline-4">
<h4 id="org3a14725"><span class="section-number-4">3.3.10</span> Add "is abstract" to assets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-10">
<p>
With C# we have started deciding if a class is abstract or not on the
basis of whether its a parent, etc. The right thing to do is to have a
"is abstract" property which is populated on the guts of assets (using
the current logic of parents are abstract).
</p>

<p>
We then need to review the C++ templates and figure out where we were
also inferring "abstractness", and use the new flag.
</p>

<p>
Actually we already have an is abstract flag, we just need to check
its been used correctly across all kernels.
</p>
</div>
</div>

<div id="outline-container-org96a5a52" class="outline-4">
<h4 id="org96a5a52"><span class="section-number-4">3.3.11</span> Implement CLI configuration validator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-11">
<p>
At present we are not performing any validation on the new
configuration classes we created in the API model.
</p>
</div>
</div>

<div id="outline-container-org2ee9e1e" class="outline-4">
<h4 id="org2ee9e1e"><span class="section-number-4">3.3.12</span> Create a theme for element colours based on an algorithm&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-12">
<p>
It would be nice if we could automatically determine the colours for
new modeling elements. This could be done by choosing some kind of
base colour for each group and then incrementing by a colour step for
each element. This can easily be done in the python script. The
question is whether the result would look sensible. This needs some
experimentation. We also need to make sure that the colour step
results in colours that are distinct enough so that we can recognise
the elements. We also need to make sure the elements are readable.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/214359/converting-hex-color-to-rgb-and-vice-versa">Converting hex color to RGB and vice-versa</a></li>
<li><a href="https://stackoverflow.com/questions/43001349/convert-numpy-array-of-rgb-values-to-hex-using-format-operator">Convert numpy array of RGB values to hex using format operator %</a></li>
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Colors.html">emacs: Colors for Faces</a>: list RGB colours in emacs.</li>
</ul>
</div>
</div>

<div id="outline-container-org760cc8b" class="outline-4">
<h4 id="org760cc8b"><span class="section-number-4">3.3.13</span> Improve error messages for mistakes in meta-data enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-13">
<p>
At present when one makes a mistake in meta data the errors are not
particularly enlightening:
</p>

<pre class="example">
FAILED: projects/dogen.models/dia/CMakeFiles/generate_dogen.engine.dia
cd /work/DomainDrivenConsulting/masd/dogen/integration/build/output/clang9/Release &amp;&amp; /work/DomainDrivenConsulting/masd/dogen/integration/build/output/clang9/Release/stage/bin/dogen.cli generate --target /work/DomainDrivenConsulting/masd/dogen/integration/projects/dogen.models/dia/dogen.engine.dia --output-directory /work/DomainDrivenConsulting/masd/dogen/integration/projects/
Error: bad lexical cast: source type value could not be interpreted as target
</pre>


<p>
This was caused because we put in an invalid binding point:
</p>

<pre class="example">
#DOGEN masd.variability.default_binding_point=entity
</pre>


<p>
We should trap the lexical cast exception and provide a proper error
given the context. We could also calculate the levenshtein distance
against the existing enums when the errors.
</p>
</div>
</div>

<div id="outline-container-org4b100e1" class="outline-4">
<h4 id="org4b100e1"><span class="section-number-4">3.3.14</span> Tracing backend is not defaulted&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reviewing">reviewing</span>&#xa0;<span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-14">
<p>
Not supplying a tracing backend results in the following error:
</p>

<pre class="example">
FAILED: projects/dogen.models/dia/CMakeFiles/generate_dogen.dia
cd /work/DomainDrivenConsulting/masd/dogen/integration/build/output/clang9/Release &amp;&amp; /work/DomainDrivenConsulting/masd/dogen/integration/build/output/clang9/Release/stage/bin/dogen.cli generate --target /work/DomainDrivenConsulting/masd/dogen/integration/projects/dogen.models/dia/dogen.dia --log-enabled --log-level trace --tracing-enabled --tracing-level detail --tracing-guids-enabled --reporting-enabled --reporting-style org-mode --output-directory /work/DomainDrivenConsulting/masd/dogen/integration/projects/
Error: Tracing backend is unsupported: { "__type__": "tracing_backend", "value": "invalid" }
</pre>


<p>
We need to add a sensible default value.
</p>
</div>
</div>

<div id="outline-container-org428b420" class="outline-4">
<h4 id="org428b420"><span class="section-number-4">3.3.15</span> Naming of DLL entry point does not follow existing convention&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-15">
<p>
With the introduction of <code>entry_point</code>, users can now declare an
entity representing the component's entry point. It is projected to
the different facets:
</p>

<ul class="org-ul">
<li>for types, it should mean <code>main.cpp</code> for executables and
<code>dllmain.cpp</code> for shared objects.</li>
<li>for tests it should mean <code>main.cpp</code>.</li>
</ul>

<p>
At present we do not have a way to define a "prefix" for a
formatter. Thus it is not possible to generate a file called
<code>dllmain.cpp</code>. We need to investigate the naming conventions for these
files.
</p>
</div>
</div>

<div id="outline-container-orgc6fed32" class="outline-4">
<h4 id="orgc6fed32"><span class="section-number-4">3.3.16</span> Boost test module is named after the entity&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-16">
<p>
At present we have:
</p>

<pre class="example">
#define BOOST_TEST_MODULE cpp_ref_impl::boost_model::entry_point
</pre>


<p>
In reality, the test module name should be more something reflective
of the model itself, such as cpp<sub>ref</sub><sub>impl</sub>::boost<sub>model</sub>::tests.
</p>
</div>
</div>

<div id="outline-container-org2e225c1" class="outline-4">
<h4 id="org2e225c1"><span class="section-number-4">3.3.17</span> Use profile overrides reduce the number of test models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-17">
<p>
At present we have a number of test models in C++ reference
implementation that are variations on the same theme: testing the
enablement of a single facet. This could easily be achieved with a
single model by using the new profile override machinery that was
developed for nightlies.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need to somehow also override the model modules.</li>
<li>we could create separate CMake targets for these special cases.</li>
<li>this may also apply to cases such as delete extra, etc. We need to
do an inventory of all models that have exactly the same composition
but different configurations.</li>
</ul>
</div>
</div>

<div id="outline-container-org85a530f" class="outline-4">
<h4 id="org85a530f"><span class="section-number-4">3.3.18</span> Improve error message for missing files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-18">
<p>
At present when we are expecting a file but the file is missing, the
tests state:
</p>

<pre class="example">
Unexpected file (remove): CSharpRefImpl.CSharpModel/SequenceGenerators/AssistantSequenceGenerator.cs
Unexpected file (remove): CSharpRefImpl.CSharpModel/Dumpers/AssistantDumper.cs
</pre>


<p>
We should really say "Expected file". Think a bit more about the right
wording for these messages.
</p>
</div>
</div>

<div id="outline-container-orgb8e4122" class="outline-4">
<h4 id="orgb8e4122"><span class="section-number-4">3.3.19</span> Add "structural" to structural stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-19">
<p>
At present all masd stereotypes are namespaced correctly, according to
the matching meta-model elements, except for the structural ones. That
is, we do <code>masd::entry_point</code> instead of
<code>masd::structural::entry_point</code> etc.
</p>
</div>
</div>

<div id="outline-container-orge0acbb6" class="outline-4">
<h4 id="orge0acbb6"><span class="section-number-4">3.3.20</span> Mop-up nested namespaces using legacy syntax&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-20">
<p>
It seems we still have a number of places in the templates where we
are using the legacy nested namespaces. Its probably only in
serialisation, given that's the only place where we've hard-coded the
namespaces and they are more than one level deep (we have a lot of
<code>std</code> but that's not affected):
</p>

<pre class="example">
namespace boost {
namespace serialization {
</pre>


<p>
We need to wrap these in if's for C++ 17 and add nested namespaces.
</p>
</div>
</div>

<div id="outline-container-orgd078179" class="outline-4">
<h4 id="orgd078179"><span class="section-number-4">3.3.21</span> Tidy-up profile names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-21">
<p>
At present we have two types of profiles:
</p>

<ul class="org-ul">
<li>the "enable just one facet" profiles such as typeable, etc. These
are meant to allow for composition: e.g., <code>dogen::typeable,
  dogen::pretty_printable</code>. in order to allow composition, the type is
based on profile "disable all facets".</li>
<li>the "handcraft this type" profiles such as <code>handcrafted_typeable</code>,
<code>handcrafted_pretty_printable</code> etc. These are also meant for
composition. Again, their base type is using "disable all facets".</li>
</ul>

<p>
There are several problems:
</p>

<ul class="org-ul">
<li>the names aren't great. Unless you know Dogen you don't know what
most of these profile names mean.</li>
<li>We now have a third use case: enable types without disabling all
other facets. This is needed because we want the entry point in CLI
to work for tests with profile overrides. For now we need to do this
manually.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbd0215d" class="outline-4">
<h4 id="orgbd0215d"><span class="section-number-4">3.3.22</span> Add inheritance via meta-data to profiles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-22">
<p>
For objects we can use meta-data to declare inheritance relationships:
</p>

<pre class="example">
#DOGEN masd.generalization.parent=assets::meta_model::element
</pre>


<p>
However, this is not honoured for other element types. We should
extend this to any case where there is inheritance. At present these
are:
</p>

<ul class="org-ul">
<li>object templates;</li>
<li>profiles.</li>
</ul>

<p>
Interestingly we seem to support a different kind of "inheritance" via
 <code>masd.variability.profile</code>, e.g.:
</p>

<pre class="example">
masd.variability.profile = dogen.profiles.base.disable_all_facets
</pre>
</div>
</div>
<div id="outline-container-orgee4d43c" class="outline-4">
<h4 id="orgee4d43c"><span class="section-number-4">3.3.23</span> Consider renaming <code>origin_types</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-23">
<p>
We created an enumeration called <code>origin_types</code> to distinguish between
models of different types:
</p>

<ul class="org-ul">
<li>target model</li>
<li>reference model:
<ul class="org-ul">
<li>proxy reference: a PDM really.</li>
<li>non-proxy reference: a regular dogen model we reference.</li>
</ul></li>
</ul>

<p>
However, this is not really the model's "origin". It is more like "the
model's purpose in this context". We need to think more about the
meaning of this enumeration.
</p>
</div>
</div>

<div id="outline-container-org673474e" class="outline-4">
<h4 id="org673474e"><span class="section-number-4">3.3.24</span> Consider merging all "registrar-like" entities&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-24">
<p>
At present we have a registrar in C++ generation model which is used
to generate the code to register types for boost serialisation. This
principle is fairly universal, and probably all serialisation
technologies will require something of this kind in presence of
inheritance. In addition to this, we have the related notion of
"initialisers". These are used to register types such as:
</p>

<ul class="org-ul">
<li>formatters</li>
<li>feature templates</li>
</ul>

<p>
The notion here is that we need to know of a set of related
types. Whilst registration happens at run time, in reality all is
known at compile time and we generate all of the required code up
front. If we attempt to generalise this idea, it seems we have:
</p>

<ul class="org-ul">
<li>a set of types that need to be registered, according to some
condition. Examples: the meta-type (feature template, etc), the fact
that the type is a base class/derived class, etc.</li>
<li>a class responsible for registration.</li>
<li>a container of some kind that remembers what was registered. The
type of the data stored is a parameter. It could be that we want
pointers to an interface (e.g. formatters) or just remember some
strings.</li>
<li>a set of initialisers that talk to the registrar to register the</li>
<li>there is a top-level class that creates the repository and then
passes it through to the initialisers to get it populated. Further
transforms may then be made to the repository.</li>
</ul>

<p>
We should look into registrar terminology to see if all of these
actors have names.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the construction of the type may be non-trivial. We may need to
supply some arguments, etc. We need to catalogue all of the
initialisers and see the comonalities.</li>
<li>bundle initialisers introduced the notion of "scope" whereby an
initialiser will look for types in the same package and worry only
about those. Then, a higher level initialiser would call all of the
lower level initialisers.</li>
<li>we need to somehow create different initialisers per type or else
these are going to become too complicated.</li>
<li>the problem of the serialisation registrar is that, instead of using
actual data stored in a repository, it works at the template
level/compule time, with each type being registered against an
archive. We need to look into the boost serialisation documentation
and see if there is a way to make the code look a bit more like the
other instances of this pattern.</li>
</ul>
</div>
</div>

<div id="outline-container-org1d4e613" class="outline-4">
<h4 id="org1d4e613"><span class="section-number-4">3.3.25</span> Code generation of registrars for static registration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-25">
<p>
We are using a lot of static registration and we have converged into
what appears to be a useful pattern. It would be nice to be able to
mark a type as registrable and to have the registrar automatically
generated for it, with a name configurable via dynamic extensions. We
would also need to configure the registration method (name,
arguments - we may want to register against a string or just have a
list of registered types).
</p>

<p>
The next logical step would be to code-generate the static
initialisers too. For this we would have to be aware of all types to
register in a given model (perhaps by looking at inheritance across
models) and for each of these generate the appropriate initialiser
code. This is more tricky but it would be really useful. Actually
given the templatisation of formatters, this is not useful any longer.
</p>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>create a registrar type in yarn and associated stereotype.</li>
<li>add keys to link types to a yarn type. This should be generic so
that we can use it for other model elements. We could either do it
the hard (static) way where we manually list the types, or in a more
dynamic way by providing a base class and letting yarn determine all
of the descendants.</li>
<li>add formatter interfaces and a stitch template for registrar.</li>
</ul>

<p>
Note: the sample principles probably apply for code generating the
container.
</p>
</div>
</div>

<div id="outline-container-orgd7298ac" class="outline-4">
<h4 id="orgd7298ac"><span class="section-number-4">3.3.26</span> Update the MASD UML profile to reflect the latest changes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-26">
<p>
The UML profile is now a fair bit out of date. Take advantage of the
down time waiting for builds to sync it.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add <code>structural</code> namespace to core elements</b>
</p>

<p>
We've created a namespace inside the coding meta-model for the core
entities but we did not update the MASD profile.
</p>

<p>
Actually structural is not a very good name - all of the meta-model
elements are structural elements, really. We need to find a good name
before we update the stereotypes.
</p>

<p>
We should update the MASD profile only after we have moved all
entities into the assets meta-model and finished refactoring
generation.
</p>
</div>
</div>

<div id="outline-container-org5e657d7" class="outline-4">
<h4 id="org5e657d7"><span class="section-number-4">3.3.27</span> Update all exception names to match framework guiidelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-27">
<p>
Exceptions should end with "exception".
</p>
</div>
</div>

<div id="outline-container-org035a724" class="outline-4">
<h4 id="org035a724"><span class="section-number-4">3.3.28</span> Fix pictures in old release notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-28">
<p>
Many of the pictures we used in the past were in panoramio. These are
now gone. We need to replace them with other pictures.
</p>
</div>
</div>

<div id="outline-container-org24eb537" class="outline-4">
<h4 id="org24eb537"><span class="section-number-4">3.3.29</span> Current implementation of vcxproj has many problems&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-29">
<p>
Problems:
</p>

<ul class="org-ul">
<li>bug: startup project is hard-coded in both c++ and c#:</li>
</ul>

<pre class="example">
StartupItem = CppModel.vcxroj
StartupItem = CSharpModel.csproj
</pre>


<ul class="org-ul">
<li>we should create separate groups for ODB files, etc.</li>
<li>its not possible to supply versions (VS version, tools version,
etc).</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Teivaz/vcxproj-generator/blob/master/generate_vcxproj.py%0A">vcxproj-generator</a></li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/itemgroup-element-msbuild?view=vs-2019">ItemGroup element (MSBuild)</a></li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/item-element-msbuild?view=vs-2019">Item element (MSBuild)</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/reference/vcxproj-file-structure?view=vs-2019">.vcxproj and .props file structure</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/reference/project-files?view=msvc-160">Project Files Example</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Generate visual studio c++ projects</b>
</p>

<p>
No <code>vcxproj</code> for c++ and no way to add code-generated files. Ideally one
should be able to include a code-generated file into project with list
of items.
</p>
</div>
</div>

<div id="outline-container-org5574698" class="outline-4">
<h4 id="org5574698"><span class="section-number-4">3.3.30</span> Create a meta-model mapping type for ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-30">
<p>
At present we are hacking the mapping of types in ODB by adding them
next to the class using it. Ideally we should create a separate header
file with all the mappings in a model and include it as required. The
inclusion logic probably requires a fair bit of cleverness (.e.g is
type in map?).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>create a modeling element called <code>orm::type_map</code>. It has entries
with the fields of an ODB type map:
<ul class="org-ul">
<li>database: optional</li>
<li>source type</li>
<li>destination type</li>
<li>to: optional</li>
<li>from: optional</li>
</ul></li>
<li>we can use the attributes to represent entries, and name for source
type and value for destination type. The rest is supplied as
meta-data.</li>
<li>the name of the element will give raise to the name of the
file. There can be more than one map per model.</li>
<li>for each type with type overrides, check to see if the type name is
in any of the maps. If so, add an include. At the meta-model level
this can be captured as a dependency.</li>
<li>we should add a database of "any" or "all" - this would allow us to
add references that are not specific to a database engine.</li>
<li>we should obtain a list of the core types in ODB and check if a type
is n the list. If not, we should tell the user a type map needs to
be created.</li>
</ul>

<pre class="example">
#pragma db map sqlite:type("JSON_TEXT") as("TEXT") to("json((?))")
#pragma db map pgsql:type("JSONB") as("TEXT") to("to_jsonb((?)::jsonb)") from("from_jsonb((?))")
</pre>
</div>
</div>

<div id="outline-container-org02d37e4" class="outline-4">
<h4 id="org02d37e4"><span class="section-number-4">3.3.31</span> Improve handling of stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-31">
<p>
At present we can add any string as a stereotype. If anyone binds to
that string, we will do "something" if no one binds, we will do
"nothing". This is not ideal:
</p>

<ul class="org-ul">
<li>its not easy to tell what stereotypes are available and what they
do.</li>
<li>if a user is expecting some functionality to come out based on a
stereotype, they won't know why it didn't.</li>
<li>more than one consumer may exist for a single stereotype - e.g. a
stereotype may have more than one meaning by mistake.</li>
</ul>

<p>
Ideally we should have:
</p>

<ul class="org-ul">
<li>a central registry of stereotypes with associated descriptions and
modeled by a meta-model concept of a stereotype.</li>
<li>a validation check that all stereotypes match registered stereotypes
and a fatal error if not (perhaps overridable?)</li>
<li>a command-line parameter to dump available stereotypes and their
descriptions so that users know whats available.</li>
<li>a check that a stereotype has not yet been registered so only one
consumer can bind to it.</li>
</ul>
</div>
</div>

<div id="outline-container-orga8a3768" class="outline-4">
<h4 id="orga8a3768"><span class="section-number-4">3.3.32</span> Single reporting format option&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-32">
<p>
At present we have different options for report format for each
format. It makes more sense to have a single option, so that for
example we use org-mode for tracing and reporting. Note also that the
byproducts dir does not have <code>cli</code>.
</p>
</div>
</div>

<div id="outline-container-orgd978172" class="outline-4">
<h4 id="orgd978172"><span class="section-number-4">3.3.33</span> Clean up injection element properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-33">
<p>
When PDMs were deemed a hack, we did a number of quick hacks to
provide missing information directly in the JSON:
</p>

<ul class="org-ul">
<li><code>can_be_primitive_underlier</code></li>
<li><code>in_global_module</code></li>
<li><code>can_be_enumeration_underlier</code></li>
<li><code>is_default_enumeration_type</code></li>
<li><code>is_associative_container</code></li>
</ul>

<p>
And maybe more. These were added as attributes of the JSON and placed
directly in the injection element. This means its not possible to set
them from Dia. The right solution for this is as follows:
</p>

<ul class="org-ul">
<li>add a transform in injection that reads these properties and sets
them in the element. This is now possible because we have proper
annotation support.
<ul class="org-ul">
<li>move the attributes to meta-data on all JSON models.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf57320d" class="outline-4">
<h4 id="orgf57320d"><span class="section-number-4">3.3.34</span> Multiple entries of the same key is invalid in JSON&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-34">
<p>
The gist of it is that we have invalid JSON at present on our JSON
models:
</p>

<pre class="example">
"masd.injection.reference": "cpp.builtins",
"masd.injection.reference": "cpp.std",
"masd.injection.reference": "cpp.boost",
"masd.injection.reference": "masd",
"masd.extraction.ignore_files_matching_regex": ".*/CMakeLists.txt",
"masd.extraction.ignore_files_matching_regex": ".*/test/.*",
"masd.extraction.ignore_files_matching_regex": ".*/tests/.*",
"masd.extraction.delete_extra_files": "true",
"masd.extraction.delete_empty_directories": "true",
</pre>


<p>
The duplicate keys in an object are not valid, which means that they
are filtered out when we indent. A quick fix for this is to allow
users to supply arrays in JSON but then internally map them back to
flat key value pairs. This should be really easy to do. We should also
at some point add some validation to stop users from adding silly
things such as objects as values, etc.
</p>

<p>
One interesting caveat is conversion from dia to JSON. If the keys on
the Dia model are not all together, the converter needs to be clever
enough to locate all keys with the same name and group them into the
same container, else we will end up having exactly the same
problem. However, we should try to preserve the order of the keys as
much as possible because this makes troubleshooting much easier.
</p>

<p>
Merged stories:
</p>

<p>
<b>Support containers correctly in annotations</b>
</p>

<p>
At present we are allowing users to enter the same key multiple times
to represent a container:
</p>

<pre class="example">
#DOGEN yarn.output_language=cpp
#DOGEN yarn.output_language=csharp
</pre>



<p>
This was an acceptable pattern from a Dia perspective, because we had
control of the KVP semantics. However, when we copied the pattern
across to the JSON representation things did not work out so
well. This is because the following JSON:
</p>

<pre class="example">
"yarn.output_language": "csharp",
"yarn.output_language": "cpp",
</pre>


<p>
Is interpreted by a lot of JSON parsers as a duplicate, and results on
only a single KVP making it. We could try to solve a lot of problems
in one go and standardise all of the meta-data on JSON:
</p>

<ul class="org-ul">
<li>use start and end markers to enclose the JSON when in dia. Story:
<a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#consider-adding-a-start-and-end-dogen-variable-block-in-dia">Consider adding a start and end dogen variable block in dia</a></li>
<li>this would also solve the problem with pairs (or at least part of
it). Story: <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_99.org#add-a-new-annotation-type-of-pair">Add a new annotation type of pair</a></li>
<li>we could allow users to keep the JSON externally. Story: <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_99.org#add-support-for-one-off-profiles">Add support
for one off profiles</a></li>
<li>the JSON would also work nicely with the concept of a dogen
project. Story: <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_99.org#introduce-dogen-projects">Introduce dogen projects</a></li>
</ul>

<p>
However, before we embark on this story we need to perform a lot of
analysis on this.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>yarn.dia.comment is no longer necessary, just look for the
markers.</li>
<li>we should only allow arrays of simple types.</li>
<li>the fragment used inside Dia should be identical to the file
supplied as argument for the one-off profile and it should also
identical to a fragment inside a project. Do we need to support both
projects and one-off profiles?</li>
</ul>

<p>
Sample:
</p>

<pre class="code"><code>  "annotation": {
    "yarn.dia.comment": true,
    "yarn.dia.external_modules": "dogen::test_models",
    "annotations.profile": "dogen",
    "yarn.input_language": "language_agnostic",
    "yarn.output_language": [ "csharp", "cpp" ]
</code></pre>

<p>
This error has been picked up by codacy too:
</p>

<ul class="org-ul">
<li><a href="https://www.codacy.com/app/marco-craveiro/dogen/commit?cid%3D79696432&amp;bid%3D3493157&amp;utm_campaign%3Dnew_commit&amp;utm_medium%3DEmail&amp;utm_source%3DInternal">Commit 91886c6</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfb3101e" class="outline-4">
<h4 id="orgfb3101e"><span class="section-number-4">3.3.35</span> Check if enable kernel directories is on extraction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-35">
<p>
When we moved the kernel logic into yarn from quilt, we did not rename
the traits.
</p>
</div>
</div>

<div id="outline-container-org03531c7" class="outline-4">
<h4 id="org03531c7"><span class="section-number-4">3.3.36</span> Add additional checks in generation formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-36">
<p>
We are not validating very much in the formatters. Checks we could be
doing for boilerplate formatter:
</p>

<ul class="org-ul">
<li>anonymous namespaces outside of c++ are invalid.</li>
<li>ensure TS is supported.</li>
<li>include guards outside of c++ are invalid.</li>
<li>include guard must obey a regex.</li>
<li>c++ dependencies are expected to be enclosed in quotes or angle
brackets.</li>
<li>c# dependencies are expected to be valid identifiers.</li>
</ul>
</div>
</div>

<div id="outline-container-org55cc64d" class="outline-4">
<h4 id="org55cc64d"><span class="section-number-4">3.3.37</span> Operations to add when we have code merging support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-37">
<p>
This story lists all of the operations that should be added to objects
once we can merge handcrafted code with generated code.
</p>

<ul class="org-ul">
<li>add <code>size()</code> to model and element repository, computed by adding the
size of all element containers.</li>
<li>add <code>merge()</code> (join?) to models.</li>
<li>add <code>id()</code> to names or maybe to elements (or both).</li>
</ul>
</div>
</div>

<div id="outline-container-org766a6e6" class="outline-4">
<h4 id="org766a6e6"><span class="section-number-4">3.3.38</span> Shared pointers have getters and setters with references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-38">
<p>
We should really pass shared pointers by value instead of reference.
</p>
</div>
</div>

<div id="outline-container-org2933a7e" class="outline-4">
<h4 id="org2933a7e"><span class="section-number-4">3.3.39</span> Improve LAM test models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-39">
<p>
At present LAM is very basic. We need to ensure that all features work
correctly for LAM:
</p>

<ul class="org-ul">
<li>inheritance, composition</li>
<li>dynamic arrays, static arrays</li>
<li>enumerations</li>
<li>exceptions</li>
<li>cross-TS handcrafted profiles</li>
</ul>

<p>
We need to look at the core C++ and C# models and see what else we may
be missing.
</p>
</div>
</div>

<div id="outline-container-org48adb4a" class="outline-4">
<h4 id="org48adb4a"><span class="section-number-4">3.3.40</span> Create an element builder&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-40">
<p>
At present we are manually populating the core properties of
element. This means every time a new one is added, we need to go and
find all the places where element is being created. We need a template
based builder for element that takes care of these:
</p>

<ul class="org-ul">
<li>populate implicit properties, such as configuration whenever name is
populated.</li>
<li>hide name factory inside of builder.</li>
<li>to determine the builder API, see all use cases where we are
manually creating the element.</li>
<li>populate the origin type. At present we are doing this on a
transform but the problem is we keep forgetting on adding new
meta-model types to it. Ideally we just want the types to be
populated straight on adaption. We just need a flag to be supplied
to the injection to coding transform (is target?), if we don't have
one already.</li>
</ul>
</div>
</div>

<div id="outline-container-org70d86b5" class="outline-4">
<h4 id="org70d86b5"><span class="section-number-4">3.3.41</span> Improve model mapping support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-41">
<p>
Our original mapping implementation was very tentative. It had a
number of half-baked ideas that were not fully implemented. We tried
to preserve some of it, so that when we return to fix it we can
continue from where we left of. The two key ideas that are very
undeveloped are:
</p>

<ul class="org-ul">
<li>mapping to native types. For example, we want a way to say
<code>lam::array&lt;int&gt;</code> and have that map to <code>int[]</code> on C++ and C#. This
is not entirely trivial because it requires some intelligence at the
mapping level; we could for example map <code>array</code> to setting a bit on
the <code>int</code> type to signify an array.</li>
<li>mapping to types that are not required on a given technical
space. For example, <code>lam::pointer</code> maps to a <code>shared_ptr</code> in C++,
but to a normal type in C#. We need some kind of "type erasure" or
again treat this as a native type. This is probably the cleanest
solution.</li>
</ul>

<p>
Other problems:
</p>

<ul class="org-ul">
<li>at present there is no way to tell if the mapping support is
complete or not. For example, we could have forgotten to add a
reference to a C++ model, which would cause the mappings to fail. We
have no way of knowing what reference is missing. However, we could
"grep" a library and determine all of the potential mappings and
then tell the user that it is missing a reference. This includes
models that are not referenced. In fact this is useful in general,
we could have a "light weight model" that just gets the IDs and
mappings of all injection models and is used on resolution failures
and mapping failures.</li>
<li>mapping only allows a single target per element, e.g. <code>std::string</code>
can only be mapped to a single LAM element. This has two
limitations: first, it is entirely possible we have a LAM type
mapped to more than one element (for example say we could have two
string-like types in LAM that are implemented by
<code>std::string</code>). Secondly, users cannot define their own mappings if
the destination has already been mapped. Both of these limitations
would be addressed if we made the destination <code>text_collection</code>
rather than just <code>text</code>. In theory it should just work.</li>
<li>we can only have one mapping set. Originally we had envisioned that
users could supply multiple mapping sets, mapping different types as
required to LAM types. However, the new setup does not allow for
this. It could be possible via some weird and wonderful
parameterisation of mapping targets, but we are yet to have a use
case for such a complex scenario so its probably not worth worrying
about it.</li>
<li>mappings and overrides is a complex issue. Some of the problems we
have are:
<ul class="org-ul">
<li>assume you can define mapping overrides; how do you determine
their scope? Do the overrides work only for one of the loaded
models or all the loaded models? Can you apply overrides to a
single package? What happens when you have a model set with
multiple overrides?</li>
</ul></li>
</ul>

<p>
The fundamental problem appears to be that we need a good use case for
model mapping. At present we haven't got one so there are too many
possibilities for the implementation. If we do decide to go forward
with the clean up, we should first read up on the literature and then
settle on a subset of functionality that we can reasonably "make up" a
use case for. For example, its useful not to have to define test
models for all languages we support. It would be much nicer if we
could have the "core" test model, testing inheritance, association,
composition and the like, defined in LAM and reused across all
supported output technical spaces.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>perhaps the correct solution is to have two different kinds of
modeling elements related to mapping:
<ul class="org-ul">
<li>the "abstract" element which is in effect a place holder and must
belong to an abstract technical space such as LAM;</li>
<li>the "mapping" element, which is defined against a concrete
technical space such as C++. Each attribute of the mapping element
is a mapping between an abstract element and a concrete element.</li>
</ul></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Allow users to override mapping sets at the element level</b>
</p>

<p>
Sometimes we may want to use a different mapping just for a particular
element. For example, by default <code>lam::linked_list</code> binds to
<code>std::list</code> for C++; once Dogen supports <code>std::forward_list</code>, one may
want to override this for a partial number of elements. It would be
nice if one could have a meta-data tag at the attribute level that
would override the mapping. The one slight wrinkle is that we would
not be able to supply a breakdown of:
</p>

<ul class="org-ul">
<li>simple name</li>
<li>model name</li>
<li>internal modules</li>
</ul>

<p>
and so forth. So this may cause issues for resolution. We'd have to
test it and see what breaks. Actually this may just work, The current
mappings in LAM take the form of:
</p>

<pre class="example">
"masd.mapping.target": "masd.lam.numeric.integer8",
</pre>


<p>
This is placed in the source of the mapping. We could allow mapping
overrides locally by letting users define both the source and the
target of a mapping in the context of the attribute. Then, during
mapping, we could use these overrides only in the function that maps
the attribute: e.g. read the local attribute override, override a
local copy of the map, then apply the mapping. The changes are only
local to the override. The problem of global overrides must be tackled
elsewhere.
</p>

<p>
If this fails, the alternative is that the mapping is by id, and we'd
resolve it internally using the mapping container, e.g.:
</p>

<ul class="org-ul">
<li>create a map of names for each language by id</li>
<li>user supplies the id for a given language, we look it up and
retrieve the name.</li>
</ul>
</div>
</div>

<div id="outline-container-org37ecf49" class="outline-4">
<h4 id="org37ecf49"><span class="section-number-4">3.3.42</span> Improve resolution errors when user fails to reference model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-42">
<p>
We could have a "light weight model" that just gets the IDs and
mappings of all injection models that have not been referenced and
uses it for resolution failures and mapping failures.
</p>
</div>
</div>

<div id="outline-container-org4474b9f" class="outline-4">
<h4 id="org4474b9f"><span class="section-number-4">3.3.43</span> Move to .net core in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-43">
<p>
At present we are using .net framework, but everyone has moved on to
.net core. Update projects to use .net core.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://kimsereyblog.blogspot.com/2018/08/sdk-style-project-and-projectassetsjson.html">SDK-Style project and project.assets.json</a></li>
</ul>
</div>
</div>

<div id="outline-container-org98325db" class="outline-4">
<h4 id="org98325db"><span class="section-number-4">3.3.44</span> Use C# notation in JSON C# models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-44">
<p>
At present we are generating C++ style types in JSON models (at least
for LAM):
</p>

<pre class="example">
"type": "masd::lam::text::character"
</pre>


<p>
If we change this to
</p>

<pre class="example">
"type": "masd.lam.text.character"
</pre>


<p>
We get a parsing error. We need to detect the output technical space,
use the correct convention for module separation and ensure it is
valid from a parsing perspective.
</p>
</div>
</div>

<div id="outline-container-org9f3041d" class="outline-4">
<h4 id="org9f3041d"><span class="section-number-4">3.3.45</span> Consider renaming LAM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-45">
<p>
We originally created the Language Agnostic Model (LAM). This may not
be the best of names, especially now we moved over to technical
spaces. It should really reflect its PIM (platform independent model)
nature. Names: <code>masd::lannguage_agnostic</code>, <code>masd::la</code> or maybe
<code>masd::pim</code>? LAM is not a MDE term either.
</p>

<p>
Actually, now that we are moving towards Technical Spaces, the name
should reflect the fact that it belongs to an abstract TS.
</p>
</div>
</div>

<div id="outline-container-orgabf90d7" class="outline-4">
<h4 id="orgabf90d7"><span class="section-number-4">3.3.46</span> Remove empty types in <code>=injection.json</code> models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-46">
<p>
At present we are adding type to the converted model, even when its
empty. For cases such as enumerations this is just confusing:
</p>

<pre class="example">
{
  "name": "meta_model::static_stereotypes",
  "documentation": "Lists all stereotypes defined in the masd UML profile.\n",
  "stereotypes": [
    "masd::enumeration"
  ],
  "fallback_element_type": "masd::object",
  "attributes": [
    {
      "name": "object",
      "type": ""
    },
    {
      "name": "object_template",
      "type": ""
    },
    {
      "name": "exception",
      "type": ""
    },
</pre>


<p>
It would be much easier to read this if we ignored empty types. We
need to check that the hydrator is not expecting this field.
</p>
</div>
</div>

<div id="outline-container-org28ccbfa" class="outline-4">
<h4 id="org28ccbfa"><span class="section-number-4">3.3.47</span> Consider creating top level exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-47">
<p>
There are a number of exceptions that have been repeated across
projects. For example:
</p>

<ul class="org-ul">
<li>transform error</li>
<li>building error</li>
</ul>

<p>
We should consider having these in the dogen API and removing them
from each project. However, we need to consider if end users should
necessary know about these exceptions.
</p>
</div>
</div>

<div id="outline-container-org90a8db3" class="outline-4">
<h4 id="org90a8db3"><span class="section-number-4">3.3.48</span> Add dependency checks to transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-48">
<p>
Check the backlog as we may already have this story. At present we do
not have a way to determine if a given transform dependency has been
met. Say for example transform A depends on transform B; we are aware
of this only because the comments on the transform chains tell us
so. It would be nicer if we could declare transform dependencies (and
reasons) as part of the transform "interface" and then check that a
given transform has indeed been applied to a model. This also fits in
with the idea that we keep track of which transforms have affected a
given model. In this sense we need to capture:
</p>

<ul class="org-ul">
<li>what transforms have been applied;</li>
<li>whether the transform has modified anything or not.</li>
</ul>
</div>
</div>

<div id="outline-container-org3091616" class="outline-4">
<h4 id="org3091616"><span class="section-number-4">3.3.49</span> Modeling elements should not have <code>profile</code> setup&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-49">
<p>
We expected <code>masd.variability.profile</code> to be only applicable at the
global scope, but when overriding it manually no error occurs and no
override happens either. Check the binding properties of this
field. We need to ensure that users cannot add this field to profiles
or else we will end up with very weird error messages and/or
behaviours.
</p>

<p>
Actually this is probably not right - we have stereotypes on elements
and these map to profile binds. The only real problem is when using
profiles on profiles probably. This requires some thinking.
</p>
</div>
</div>

<div id="outline-container-org4109369" class="outline-4">
<h4 id="org4109369"><span class="section-number-4">3.3.50</span> Profile overriding may cause link errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-50">
<p>
We've added profile overriding to solve the nightlies problem:
generating all facets. However, there was a consequence we didn't
notice at the time: the code must always link against <b>all</b> the
libraries required by full code generation. That is, if any facet
requires a third-party library, and that facet is normally disabled
but it is enabled on the nightly, we need to link against the library
even when not using the facet.
</p>

<p>
How we noticed this problem: we removed boost serialisation from our
list of libraries and now the nightly is failing to link with lots of
errors like these:
</p>

<pre class="example">
/work/DomainDrivenConsulting/masd/vcpkg/masd/installed/x64-linux/include/boost/archive/basic_xml_oarchive.hpp:99: error: undefined reference to 'boost::archive::basic_xml_oarchive&lt;boost::archive::xml_oarchive&gt;::save_start(char const*)'
</pre>


<p>
The right solution is to have "facet specific" link libraries, that
kick in when the facet is enabled. This will not happen for a long
time.
</p>
</div>
</div>

<div id="outline-container-org2e302a3" class="outline-4">
<h4 id="org2e302a3"><span class="section-number-4">3.3.51</span> References to ODB types in different namespaces fails&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-51">
<p>
By mistake we created a type which was meant to be in the relational
namespace, but due to dia's peculiarities around copy and pasting,
ended up in the model namespace. The generated ODB files had includes
that placed the referenced ODB files in "types" rather than in
"odb". It seems there is some kind of regex error.
</p>
</div>
</div>

<div id="outline-container-org99b691f" class="outline-4">
<h4 id="org99b691f"><span class="section-number-4">3.3.52</span> Schema name propagation is not handled correctly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-52">
<p>
The logic around the propagation of schema names is very dodgy. Not
only do we rely on overwriting the schema name (e.g. first we take the
containing module schema name, then we check to see if its overridden
at the element level) but we also do not take into account recursive
composition. We need to revisit this.
</p>
</div>
</div>

<div id="outline-container-org8d3e15c" class="outline-4">
<h4 id="org8d3e15c"><span class="section-number-4">3.3.53</span> Test ORM support for table name and column name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-53">
<p>
At present it seems we can supply a table name, but no corresponding
ODB pragmas are generated for it. The same seems to be the case with
column name.
</p>

<p>
Actually column name seems to work because we are using "raw" odb
pragmas:
</p>

<pre class="example">
#DOGEN masd.orm.odb_pragma=column("LASTNAME")
</pre>


<p>
We should really have an ORM level concept of column name and table
name.
</p>
</div>
</div>

<div id="outline-container-org7a47916" class="outline-4">
<h4 id="org7a47916"><span class="section-number-4">3.3.54</span> Conversion does not output static stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-54">
<p>
At present we only output dynamic stereotypes. However, there is no
point on fixing this until we move to the new JSON format. This could
also resolve the elment fall back issue in JSON: check to see if any
static stereotypes with element definitions have been supplied, and if
not, use the fallback element type.
</p>

<p>
Actually we shouldn't even have a fallback element type at the JSON
level; if an injector does not provide a type, we should just default
to say object.
</p>

<p>
Merged stories:
</p>

<p>
<b>Rename <code>fallback_element_type</code></b>
</p>

<p>
Our JSON uses a very strangely named attribute to carry the meta-type:
</p>

<pre class="example">
"fallback_element_type": "masd::object",
</pre>


<p>
Its not at all obvious what this is meant to do. It should just be the
<code>element_type</code>.
</p>

<p>
We introduced this because users can set the stereotype,
e.g. <code>masd::object</code> - but don't always have to (e.g. when converting a
model from Dia). In this case, the fallback element type is
used. Perhaps we can keep the "fallback" logic internally, but just
call it element type?
</p>

<p>
One possible solution is to simply populate the stereotypes with the
inferred metamodel type. For this we need to check against a list of
metamodel types ("has the user already defined a stereotype?") and if
not, use the default one. This means our conversion will not roundtrip
without differences, but at least it produces more sensible models.
</p>

<p>
We directly mapped KVPs in UML to JSON, e.g.:
</p>

<pre class="example">
#DOGEN masd.injection.model_modules=Masd.CSharpRefImpl.CSharpModel
#DOGEN masd.injection.input_language=csharp
#DOGEN masd.injection.reference=csharp.builtins
#DOGEN masd.injection.reference=csharp.system.collections.generic
#DOGEN masd.injection.reference=csharp.system.collections
#DOGEN masd.injection.reference=csharp.system
...
</pre>


<p>
maps to:
</p>

<pre class="example">
{
 "tagged_values": {
   "masd.injection.dia.comment": "true",
   "masd.injection.model_modules": "Masd.CSharpRefImpl.CSharpModel",
   "masd.injection.input_language": "csharp",
   "masd.injection.reference": "csharp.builtins",
   "masd.injection.reference": "csharp.system.collections.generic",
   "masd.injection.reference": "csharp.system.collections",
   "masd.injection.reference": "csharp.system",
...
</pre>


<p>
However, we cannot have duplicate keys in JSON, resulting in problems
when we indent models: the indenter removes all duplicate keys but
one. This means we have to massage models post indentation every
time. Solutions:
</p>

<ul class="org-ul">
<li>use a JSON container for container keys. The problem with this is
that our internal representation does not have a container but a
list of KVPs. We need to somehow convert to and from this container
representation. We also need to be able to dynamically determine if
the value is a container or just a plain value when deserialising
from JSON. If it's a container, we need to flatten it.</li>
<li>actually, now that we added annotations to the injection model, we
can first perform the annotations transform; this would convert the
keys to the right types. We can then convert to JSON using the
annotations. However, the one downside of this approach is that the
JSON representation of injection would be at a higher level of
abstraction.</li>
<li>the final solution for this is to make the map a container of
pairs. In effect that is what the container is in the first place,
we just mapped it incorrectly into JSON. So instead of</li>
</ul>

<pre class="example">
"tagged_values": {
  "masd.injection.reference": "cpp.builtins",
  "masd.injection.reference": "cpp.std",
  "masd.injection.reference": "cpp.boost",
</pre>


<p>
we'd have:
</p>

<pre class="example">
"tagged_values": [
  { "masd.injection.reference": "cpp.builtins" },
  { "masd.injection.reference": "cpp.std" },
  { "masd.injection.reference": "cpp.boost" },
</pre>
</div>
</div>

<div id="outline-container-orga5e52e3" class="outline-4">
<h4 id="orga5e52e3"><span class="section-number-4">3.3.55</span> Colours test model is invalid at present&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-55">
<p>
We should probably generate this model; at the moment, we have many
missing elements/meta-data, causing dogen to choke. However we need a way
to make the model generate nothing.
</p>
</div>
</div>

<div id="outline-container-org5febe83" class="outline-4">
<h4 id="org5febe83"><span class="section-number-4">3.3.56</span> Copyright holders is scalar when it should be an array&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-56">
<p>
At present its only possible to specify a single copyright holder. It
should be handled the same was as odb parameters, but because that is
done with a massive hack, we are not going to extend the hack to
copyright holders.
</p>

<p>
This functionality has been implemented but requires tests in the test
model.
</p>
</div>
</div>

<div id="outline-container-org390d8d4" class="outline-4">
<h4 id="org390d8d4"><span class="section-number-4">3.3.57</span> Check support for decoration configuration overrides&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-57">
<p>
At present we have hard-coded the decoration configuration to be read
from the root object only. In an ideal world, we should be able to
override some of these such as the copyrights. It may not make sense
to be able to override them all though.
</p>

<p>
This functionality has been implemented but requires tests in the test
model.
</p>
</div>
</div>

<div id="outline-container-orgd577dbb" class="outline-4">
<h4 id="orgd577dbb"><span class="section-number-4">3.3.58</span> Location of <code>--byproduct-directory</code> not respected on conversion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-58">
<p>
It seems that at present we are not honouring the directory supplied
by the user. This seems to only happen on convert mode.
</p>
</div>
</div>

<div id="outline-container-orgc703680" class="outline-4">
<h4 id="orgc703680"><span class="section-number-4">3.3.59</span> Generated tests fail when model has nothing to test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-59">
<p>
In cases where we are generating tests for a model which has nothing
to test - from a dogen generated code perspective - the tests will
fail with an error. This is because boost test expects to have at
least one test registered. In the past we have solved this by adding
"fake tests" which kept the test suite green until we added real
tests. However, for generated code, we need to somehow determine when
the fake tests should be injected.
</p>

<p>
This is not a trivial thing to do because we need to ensure that the
test template did not emit a single test for a given entity, and then
look at all entities and see if there is at least one test or not.
</p>

<p>
Example fake tests:
</p>

<pre class="code"><code><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #C586C0;">&lt;</span><span style="color: #DB8E73;">boost/test/unit_test.hpp</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">"dogen.utility/types/test/logging.hpp"</span>

<span style="color: #339CDB; font-weight: bold;">namespace</span> <span style="color: #C586C0;">{</span>

<span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB;">std</span>::<span style="color: #35CDAF;">string</span> <span style="color: #85DDFF;">empty</span>;
<span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB;">std</span>::<span style="color: #35CDAF;">string</span> <span style="color: #85DDFF;">test_module</span><span style="color: #DB8E73;">(</span><span style="color: #DB8E73;">"dogen.tests"</span><span style="color: #DB8E73;">)</span>;
<span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #339CDB;">std</span>::<span style="color: #35CDAF;">string</span> <span style="color: #85DDFF;">test_suite</span><span style="color: #DB8E73;">(</span><span style="color: #DB8E73;">"fake_tests"</span><span style="color: #DB8E73;">)</span>;

<span style="color: #C586C0;">}</span>

BOOST_AUTO_TEST_SUITE<span style="color: #C586C0;">(</span>fake_tests<span style="color: #C586C0;">)</span>

<span style="color: #D9DAA2;">BOOST_AUTO_TEST_CASE</span><span style="color: #C586C0;">(</span>test<span style="color: #C586C0;">)</span> <span style="color: #C586C0;">{</span>
    SETUP_TEST_LOG<span style="color: #DB8E73;">(</span><span style="color: #DB8E73;">"test"</span><span style="color: #DB8E73;">)</span>;
<span style="color: #C586C0;">}</span>

BOOST_AUTO_TEST_SUITE_END<span style="color: #C586C0;">()</span>
</code></pre>

<p>
The current workaround is to disable generated tests whilst there are
no types to test. This is not ideal because if we introduce testable
types we will probably forget to remove the disabling, but its
arguably better than adding a fake type.
</p>
</div>
</div>

<div id="outline-container-org329005f" class="outline-4">
<h4 id="org329005f"><span class="section-number-4">3.3.60</span> Add meta-data to "force" parent&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-60">
<p>
At present we can force a class not to be final:
</p>

<pre class="example">
#DOGEN masd.generalization.is_final=false
</pre>


<p>
However, this still does not create the methods for a parent such as
virtual destructor, equals etc. We need something to trigger those
methods as well.
</p>
</div>
</div>

<div id="outline-container-orge221c92" class="outline-4">
<h4 id="orge221c92"><span class="section-number-4">3.3.61</span> <code>CMakeFiles</code> do not reference dogen models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-61">
<p>
At present we cannot test cross-model referencing because our
CMakeFiles are not adding the linking references to these models. This
needs to be fixed before we can test cross model serialisation.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>in order to map references to models, we need to create a modeling
element for a reference. For this we have two cases: for proxy
models/PDMs, we need to read from the meta-data the name of the lib
the model generates. For dogen models we can create it from the
model name.</li>
<li>this is a variation of the "exports and imports" pattern: we import
a set of libraries (these can either be macros or actual library
names) and we export (for now) a single library. When we support
facets in libraries, we may need to export more than one, so we
should cope with this scenario now. We need to keep track of the
exports for a reference, and then use those as the imports for the
model.</li>
<li>in an ideal world, all imports come via this mechanism. However,
this means we now have to create PDMs/proxies just to setup the
imports. For example, for LibXML we will not need to define any of
the types, but we need the import. However, If we do force the
definition of the PDM, the advantage is that we now have the right
place to put the definition, and is done only once and shared by all
models.</li>
</ul>
</div>
</div>

<div id="outline-container-org0dbf46d" class="outline-4">
<h4 id="org0dbf46d"><span class="section-number-4">3.3.62</span> Cannot create classes with pointers to base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-62">
<p>
At present it is not possible to create a class (call it A) with a
shared pointer to a base class (B). This is because A defines the
equality operator, but B does not. We need to have some kind of "has
equality" but in a more generalised form so that we can reuse it for
other things like comparisons, etc.
</p>

<p>
Then, we suppress the generation of the equality operator in the
presence of any members which do not have support for it.
</p>
</div>
</div>

<div id="outline-container-orgbaec8df" class="outline-4">
<h4 id="orgbaec8df"><span class="section-number-4">3.3.63</span> Detect unqualified stereotypes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-63">
<p>
If a user enters say <code>enumeration</code> instead of <code>masd::enumeration</code> we
are providing an unhelpful error message:
</p>

<pre class="example">
Error: Attribute type is empty: structured
</pre>


<p>
This is because we validate the class as if it was an object and then
figure out that there are no types against the attributes. One easy
way to make things more useful is to detect unqualified stereotypes
and error straight away with a more useful message such as "did you
mean yarn::xyz?".
</p>

<p>
We could also do the same if the stereotype is blank ("did you mean
enumeration?").
</p>

<ul class="org-ul">
<li>for extra bonus points use the <a href="http://en.wikipedia.org/wiki/levenshtein_distance">Levenshtein distance</a> for spelling
suggestions. See stories on this by searching for Levenshtein.</li>
</ul>
</div>
</div>

<div id="outline-container-orga9a8f46" class="outline-4">
<h4 id="orga9a8f46"><span class="section-number-4">3.3.64</span> Using <code>std::set&lt;std::string&gt;</code> causes compilation errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-64">
<p>
In theory sets of strings (and any other type that has <code>operator&lt;</code>
should work out of the box, even though we do not support sets of
dogen types. However, when we tried to use a set of strings we got a
whole load of compilation errors in serialisation, etc.
</p>
</div>
</div>

<div id="outline-container-org97c8cbf" class="outline-4">
<h4 id="org97c8cbf"><span class="section-number-4">3.3.65</span> Line endings could cause rewrites&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-65">
<p>
At present if we git clone a repo with UNIX line endings and then
re-run dogen on Windows, even though nothing has changed in the model,
all generated files should get rewritten with windows line endings. We
should have a setting that enforces one set of line endings at the
model level. Interestingly, at present almost all extraction and
generation tests are green, implying we do not see any diffs. This is
very puzzling.
</p>
</div>
</div>

<div id="outline-container-org22e5b82" class="outline-4">
<h4 id="org22e5b82"><span class="section-number-4">3.3.66</span> Character member variables are not tidied up on io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-66">
<p>
At present there is no code to convert non-printable chars into
something acceptable in JSON. We probably never noticed this before
because test data generates printable chars. Code generated is as
follows (all built-in model):
</p>

<pre class="example">
&lt;&lt; "\"char_property\": " &lt;&lt; "\"" &lt;&lt; v.char_property() &lt;&lt; "\"" &lt;&lt; ", "
</pre>


<p>
We need a "tidy-up char" function to handle this properly.
</p>

<p>
For now we've hacked this and set <code>remove_unprintable_characters</code> to
false to keep backwards compatibility with legacy.
</p>
</div>
</div>

<div id="outline-container-orgfd1d610" class="outline-4">
<h4 id="orgfd1d610"><span class="section-number-4">3.3.67</span> Lists of strings are not properly tidied up on io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-67">
<p>
In the log file, when we dump include dependencies we see invalid
JSON:
</p>

<pre class="example">
[ "&lt;iosfwd&gt;", ""dogen/sml/types/merger.hpp"" ]
</pre>


<p>
This implies we are not calling <code>tidy_up_string</code>. This can be tested
by creating a container of <code>filesystem::path</code>.
</p>
</div>
</div>

<div id="outline-container-org68d7037" class="outline-4">
<h4 id="org68d7037"><span class="section-number-4">3.3.68</span> Use of disabled facets in non-generatable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-68">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to know when I try to use a disabled
facet in a non-generatable type so that I don't generate
non-compilable code.
</p>

</blockquote></div>

<p>
It would be useful to set facets to disabled on non-generatable types,
when there are generatable types that depend on them. For example, if
we create some non-generatable types for which there is only a <code>types</code>
facet, we may still want to create generatable types that make use of
them. In this case, we would like Dogen to automatically disable all
facets except for <code>types</code>. Also, if a type is non-generatable, all
facets should be automatically disabled and its up to the user to
enable the ones he is interested in manually.
</p>
</div>
</div>

<div id="outline-container-org4d18a83" class="outline-4">
<h4 id="org4d18a83"><span class="section-number-4">3.3.69</span> Type with the same name as the project does not compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-69">
<p>
It seems that if we create a type with exactly the same name as the
model, we get strange compilation errors:
</p>

<pre class="example">
/home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.4/stage/bin/dogen_examples/source/hello_world/include/hello_world/test_data/hello_world_td.hpp:37:13: error: hello_world::hello_world::hello_world names the constructor, not the type
    typedef hello_world::hello_world result_type;
            ^
</pre>


<p>
We should do a test case for this and fix the errors.
</p>
</div>
</div>

<div id="outline-container-org0dea965" class="outline-4">
<h4 id="org0dea965"><span class="section-number-4">3.3.70</span> Allow for generation of class with the same name as package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-70">
<p>
At present its not possible to generate a class inside a package with
the same name of that package, if the package documentation is being
generated. This is because they will both have the exact same file
name.
</p>
</div>
</div>

<div id="outline-container-org2741a84" class="outline-4">
<h4 id="org2741a84"><span class="section-number-4">3.3.71</span> Partial matching of built-ins doesn't work for certain types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-71">
<p>
We introduced a fix that allows users to create types that partially
match built-ins types such as <code>in</code> or <code>integer</code>. The fix was copied
from the spirit documentation:
</p>

<p>
<a href="http://www.boost.org/doc/libs/1_52_0/libs/spirit/repository/doc/html/spirit_repository/qi_components/directives/distinct.html">- Qi Distinct Parser Directive</a>
</p>
<ul class="org-ul">
<li><a href="http://www.boost.org/doc/libs/1_52_0/libs/spirit/repository/test/qi/distinct.cpp">distinct.cpp</a></li>
</ul>

<p>
Seems like the thing to do here is to create a keyword parser and nest
it with the existing parsers:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/21960167/prevent-the-boost-spirit-symbol-parser-from-accepting-a-keyword-too-early">Prevent the Boost Spirit Symbol parser from accepting a keyword too early</a></li>
<li><a href="http://www.boost.org/doc/libs/1_53_0/libs/spirit/repository/doc/html/spirit_repository/qi_components/directives/kwd.html">Qi Keyword Parser Directive</a></li>
</ul>

<p>
The new parser has a fix for these problems but was not completed so
cannot yet replace the legacy parser.
</p>
</div>
</div>

<div id="outline-container-org0ad6b2b" class="outline-4">
<h4 id="org0ad6b2b"><span class="section-number-4">3.3.72</span> Returning optional of base class results in invalid code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-72">
<p>
When defining a model with a type with a field of <code>boost::optional&lt;x&gt;</code>
where <code>x</code> is an abstract base class, we get compilation errors in test
data. The problem appears to be that our test data factories try to
instantiate <code>x</code> rather than go through the abstract base class
machinery. We need to build a test model for this and fix the code.
</p>

<p>
We should also question if this is a valid scenario - if not we must
add it to the validation rules.
</p>
</div>
</div>

<div id="outline-container-orgca8e956" class="outline-4">
<h4 id="orgca8e956"><span class="section-number-4">3.3.73</span> Investigate current support for <code>std::set</code> and <code>std::map</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-73">
<p>
It seems that we do not support sets and maps at present. When we
tried to use a set, we got errors in the guts of test data generation:
</p>

<pre class="example">
/usr/bin/../lib/gcc/x86_64-linux-gnu/4.9/../../../../include/c++/4.9/bits/stl_function.h:371:20: error: invalid operands to binary expression ('const dogen::sml::qname' and 'const dogen::sml::qname')
      { return __x &lt; __y; }
</pre>


<p>
This could be a bug (e.g. we are placing the <code>operator&lt;</code> in the wrong
place etc). Or it could be that we just never needed ordered maps and
sets so we never added proper support.
</p>
</div>
</div>

<div id="outline-container-org3b123e3" class="outline-4">
<h4 id="org3b123e3"><span class="section-number-4">3.3.74</span> Format doubles, floats and bools properly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-74">
<p>
At present we are using IO state savers but not actually setting the
formatting on the stream depending on the built-in type.
</p>

<p>
Ideally we should pass in some dynamic extensions to determine the
formatting. We should also consider using <code>boost::format</code> for this.
</p>
</div>
</div>

<div id="outline-container-orgb709ebb" class="outline-4">
<h4 id="orgb709ebb"><span class="section-number-4">3.3.75</span> Private properties should be ignored&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-75">
<p>
At present we treat private properties as if they were public; we
should ignore them. We need to go through all the models and change
the private ones to public before we do this.
</p>

<p>
We should also log a warning.
</p>
</div>
</div>

<div id="outline-container-org1b71b8e" class="outline-4">
<h4 id="org1b71b8e"><span class="section-number-4">3.3.76</span> Identifiable needs to use camel case in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-76">
<p>
At present we are building identifiables with underscores.
</p>
</div>
</div>

<div id="outline-container-orgc44ee1d" class="outline-4">
<h4 id="orgc44ee1d"><span class="section-number-4">3.3.77</span> Inserter for enumerations shouldn't throw&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-77">
<p>
We only use the inserter for debug dumping and it could happen that we
are about to write the message for an exception when we decide to
throw. Instead we should just print unexpected/invalid value and cast
it to a numeric value in brackets.
</p>
</div>
</div>

<div id="outline-container-orgf6fdc3f" class="outline-4">
<h4 id="orgf6fdc3f"><span class="section-number-4">3.3.78</span> Assignment operator seems to pass types by value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-78">
<p>
The code for the operator is as follows:
</p>

<pre class="example">
stream_ &lt;&lt; indenter_ &lt;&lt; ci.name() &lt;&lt; "&amp; operator=(" &lt;&lt; ci.name()
       &lt;&lt; " other);" &lt;&lt; std::endl;
</pre>


<p>
If this is the case we need to fix it and regenerate all models.
</p>

<p>
Actually we have implemented assignment in terms of swap, so that is
why we copy. We need to figure out if this was a good idea. Raise
story in backlog.
</p>

<pre class="example">
diff --git a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
index f9f91af..663f0ac 100644
--- a/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
+++ b/projects/cpp/src/types/formatters/types/class_header_formatter.stitch
@@ -253,7 +253,7 @@ public:
 &lt;#+
                 if (!c.is_parent()) {
 #&gt;
-    &lt;#= c.name() #&gt;&amp; operator=(&lt;#= c.name() #&gt; other);
+    &lt;#= c.name() #&gt;&amp; operator=(&lt;#= c.name() #&gt;&amp; other);
 &lt;#+
                 }
             }
diff --git a/projects/cpp_formatters/src/types/class_declaration.cpp b/projects/cpp_formatters/src/types/class_declaration.cpp
index c2eeb3c..534ab69 100644
--- a/projects/cpp_formatters/src/types/class_declaration.cpp
+++ b/projects/cpp_formatters/src/types/class_declaration.cpp
@@ -457,8 +457,8 @@ void class_declaration::swap_and_assignment(

     // assignment is only available in leaf classes - MEC++-33
     if (!ci.is_parent()) {
-        stream_ &lt;&lt; indenter_ &lt;&lt; ci.name() &lt;&lt; "&amp; operator=(" &lt;&lt; ci.name()
-                &lt;&lt; " other);" &lt;&lt; std::endl;
+        stream_ &lt;&lt; indenter_ &lt;&lt; ci.name() &lt;&lt; "&amp; operator=(const " &lt;&lt; ci.name()
+                &lt;&lt; "&amp; other);" &lt;&lt; std::endl;
     }

     utility_.blank_line();
diff --git a/projects/cpp_formatters/src/types/class_implementation.cpp b/projects/cpp_formatters/src/types/class_implementation.cpp
index 5c9fe50..9276701 100644
--- a/projects/cpp_formatters/src/types/class_implementation.cpp
+++ b/projects/cpp_formatters/src/types/class_implementation.cpp
@@ -456,8 +456,8 @@ assignment_operator(const cpp::formattables::class_info&amp; ci) {
         return;

     stream_ &lt;&lt; indenter_ &lt;&lt; ci.name() &lt;&lt; "&amp; "
-            &lt;&lt; ci.name() &lt;&lt; "::operator=(" &lt;&lt; ci.name()
-            &lt;&lt; " other) ";
+            &lt;&lt; ci.name() &lt;&lt; "::operator=(const " &lt;&lt; ci.name()
+            &lt;&lt; "&amp; other) ";

     utility_.open_scope();
     {
</pre>
</div>
</div>

<div id="outline-container-org0957a21" class="outline-4">
<h4 id="org0957a21"><span class="section-number-4">3.3.79</span> Shared pointer to vector fails to build&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-79">
<p>
If one has a property with type
<code>boost::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;</code>, we get the following
error:
</p>

<pre class="example">
/home/marco/Development/kitanda/output/dogen/stage/bin/demo/demo_20/sprint_20/src/test_data/my_class_td.cpp: In function boost::shared_ptr&lt;std::vector&lt;std::basic_string&lt;char&gt; &gt; &gt; {anonymous}::create_boost_shared_ptr_std_vector_std_string_(unsigned int):
/home/marco/Development/kitanda/output/dogen/stage/bin/demo/demo_20/sprint_20/src/test_data/my_class_td.cpp:47:50: error: create_std_vector_std_string_ptr was not declared in this scope
</pre>


<p>
This is because the generated code is not creating a method to new
vectors:
</p>

<pre class="example">
std::vector&lt;std::string&gt; create_std_vector_std_string(unsigned int position) {
   std::vector&lt;std::string&gt; r;
   for (unsigned int i(0); i &lt; 10; ++i) {
       r.push_back(create_std_string(position + i));
   }
   return r;
</pre>

<p>
:}
</p>
<pre class="example">

</pre>

<p>
:boost::shared<sub>ptr</sub>&lt;std::vector&lt;std::string&gt; &gt;
:create<sub>boost</sub><sub>shared</sub><sub>ptr</sub><sub>std</sub><sub>vector</sub><sub>std</sub><sub>string</sub><sub>(unsigned int position)</sub> {
</p>
<pre class="example">
boost::shared_ptr&lt;std::vector&lt;std::string&gt; &gt; r(
    create_std_vector_std_string_ptr(position));
return r;
</pre>

<p>
:}
</p>
</div>
</div>

<div id="outline-container-orgb458e4a" class="outline-4">
<h4 id="orgb458e4a"><span class="section-number-4">3.3.80</span> Add tests for immutability on an inheritance tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-80">
<p>
We are using the full constructor for immutability, but its not clear
how that would work on a inheritance tree. Ensure we have test cases
for this.
</p>

<p>
In particular, have a look at the test data generator with
immutability - it appeared wrong.
</p>
</div>
</div>

<div id="outline-container-org8d4dea9" class="outline-4">
<h4 id="org8d4dea9"><span class="section-number-4">3.3.81</span> Equality in floating point numbers is incorrect&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-81">
<p>
At present we are blindly comparing floating point numbers. In
all<sub>builtins</sub> test model:
</p>

<pre class="example">
double_property_ == rhs.double_property_ &amp;&amp;
float_property_ == rhs.float_property_;
</pre>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://realtimecollisiondetection.net/blog/?p%3D89">Floating-point tolerances revisited</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8448495" class="outline-4">
<h4 id="org8448495"><span class="section-number-4">3.3.82</span> Fix northwind tests on OSX and Windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-82">
<p>
Get the tests to compile and run on windows. At present they are
failing to link. It seems there is some kind of mismatch between debug
and release, at least on MSVC.
</p>

<p>
Building with linking errors is available <a href="https://ci.appveyor.com/project/mcraveiro/cpp-ref-impl/builds/22859591">here</a>. For now we've disabled
postgres:
</p>

<pre class="example">
diff --git a/.appveyor.yml b/.appveyor.yml
index 3f9fc6e..c265e24 100644
--- a/.appveyor.yml
+++ b/.appveyor.yml
@@ -41,7 +41,6 @@ services:
 before_build:
   - SET PGUSER=postgres
   - SET PGPASSWORD=Password12!
-  - SET POSTGRES_SERVER_SETUP=1
   - psql -f %APPVEYOR_BUILD_FOLDER%\build\scripts\setup_postgres.sql -U postgres
   - if DEFINED msvc_setup_path call "%msvc_setup_path%" %msvc_setup_arg%
   - cd %APPVEYOR_BUILD_FOLDER%
</pre>


<p>
At present we are building northwind on all platforms, but the tests
are being excluded on OSX and windows, so we are not really testing
the linking, just the compilation. One of the problems is that we
conflated the running of the tests (for which we need a postgres
server) with the building of the tests (which we should always do
whenever we find all the required dependencies). However, it seems a
bit silly yo have to have two flags for this.
</p>

<p>
At present we have linking failures on both OSX and windows. It is not
entirely clear what is causing these failures. We need to revisit this
when we clean up the linking across dogen.
</p>
</div>
</div>

<div id="outline-container-orga2af136" class="outline-4">
<h4 id="orga2af136"><span class="section-number-4">3.3.83</span> Do not output JSON markers for primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-83">
<p>
We should just output the underlying primitive.
</p>
</div>
</div>

<div id="outline-container-org0910ebb" class="outline-4">
<h4 id="org0910ebb"><span class="section-number-4">3.3.84</span> Parent without descendants in current model errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-84">
<p>
At present it is not possible to generate a parent in a model which
does not have at least one descendant in that model. This is because
we do not generate the base class methods. We need a meta-data
parameter to force a class to become a parent.
</p>

<p>
For now we just hacked it by adding a fake descendant.
</p>

<p>
Interestingly, we already have a "is final" meta-data parameter. We
could possibly check this; if its not final then we could assume it is
a base class.
</p>
</div>
</div>

<div id="outline-container-orgef98164" class="outline-4">
<h4 id="orgef98164"><span class="section-number-4">3.3.85</span> C# inheritance requires ordering&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-85">
<p>
When we implement C# inheritance we must make sure we place the
interfaces at the end after any base classes or else we will have
compiler errors. This means we need to be able to distinguish
interfaces from other types (e.g. <code>interface</code> stereotype). We must
also make sure there is only at most one base class, as multiple
inheritance is only supported on interfaces.
</p>
</div>
</div>

<div id="outline-container-orgb552bb6" class="outline-4">
<h4 id="orgb552bb6"><span class="section-number-4">3.3.86</span> Add meta-data to trigger inclusion/generation of <code>stdafx</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-86">
<p>
No setting to add include for precompiled headers: <code>stdafx.h</code>. In
addition, this should be a formatter specific property. It must look
at some model state (e.g. "generate windows files").
</p>
</div>
</div>

<div id="outline-container-orgfdb5865" class="outline-4">
<h4 id="orgfdb5865"><span class="section-number-4">3.3.87</span> Immutable types cannot be owned by mutable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-87">
<p>
When we try to create a mutable class that has a property of an
immutable type, the code fails to compile due to the swap
method. This is because immutable types do not provide swap.
</p>
</div>
</div>

<div id="outline-container-orgd5fe319" class="outline-4">
<h4 id="orgd5fe319"><span class="section-number-4">3.3.88</span> Add DateTime and related types to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-88">
<p>
At present we do not have date types in C#. We will need helpers,
etc. We should do this after the move to external PDMs.
</p>
</div>
</div>

<div id="outline-container-org8293f6e" class="outline-4">
<h4 id="org8293f6e"><span class="section-number-4">3.3.89</span> Using underscores with C# results in invalid code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-89">
<p>
When building in LAM, if one uses underscore notation we create code
like so:
</p>

<pre class="example">
public int prop_0 { get; set; }
public class_0(int prop_0)
{
    prop_0 = prop_0;
}
</pre>


<p>
C# thinks we're assigning the parameter to itself rather than making
use of the property.
</p>

<p>
The right fix for this is to support the "camel case mode" where we
will interpret underscores and generate camel case identifiers.
</p>

<p>
For now we should warn users when they try to use lower case
attributes in C#.
</p>
</div>
</div>

<div id="outline-container-orgf1b91cb" class="outline-4">
<h4 id="orgf1b91cb"><span class="section-number-4">3.3.90</span> Not setting output language results in weird errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-90">
<p>
When setting the input language to language agnostic and not setting
the output languages, we get the following error:
</p>

<pre class="example">
/dogen/projects/yarn/src/types/legacy_name_tree_parser.cpp(123): Throw in function std::__cxx11::string {anonymous}::grammar&lt;Iterator&gt;::scope_operator_for_language(dogen::yarn::languages) [with Iterator = __gnu_cxx::__normal_iterator&lt;const char*, std::__cxx11::basic_string&lt;char&gt; &gt;; std::__cxx11::string = std::__cxx11::basic_string&lt;char&gt;]
Dynamic exception type: boost::exception_detail::clone_impl&lt;dogen::yarn::parsing_error&gt;
std::exception::what: Invalid or unsupported language: { "__type__": "languages", "value": "language_agnostic" }
[tag_workflow*] = Code generation failure.
[owner*] = &lt;dogen&gt;&lt;test_models&gt;&lt;all_path_and_directory_settings&gt;&lt;package_0&gt;&lt;package_0_1&gt;&lt;class_2&gt;
unknown location(0): fatal error: in "workflow_tests/all_path_and_directory_settings_generates_expected_code_dia": std::runtime_error: Error during test
/home/marco/Development/DomainDrivenConsulting/dogen/projects/knit/tests/workflow_tests.cpp(213): last checkpoint
</pre>
</div>
</div>

<div id="outline-container-orgc525f06" class="outline-4">
<h4 id="orgc525f06"><span class="section-number-4">3.3.91</span> Add cross-model support to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-91">
<p>
At present we do not have any tests that prove that cross-model
support is working (other than proxy models). We need to create a user
level model that makes use of types from another model. In theory it
should just work since we are using fully qualified names everywhere.
</p>
</div>
</div>

<div id="outline-container-org1477177" class="outline-4">
<h4 id="org1477177"><span class="section-number-4">3.3.92</span> Do not include algorithm if swap is disabled&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-92">
<p>
At present we always include <code>algorithm</code> in types' class header - both
in new and old world. However, it is there for swap, so we should only
include it if we are going to generate swap. This could be achieved
with:
</p>

<pre class="example">
if ((!c.all_properties().empty() || c.is_parent()) &amp;&amp; !c.is_immutable()) {
</pre>


<p>
As per stitch template. We should probably add a "is swappable" flag
at the yarn level for this.
</p>

<p>
This is a bit more relevant now we are generating wale templates
because we are including algorithm all over the place on the generated
templates.
</p>
</div>
</div>

<div id="outline-container-orge23f73c" class="outline-4">
<h4 id="orge23f73c"><span class="section-number-4">3.3.93</span> Multiple inheritance and profiles do not work predictably&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-93">
<p>
The current inheritance logic is fine for single inheritance or even
multiple inheritance when two parts of the inheritance tree do not
define the same types; but it fails when there is overlap. For an
example, see the previous attempt to define "disable odb cmake" in terms
of "disable odb" and "disable cmake". This fails because disable odb
inherits from enable all facets; when we merge against "disable cmake"
we do not know that cmake was enabled via "enable all facets" and so
this takes priority.
</p>

<p>
We could add some validation that checks to see if we'd "revert"
changes depending on order. This is not very easy because it may
actually be the user's intention. We need to find some useful but
simple heuristic that indicates problems. Example:
</p>

<ul class="org-ul">
<li>changing a given knob more than twice?</li>
<li>updating a given knob in more than one place at the same level of
the hierarchy? This is a good candidate because its easy to detect.</li>
</ul>
</div>
</div>

<div id="outline-container-org82415bb" class="outline-4">
<h4 id="org82415bb"><span class="section-number-4">3.3.94</span> Reference to non-existent features produce unhelpful errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-94">
<p>
When renaming fields, we get the following dogen errors:
</p>

<pre class="example">
2016-01-09 22:54:27.703708 [ERROR] [dynamic.workflow] Field definition not found: cpp.odb.class_header_formatter.inclusion_required
</pre>


<p>
This is not particularly helpful. We should state:
</p>

<ul class="org-ul">
<li>that the field instance is in the user model but does not exist in
the library;</li>
<li>the type in which the field instance was used;</li>
<li>for extra bonus points use the <a href="http://en.wikipedia.org/wiki/levenshtein_distance">levenshtein distance</a> for spelling
suggestions. See story on this.</li>
</ul>

<p>
In addition this also depends on the field. For example, while
renaming <code>dia.comment</code> to <code>yarn.dia.comment</code>, we had no errors at all,
but then all fields defaulted. We should have gotten an error message
stating that the field did not exist.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Martinsos/edlib">edlib</a>: Lightweight, super fast C/C++ (&amp; Python) library for sequence
alignment using edit (Levenshtein) distance.</li>
<li><a href="https://github.com/cschanaj/levenshtein-distance">levenshtein-distance</a>: C++ Functions for Levenshtein Distance</li>
<li><a href="https://gist.github.com/TheRayTracer/2644387">https://gist.github.com/TheRayTracer/2644387</a>: A simple C++
implementation of the Levenshtein distance algorithm to measure the
amount of difference between two strings.
Computation with Generic Types</li>
<li><a href="https://github.com/schuyler/levenshtein">levenshtein</a>: Fast string edit distance computation, using the
Damerau-Levenshtein algorithm.</li>
</ul>
</div>
</div>

<div id="outline-container-orga6030d5" class="outline-4">
<h4 id="orga6030d5"><span class="section-number-4">3.3.95</span> Using <code>std::unordered_map&lt;my_enum, ...&gt;</code> fails equality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-95">
<p>
In the past we created an unordered map of an enumeration and then
suddenly the equality tests started to fail. Since we use unordered
maps for strings quite a lot, it may be related to the fact that we
used an enum? Add a test case on the test models and see if we can
reproduce it.
</p>
</div>
</div>

<div id="outline-container-org9218b4c" class="outline-4">
<h4 id="org9218b4c"><span class="section-number-4">3.3.96</span> Recursive structures result in crashes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-96">
<p>
If one defines a tree node with a parent and children (such as <code>node</code>
in <code>logical</code> model's helpers) dogen generates code that recurses
inifinitely. This is because the structure contains a parent and we
loop through the parent back to itself and so on. To stop this from
happening we need to tell dogen to exclude certain fields. For
example, we could mark <code>parent</code> as a cycle. This is then interpreted
by the io feature as a "do not follow the pointer" (just dump its
memory address). We could have a manipulator that tells the
<code>boost::shared_ptr</code> io to skip its payload, much like we do when the
pointer is empty.
</p>

<p>
In summary:
</p>

<ul class="org-ul">
<li>add a tag to mark a property as circular. Do not confuse this with
name tree cycles which are at the type level.</li>
<li>create a manipulator that is set when a circular property is
found. Set it appropriately.</li>
<li>on all pointer code (io, comparisons, etc) check for the
manipulator; if set, do not dereference the pointer. For equality do
a pointer comparison, for io dump the address, etc.</li>
</ul>
</div>
</div>

<div id="outline-container-org67e6f43" class="outline-4">
<h4 id="org67e6f43"><span class="section-number-4">3.3.97</span> Hydrators provide no context when errors occur&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-97">
<p>
We tried to parse a JSON file using the INI parser and got the
following errors:
</p>

<pre class="example">
2015-03-27 15:16:05.291132 [DEBUG] [formatters.modeline_group_hydrator] Reading file: /home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/../data/modeline_groups/emacs.json
2015-03-27 15:16:05.291215 [ERROR] [formatters.modeline_group_hydrator] Failed to parse INI file: : &lt;unspecified file&gt;(1): '=' character not found in line
2015-03-27 15:16:05.291933 [FATAL] [knitter] Error: /home/marco/Development/DomainDrivenConsulting/dogen/projects/formatters/src/types/modeline_group_hydrator.cpp(172): Throw in function dogen::formatters::modeline_group dogen::formatters::modeline_group_hydrator::hydrate(std::istream &amp;) const
Dynamic exception type: N5boost16exception_detail10clone_implIN5dogen10formatters15hydration_errorEEE
std::exception::what: Failed to parse INI file: &lt;unspecified file&gt;(1): '=' character not found in line
[P12tag_workflow] = Code generation failure.
</pre>


<p>
The exception provides no context to the file being parsed. We need to
catch the exception and augment it with the file name.
</p>

<p>
This is probably related to using boost property tree for JSON
parsing. Now that we have good vcpkg support we should just move to a
decent JSON library and ensure it reports errors at the line and
column level.
</p>
</div>
</div>

<div id="outline-container-org58fd6c8" class="outline-4">
<h4 id="org58fd6c8"><span class="section-number-4">3.3.98</span> Using types of non-referenced models produces bad error messages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-98">
<p>
By mistake we made a reference to <code>dynamic::object</code> in the schema
model, during the <code>dynamic</code> to <code>schema</code> refactoring. This resulted in
the following, non-obvious, error message:
</p>

<pre class="example">
2015-03-09 12:56:00.920766 [FATAL] [knitter] Error: /home/marco/Development/DomainDrivenConsulting/dogen/projects/sml/src/types/merger.cpp(120): Throw in function void dogen::sml::merger::update_references()
Dynamic exception type: N5boost16exception_detail10clone_implIN5dogen3sml13merging_errorEEE
std::exception::what: Cannot find target dependency: dynamic
[P12tag_workflow] = Code generation failure.
</pre>


<p>
What this is trying to say is that the <code>dynamic</code> model is not being
referenced. We should make this a bit more obvious because it would be
very difficult for the user to figure out what type is bringing in
this dependency. It would make more sense to say "type X requires
model Y, which is not part of the list of reference models" or
something along these lines. However, for this we need to load all the
available models - however this is defined. We could also take an
approach similar to compilers:
</p>

<pre class="example">
The type or namespace name 'Tasks' does not exist in the namespace 'System.Threading' (are you missing an assembly reference?)
</pre>


<p>
And for models:
</p>

<pre class="example">
Could not load file or assembly 'TreemapControl, Version=1.0.1.38, Culture=neutral, PublicKeyToken=3f6121a52ebf7c82' or one of its dependencies. The system cannot find the file specified.Could not load file or assembly 'TreemapControl, Version=1.0.1.38, Culture=neutral, PublicKeyToken=3f6121a52ebf7c82' or one of its dependencies. The system cannot find the file specified.
</pre>


<p>
We could also add the search path, e.g. looked in directories X, Y and
Z.
</p>
</div>
</div>

<div id="outline-container-orgc20b00a" class="outline-4">
<h4 id="orgc20b00a"><span class="section-number-4">3.3.99</span> Improve error messages on empty meta-data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-99">
<p>
Consider a meta-data entry without a value, in a dia diagram (model
note):
</p>

<pre class="example">
#DOGEN dia.comment'
</pre>


<p>
At present the following error is triggered:
</p>

<pre class="example">
2014-09-27 10:07:32.761795 [ERROR] [dia_to_sml.comments_parser] Expected separator on KVP.
</pre>


<p>
This provides very little context of what went wrong. Also, we should
consider allowing for features that have no value, where the value is
assumed to be true. For cases like comment it would make life
easier. This may be good for boolean types with implied value
(e.g. presence means true). However on read we should capture the fact
that no value was supplied and then further down the processing
pipeline handle the defaulting to true.
</p>
</div>
</div>

<div id="outline-container-org7682248" class="outline-4">
<h4 id="org7682248"><span class="section-number-4">3.3.100</span> Improve error message for blank types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-100">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want a clear error message when I forget
to supply a type for a property so that I don't spend ages searching
the diagram for the missing type.
</p>

</blockquote></div>

<p>
If the user does not supply a type at all in Dia, dogen spits out a
message that is not very informative:
</p>

<pre class="example">
Error: Failed to parse string: .
</pre>


<p>
The log file is not much better:
</p>

<pre class="example">
2014-09-06 16:11:54.143249 [ERROR] [dia_to_sml.identifier_parser] Failed to parse string:
2014-09-06 16:11:54.150595 [FATAL] [knitter] Error: /home/marco/Development/DomainDrivenConsulting/dogen/projects/dia_to_sml/src/types/identifier_parser.cpp(198): Throw in function sml::nested_qname dogen::dia_to_sml::identifier_parser::parse_qname(const std::string &amp;)
Dynamic exception type: N5boost16exception_detail10clone_implIN5dogen10dia_to_sml13parsing_errorEEE
std::exception::what: Failed to parse string:
[P12tag_workflow] = Code generation failure.
</pre>


<p>
We should instead mention that the string was empty or blank. We also
need to provide the property and class that contained this string. To
reproduce this problem create an enumeration but remove the
<code>enumeration</code> stereotype. This is a very common error when creating
enumerations (forgetting to set the stereotype). We should supply some
kind of clue ("did you mean to set the stereotype to enumeration?").
</p>
</div>
</div>

<div id="outline-container-org281c9bd" class="outline-4">
<h4 id="org281c9bd"><span class="section-number-4">3.3.101</span> Error in log files when reading in Dia model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-101">
<p>
For some reason the log file is full of errors like this:
</p>

<pre class="example">
2014-01-20 18:28:31.219549 [ERROR] [dia_to_sml.processor] Did not find expected attribute value type: composite
</pre>


<p>
Presumably the errors are not fatal as code generation still
works. Investigate the errors and tidy-up the log. Since the errors
are not fatal we should at least downgrade them to warnings.
</p>
</div>
</div>

<div id="outline-container-org3224a2b" class="outline-4">
<h4 id="org3224a2b"><span class="section-number-4">3.3.102</span> Improve error messages for unconnected objects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-102">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to know exactly which object is not
connected correctly so that I can fix it.
</p>

</blockquote></div>

<p>
At present when a Dia object is not connected we get the following
error message to std out:
</p>

<pre class="example">
Error: Expected 2 connections but found: 1. See the log file for details.
</pre>


<p>
The log file is a bit more verbose but still not particularly helpful:
</p>

<pre class="example">
2014-01-23 08:25:28.115363 [ERROR] [dia_to_sml.processor] Expected 2 connections but found: 1
2014-01-23 08:25:28.118718 [FATAL] [dogen] Error: /home/marco/Development/kitanda/dogen/projects/dia_to_sml/src/types/processor.cpp(166): Throw in function dogen::dia_to_sml::processed_object dogen::dia_to_sml::processor::process(const dogen::dia::object&amp;)
Dynamic exception type: N5boost16exception_detail10clone_implIN5dogen10dia_to_sml16processing_errorEEE
std::exception::what: Expected 2 connections but found: 1
[P12tag_workflow] = Code generation failure.
</pre>


<p>
We should try to at least name the object that has the one connection
to make the user's life easier.
</p>
</div>
</div>

<div id="outline-container-org3df49e7" class="outline-4">
<h4 id="org3df49e7"><span class="section-number-4">3.3.103</span> Code coverage does not work for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-103">
<p>
It seems that using NUnit and OpenCov does not work. The main reason
appears to be the use of shadow copying, which is no longer optional
on NUnit 3.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Ullink/gradle-opencover-plugin/issues/1">https://github.com/Ullink/gradle-opencover-plugin/issues/1</a></li>
<li><a href="https://github.com/codecov/example-csharp/blob/master/appveyor.yml">https://github.com/codecov/example-csharp/blob/master/appveyor.yml</a></li>
<li><a href="https://www.appveyor.com/blog/2017/03/17/codecov/">https://www.appveyor.com/blog/2017/03/17/codecov/</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7bbf53e" class="outline-4">
<h4 id="org7bbf53e"><span class="section-number-4">3.3.104</span> ODB linking is incorrect for generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-104">
<p>
At present we are adding the libraries in the test instead of the
model using ODB. The following should be part of the generated code:
</p>

<pre class="example">
${Boost_LIBRARIES}
${ODB_PGSQL_LIBRARIES}
${ODB_SQLITE_LIBRARIES}
${ODB_BOOST_LIBRARIES}
${ODB_LIBODB_LIBRARIES}
${PostgreSQL_LIBRARIES}
${OPENSSL_LIBRARIES}
resolv
${SQLite3_LIBRARY}
</pre>


<p>
The same problem applies to boost linking.
</p>
</div>
</div>

<div id="outline-container-org91971f4" class="outline-4">
<h4 id="org91971f4"><span class="section-number-4">3.3.105</span> Inheriting from oneself causes segfault&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-105">
<p>
If you set an object to inherit from itself, say via metadata:
</p>

<pre class="example">
#DOGEN masd.generalization.parent=in_memory_weaver
</pre>


<p>
Dogen segfaults due to recursion. We need to test this via UML
inheritance as well.
</p>
</div>
</div>

<div id="outline-container-orgf767fe5" class="outline-4">
<h4 id="orgf767fe5"><span class="section-number-4">3.3.106</span> Nested external model path results in strange references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-106">
<p>
Note: we have probably already implemented a solution for this, need
to check the resolver.
</p>

<p>
The external model path does not contribute to path resolution in a
model. Up til now that has actually been a feature; it would have been
annoying to have to dype <code>dogen::</code> on every type for every
model. Instead, we refer to say <code>dogen::a::b</code> as simply <code>a::b</code> in all
models that use <code>a</code>. However this masks a deeper problem: this is not
the desired behaviour at all times. We saw this problem when we
created multiple models under dynamic: <code>dynamic::schema</code> and
<code>dynamic::expansion</code>. In this case, users of these models referred to
them as <code>schema</code> and <code>expansion</code> respectively, and this was not
ideal. In general:
</p>

<ul class="org-ul">
<li>external module path should contribute to references just like
internal module path does - there should be no difference;</li>
<li>dogen should be clever enough to determine if two models share a
top-level namespace (regardless if it was obtained from the external
or internal module path) that there is no need to have an absolute
path. So in the case of <code>dogen</code>, since every model has <code>dogen</code> as
their external module path, according to this rule we should not
have to type it.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbdbf061" class="outline-4">
<h4 id="orgbdbf061"><span class="section-number-4">3.3.107</span> Facet enablement and model references is buggy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-107">
<p>
At present we are processing enablement as part of the
post-processing. This means that we are using the target model's
annotation profile in order to determine the facet enablement. This
can cause problems as follows: say we enable hashing on a model via
the model profile of M0. We then consume that model as a reference and
disable hashing on M1. When processing types from M0 for M1 we will
disable hashing for them as well. Thus, no includes for hashing will
be generated even if a hash map is used.
</p>

<p>
Actually this is not quite right. We are expanding annotations at the
external model transform level; this means the enablement on the
reference must be correct. However, somehow we seem to be looking at
the element on the target model when deciding to include the hash file
from reference model.
</p>
</div>
</div>

<div id="outline-container-orgd32bf01" class="outline-4">
<h4 id="orgd32bf01"><span class="section-number-4">3.3.108</span> Serialisation support for C++-11 specific containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-108">
<p>
We can't add <code>std::array</code> or <code>std::forward_list</code> because there is no
serialisation support in boost 1.49. A mail was sent to the list to
see if this has changed in latter versions:
</p>

<p>
<a href="http://lists.boost.org/boost-users/2012/11/76458.php">http://lists.boost.org/boost-users/2012/11/76458.php</a>
</p>

<p>
However, it should be pretty trivial to generate serialisation code by
hand at least for <code>std::array</code> or to use a solution similar to
<code>std::unordered_map</code>.
</p>
</div>
</div>

<div id="outline-container-org52e8072" class="outline-4">
<h4 id="org52e8072"><span class="section-number-4">3.3.109</span> Shared pointers to built-in types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-109">
<p>
At present we do not support shared pointers to built-in types. This
is because they require special handling in serialisation. See:
</p>

<p>
<a href="http://boost.2283326.n4.nabble.com/Serialization-of-boost-shared-ptr-lt-int-gt-td2554242.html">http://boost.2283326.n4.nabble.com/Serialization-of-boost-shared-ptr-lt-int-gt-td2554242.html</a>
</p>

<p>
We probably need to iterate through all the nested types and find out
if there is a shared pointer to built-in; if there is, put in:
</p>

<pre class="example">
// defined a "special kind of integer"
BOOST_STRONG_TYPEDEF(int, tracked_int)

// define serialization for a tracked int
template&lt;class Archive&gt;
void serialize(Archive &amp;ar, tracked_int &amp; ti, const unsigned int version){
    // serialize the underlying int
    ar &amp; static_cast&lt;int &amp;&gt;(ti);
}
</pre>
</div>
</div>

<div id="outline-container-org135decd" class="outline-4">
<h4 id="org135decd"><span class="section-number-4">3.3.110</span> Generate ORM tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-110">
<p>
We do not seem to be testing the generated ODB code. We don't need to
test ODB per se, but we should at least have some sanity checks that
test CRUD functionality.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>for this we need a "masd database".</li>
<li>tests should only trigger if postgres or some other relational
database is detected.</li>
<li>if foreign keys are used we need to detect them and ensure we
populate the data accordingly.</li>
</ul>
</div>
</div>

<div id="outline-container-org2de8e1e" class="outline-4">
<h4 id="org2de8e1e"><span class="section-number-4">3.3.111</span> Add warning for unused references&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-111">
<p>
It would be nice if we could figure out if the user has added some
references to a model that are not required. This could be done as a
byproduct of resolution. However, we need to be careful when we
introduce two-passes as we may use a model for say profiles or
concepts but nothing else. One way of addressing this is to have a
container of "used references"; whenever we find a type from a
reference, we add that reference to the list. In the end we diff that
container against the global refs.
</p>
</div>
</div>

<div id="outline-container-org7326263" class="outline-4">
<h4 id="org7326263"><span class="section-number-4">3.3.112</span> Additional validation rules for coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-3-112">
<p>
Now that we have introduced the basic validation infrastructure
(<a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_95.org">sprint 95</a>), we should start adding more and more checks. This story
keeps track of all ideas around validation. We should convert these
ideas into stories and add them as we go along.
</p>

<p>
<b>Dia level checks</b>:
</p>

<ul class="org-ul">
<li>exceptions and enumerations can't inherit</li>
<li>exceptions shouldn't have properties.</li>
</ul>

<p>
<b>Injection level checks</b>
</p>

<ul class="org-ul">
<li>ensure all attributes are unique, all element names are unique
(qualified with the package).</li>
</ul>

<p>
<b>Intermediate model checks</b>:
</p>

<ul class="org-ul">
<li>validate feature template names: We need to ensure the template
names are valid identifiers in C++.</li>
<li>ensure all models part of a model set have compatible versions. For
example, referencing a C++ 98 model from a C++ 11 model (or
vice-versa) should result in an error.</li>
<li>detect cycles in references. Done, just needs warnings/errors framework.</li>
<li>detect references to self. Done, just needs warnings/errors framework.</li>
<li>if a model is making use of boost serialisation and it has leaves, a
warning should come up stating that a type registrar is needed. The
check should also take into account if a model is referencing models
which have registrars.</li>
<li>if a meta-model element is requested for a technical space which has
no formatters, we should issue a warning. For example, registrar on
a C# model.</li>
<li>For C# models: attribute that start with lower case will cause
problems because the property name will match the argument name,
resulting in warnings in the complete constructor (argument assigned
to itself). A simple validation check is to error if a user add an
attribute that starts with lower case in C#.</li>
<li>enumeration values should be valid according to its type. Basically
cast to int.</li>
<li>if <code>use_implementation_defined_underlier</code> is true then
<code>underlying_element</code> must be empty and vice-versa</li>
<li>primitive <code>underlying_element</code> must not be empty.</li>
<li>if <code>use_implementation_defined_enumerator_values</code> is true then
enumerator's value must be empty.</li>
<li>enumeration must have at least one enumerator. warning?</li>
<li>enumerations cannot sometimes define values and sometimes leave them
empty. They must all be either provided or all left blank.</li>
<li>external module path of the model matches all objects, etc in
current model.</li>
<li>documentation does not have non-printable characters.</li>
<li>number of type arguments is consistent with objects type.</li>
<li>Test relationships between objects and other meta types: We should
validate that objects are only related to other objects - e.g. they
cannot inherit from exception or enumeration or vice-versa. Add
tests for this.</li>
<li>Its not possible to be immutable and fluent.</li>
<li>it is not possible to be immutable and be in an inheritance
relationship. FIXME: why is that?</li>
<li>user models cannot have stereotype of "builtins". Actually do we
even need to validate this since it would do nothing.</li>
<li>we don't support generic types so we should throw if a user attempts
to use them.</li>
<li>a type marked as final cannot have descendants.</li>
<li>types in global namespace must have an empty location.</li>
<li>if model module path is empty, location must also be empty.</li>
<li>check the number of type parameters in the type definition and
ensure that all name trees have the expected number of type
parameters.</li>
<li>properties of types in other models result in dependencies.</li>
<li>concepts that don't refine must have at least one property (or
method). Maybe just warn?</li>
<li>issue error when a property is a value of an abstract class</li>
<li>properties exist in merged model.</li>
<li>vistor is only supported at the base class level: due to
implementation constraints, we only support visitable at the base
class level. Add an exception if users attempt to use visitable
stereotype in a class that has parents. Note: is this true? We are
using derived visitable in C++ model.</li>
<li>there must be at least one element for a given id with
<code>is_element_extension</code> set to false.</li>
<li>for interfaces, etc: if a user overloads a method, check to see if
arguments to the method with the same name are in the same order for
all overloads (framework design guidelines p. 124).</li>
</ul>

<p>
Existing validation code:
</p>

<pre class="example">
if ((o.is_parent() || o.is_child()) &amp;&amp; p.is_immutable())  {
    BOOST_LOG_SEV(lg, error) &lt;&lt; immutabilty_with_inheritance
                             &lt;&lt; o.name().id();

    BOOST_THROW_EXCEPTION(
        transformation_error(immutabilty_with_inheritance +
            o.name().id()));
}
</pre>


<pre class="example">
BOOST_AUTO_TEST_CASE(inheritance_with_immutability_throws) {
    SETUP_TEST_LOG_SOURCE("inheritance_with_immutability_throws");
    auto c(mock_context(model_name));

    const auto po(mock_processed_object_factory::make_generalization());
    const auto con(po[0].connection());
    BOOST_REQUIRE(con);
    const auto parents = std::list&lt;std::string&gt; { con-&gt;first };
    c.child_id_to_parent_ids().insert(std::make_pair(con-&gt;second, parents));

    transform(c, {po[1]});

    auto po1(po[2]);
    po1.stereotype(immutable_stereotype);
    const auto op1(mock_profile(po1));
    contains_checker&lt;transformation_error&gt; cc(immutability_inheritance);
    BOOST_CHECK_EXCEPTION(transform(c, po1, op1), transformation_error, cc);

    c.child_id_to_parent_ids().clear();
    auto po2(po[1]);
    po2.stereotype(immutable_stereotype);
    const auto op2(mock_profile(po2));
    BOOST_CHECK_EXCEPTION(transform(c, po2, op2), transformation_error, cc);
}
</pre>


<ul class="org-ul">
<li>enumerators with values:
<ul class="org-ul">
<li>they are unique and valid according to enumeration type;</li>
<li>they do not class with invalid value.</li>
</ul></li>
</ul>

<p>
<b>ORM</b>
</p>

<ul class="org-ul">
<li>if there are ODB options, check that there are common ODB options
too.</li>
</ul>

<p>
<b>Decoration elements</b>
</p>

<ul class="org-ul">
<li>modeline groups must be defined at the top-level.</li>
<li>modeline groups cannot contain any modeling element other than modelines.</li>
<li>modelines must be defined inside of modeline groups.</li>
<li>licences and generation markers must be defined at the top-level.</li>
</ul>

<p>
<b>Serialisation</b>
</p>

<ul class="org-ul">
<li>if using boost serialisation with a model that has inheritance, the
registrar should be present.</li>
</ul>

<p>
<b>Other</b>
</p>

<ul class="org-ul">
<li>Check that all header guards generated for a given model are
unique. We've had cases where a class with a prefix (say
<code>variability_x</code>) and a class in a namespace (say <code>variability::x</code>)
resolve to exactly the same header guard (say
<code>VARIABILITY_X_HPP</code>). We could easily obtain all headers in a model,
sort them and unique them. If there are duplicates, we should error
or warn.</li>
</ul>

<p>
<b>Features</b>
</p>

<ul class="org-ul">
<li>that formatter fields are not duplicated on simple name.</li>
<li>fields are not duplicated on qualified name.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Add warning support for validation</b>
</p>

<p>
Once we implement a validator, we will soon run into warnings: cases
where the user has done something silly but we still want to code
generate. These are best handled as warnings rather than errors.
</p>

<p>
This story keeps track of things we think should be a warning.  List
of known warnings:
</p>

<ul class="org-ul">
<li>unconnected dia object</li>
<li>comment greater than 80 columns</li>
</ul>

<p>
We will probably soon need a way to enable/disable warnings. We could
use a similar scheme as GCC: <code>-Wname</code> and <code>-Wno-name</code>.
</p>

<p>
<b>Warn if value or entity has methods</b>
</p>

<p>
We should issue a warning if a user defines methods in value or entity
objects as its most likely by mistake.
</p>
</div>
</div>

<div id="outline-container-org39d3dc3" class="outline-4">
<h4 id="org39d3dc3"><span class="section-number-4">3.3.113</span> Report validation errors like compilers do&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-113">
<p>
It would be very useful to output validation errors like a compiler,
referencing the original file from where the meta-element was defined
and any other additional information the user may find useful. We
could also have "reporting themes" such as visual studio or
GCC. Finally, we should support validation warnings, using the same
conventions as compilers (-Wall, etc). Though perhaps these are better
defined as part of the metamodel rather than command-line arguments.
</p>

<p>
We should implement this via <code>boost::error_info</code>, by adding file name,
line and column everywhere for all validation rules.
</p>
</div>
</div>

<div id="outline-container-orgda79b46" class="outline-4">
<h4 id="orgda79b46"><span class="section-number-4">3.3.114</span> Check for incompatibility between input language and kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-114">
<p>
At present it is possible to have a model with input language of say
C++ but with the C# backend enabled. We should throw if the input
language is incompatible with the enabled kernels.
</p>

<p>
This explanation has bit rotted a bit and needs to be revisited:
</p>

<p>
Sadly this is not trivial. This is because quilt only sees the mapped
models; thus as far as knit is concerned, we ask for the input
language (e.g. c++) and there is an enabled kernel for it. We don't
look at it from the enabled kernel's perspective (e.g. "C# is enabled,
why is there no input language for it?"). We could have a method in
quilt that returns all enabled kernels; we could then look at all
models we are going to build and if there is a mismatch we can
throw. But extracting the <code>configuration_factory</code> out of quilt
workflow is not going to be easy without screwing up the API.
</p>
</div>
</div>

<div id="outline-container-org99adef0" class="outline-4">
<h4 id="org99adef0"><span class="section-number-4">3.3.115</span> Improve comments on reference implementation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-115">
<p>
At present it is very difficult to understand what each model and/or
each type does in the reference implementations. We need to add some
comments to make it more obvious.
</p>
</div>
</div>

<div id="outline-container-org83957fe" class="outline-4">
<h4 id="org83957fe"><span class="section-number-4">3.3.116</span> Spirit: Improve error reporting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-116">
<p>
At present when the parser fails we give the user no idea as to why it
failed; we just return the failed state. In theory we should be
reporting errors:
</p>

<pre class="example" id="orgdb1a181">
        on_error&lt;fail&gt;
            (
                type_name,
                std::cout &lt;&lt; val("Error! Expecting ")
                &lt;&lt; _4                             // what failed?
                &lt;&lt; val(" here: \"")
                &lt;&lt; construct&lt;std::string&gt;(_3, _2) // iterators to error-pos, end
                &lt;&lt; val("\"")
                &lt;&lt; std::endl
                );
</pre>

<p>
In practice this never does anything.
</p>

<p>
Requirements:
</p>

<ul class="org-ul">
<li>get the <code>on_error</code> expression to trigger when an error occurs</li>
<li>raise an exception with the contents that we are sending to
std::cout at present.</li>
</ul>
</div>
</div>

<div id="outline-container-org77a17fa" class="outline-4">
<h4 id="org77a17fa"><span class="section-number-4">3.3.117</span> Spirit: replace the legacy parser with the Klaus parser&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-117">
<p>
Klaus created a new parser for us, but it was never integrated and
replaced the legacy parser. It should handle errors a bit
better. However, IIRC he tried to make a parser that was able to
handle more of the C++ type definition, which is no longer a
requirement - we just need to be able to support native arrays. We
need to review his code and integrate it.
</p>
</div>
</div>

<div id="outline-container-org456ed59" class="outline-4">
<h4 id="org456ed59"><span class="section-number-4">3.3.118</span> Spirit: Add support for "native" arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-118">
<p>
At present our parser does not support arrays such as:
</p>

<pre class="example" id="org1eb7f2f">
int[50];
</pre>

<p>
This should result on a name with a size associated with it. The
parser cannot cope with this. Ideally one should be able to declare a
const for the size on the class too:
</p>

<pre class="example" id="orgbba9827">
            static const int maxLimit = 50;
            int objects[maxLimit];
</pre>

<p>
So that we'd just recall the size parameter as a string in the name
tree rather than just expect it to be an integer.
</p>
</div>
</div>

<div id="outline-container-orga278daf" class="outline-4">
<h4 id="orga278daf"><span class="section-number-4">3.3.119</span> Add test with smart pointer in base class&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-119">
<p>
At present we have the following helper formatters registered against
SmartPointer:
</p>

<pre class="example">
{
  "quilt.cpp.types.class_implementation_formatter": [
    "&lt;quilt.cpp.types&gt;&lt;smart_pointer_helper&gt;",
    "&lt;quilt.cpp.io&gt;&lt;smart_pointer_helper&gt;"
  ]
}
</pre>


<p>
This should have caused something to break. It didn't because we don't
seem to have a test case with a smart pointer on the base class. This
raises the interesting point: do we ever need more than one helper for
a given family and a given file formatter? If so, we should change it
from a list to a single shared pointer.
</p>

<p>
Interestingly, for AssociativeContainer we have:
</p>

<pre class="example">
"AssociativeContainer": [
  {
    "quilt.cpp.types.class_implementation_formatter": [
      "&lt;quilt.cpp.io&gt;&lt;associative_container_helper&gt;"
    ]
  },
  {
    "quilt.cpp.io.class_implementation_formatter": [
      "&lt;quilt.cpp.io&gt;&lt;associative_container_helper&gt;"
    ]
  },
</pre>
</div>
</div>

<div id="outline-container-org0574d77" class="outline-4">
<h4 id="org0574d77"><span class="section-number-4">3.3.120</span> Improve error reporting around JSON&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-120">
<p>
At present when we break the JSON we get errors like so:
</p>

<pre class="example">
Error: Failed to parse JSON file&lt;unspecified file&gt;(75): expected object name.
</pre>


<p>
These are not very useful in diagnosing the problem. In the log file
we do a bit better:
</p>

<pre class="example">
2015-03-30 12:02:12.897202 [DEBUG] [dynamic.schema.json_hydrator] Parsing JSON file: /home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/../data/fields/cpp.json
2015-03-30 12:02:12.897216 [DEBUG] [dynamic.schema.json_hydrator] Parsing JSON stream.
2015-03-30 12:02:12.897450 [ERROR] [dynamic.schema.json_hydrator] Failed to parse JSON file: &lt;unspecified file&gt;(75): expected object name
2015-03-30 12:02:12.897515 [FATAL] [knitter] Error: /home/marco/Development/DomainDrivenConsulting/dogen/projects/dynamic/schema/src/types/json_hydrator.cpp(226): Throw in function std::list&lt;field_definition&gt; dogen::dynamic::schema::json_hydrator::hydrate(std::istream &amp;) const
Dynamic exception type: N5boost16exception_detail10clone_implIN5dogen7dynamic6schema15hydration_errorEEE
std::exception::what: Failed to parse JSON file&lt;unspecified file&gt;(75): expected object name
[P12tag_workflow] = Code generation failure.
</pre>


<p>
But it requires a lot of context to know whats going on. We need to
append more details to the exception. We should look at this after we
move to RapidJSON.
</p>

<p>
Merged stories:
</p>

<p>
<b>Duplicate fields in JSON result in non-intuitive errors</b>
</p>

<p>
By mistake we added the same field twice in JSON:
</p>

<pre class="example">
"extensions" : {
    "cpp.types.class_header_formatter.inclusion_directive" : "&lt;boost/property_tree/ptree.hpp&gt;",
    "cpp.serialization.class_header_formatter.inclusion_directive" : "&lt;boost/property_tree/ptree_serialization.hpp&gt;",
    "cpp.io.class_header_formatter.inclusion_directive" : "&lt;boost/property_tree/json_parser.hpp&gt;",
    "cpp.io.class_implementation_formatter.inclusion_directive" : "&lt;boost/property_tree/json_parser.hpp&gt;",
    "cpp.io.class_implementation_formatter.inclusion_directive" : "&lt;boost/property_tree/json_parser.hpp&gt;",
    "cpp.hash.class_header_formatter.inclusion_required" : false
</pre>


<p>
The resulting error message was not particularly helpful:
</p>

<pre class="example">
2015-06-17 13:56:06.658500 [DEBUG] [sml.json_hydrator] Processing type: &lt;boost&gt;&lt;property_tree&gt;&lt;ptree&gt;
2015-06-17 13:56:06.658519 [ERROR] [dynamic.field_instance_factory] Expected at most one element
</pre>
</div>
</div>

<div id="outline-container-org6fa842d" class="outline-4">
<h4 id="org6fa842d"><span class="section-number-4">3.3.121</span> Failed facet dependencies should be treated as errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-121">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to know when I try to use a
non-supported facet from a system type so that I don't generate
non-compilable code.
</p>

</blockquote></div>

<p>
if a facet is not supported in a system module and the user tries to
make use of it, we should error. The user must then go and disable
explicitly the facet on the affected object via the meta data. We
should not silently disable facets.
</p>
</div>
</div>

<div id="outline-container-org01186b5" class="outline-4">
<h4 id="org01186b5"><span class="section-number-4">3.3.122</span> Ensure an error info tag is not set already before we set it&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-122">
<p>
Now that we will start making use of error info tags in anger, one
problem we have spotted is that some times we reset the same tag:
i.e. when an exception has been thrown, we do not want to set the same
tag multiple times because it overwrites it. There should be a way to
either allow multiple bits of information to be associated with the
same tag, or a way to check if the tag has been already set. But if it
is, what then? We can't throw.
</p>
</div>
</div>

<div id="outline-container-orgb15c229" class="outline-4">
<h4 id="orgb15c229"><span class="section-number-4">3.3.123</span> Add more validation to stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-123">
<p>
Missing validation:
</p>

<ul class="org-ul">
<li>check that directive an has end marker.</li>
<li>start control block marker inside of an inline control block.</li>
<li>profile cannot have the same type instantiated more than once.</li>
<li>type definition cannot define the same type more than once.</li>
<li>directives cannot be used in lines with mixed content;</li>
<li>variables cannot be used in lines with mixed content;</li>
</ul>
</div>
</div>

<div id="outline-container-orgda72507" class="outline-4">
<h4 id="orgda72507"><span class="section-number-4">3.3.124</span> Add tests for external and model modules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-124">
<p>
At present we do not have tests exercising different combinations of
external and model modules.
</p>

<p>
Tests:
</p>

<ul class="org-ul">
<li>0-3 levels of external modules</li>
<li>1-3 levels of model modules</li>
</ul>
</div>
</div>

<div id="outline-container-org5d92a08" class="outline-4">
<h4 id="org5d92a08"><span class="section-number-4">3.3.125</span> Add test for parent with no derived classes on the same model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-125">
<p>
We need to check that when a parent that has no leaves on its own
model generates correct code. The most likely problem is that the
parent will not be marked as abstract.
</p>
</div>
</div>

<div id="outline-container-org91a290e" class="outline-4">
<h4 id="org91a290e"><span class="section-number-4">3.3.126</span> Add tests to inheritance test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-126">
<p>
We should make sure types' use of IO kicks in via the inheritance test
model. For this we need a base class with associative containers, etc
and a derived class.
</p>
</div>
</div>

<div id="outline-container-orgf606494" class="outline-4">
<h4 id="orgf606494"><span class="section-number-4">3.3.127</span> Add tests to association model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-127">
<p>
We need a test for composition / recursion.
</p>
</div>
</div>

<div id="outline-container-orgd338ca8" class="outline-4">
<h4 id="orgd338ca8"><span class="section-number-4">3.3.128</span> Add tests to identifier parser with invalid names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-128">
<p>
We need to handle properly the following cases:
</p>

<ul class="org-ul">
<li>totally blank name.</li>
<li>template with angle brackets but nothing inside: <code>a&lt;&gt;</code>.</li>
<li>template with angle brackets, type and then a comma: <code>a&lt;b,&gt;</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org0f1cb1f" class="outline-4">
<h4 id="org0f1cb1f"><span class="section-number-4">3.3.129</span> Add tests for empty objects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-129">
<p>
This was mainly in the context of IO but could be useful for other
facets. Example:
</p>

<pre class="example">
class empty_model_generator {
public:
    typedef dogen::sml::model result_type;

public:
    result_type operator()() {
        dogen::sml::model r;
        return r;
    }
};
...
BOOST_AUTO_TEST_CASE(validate_io_for_empty_objects) {
    SETUP_TEST_LOG("validate_io_for_empty_objects");

    /* ensure we generate valid JSON for empty model. test was added
     * because empty property trees were not correct, but its valid on
     * its own right as we always use populated objects when testing
     * JSON.
     */
    // test_io&lt;empty_model_generator&gt;();
}
</pre>
</div>
</div>

<div id="outline-container-org2e5d9ad" class="outline-4">
<h4 id="org2e5d9ad"><span class="section-number-4">3.3.130</span> Cross package referencing tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-130">
<p>
Scenarios:
</p>

<ul class="org-ul">
<li>object in root refers to object in package: A =&gt; pkg1::B;</li>
<li>object in root refers to object in package inside of package: A =&gt;
pkg1::pkg2::B;</li>
<li>object inside of package refers to object inside of the same
package: pkg1::A =&gt; pkg1::B (must be qualified);</li>
<li>object in package refers to root object: pkg1::A =&gt; B;</li>
<li>object in package refers to object in other package: pkg1::A =&gt;
pkg2::B;</li>
<li>object in package refers to object in package in package: pkg1::A =&gt;
pkg1::pkg2::B;</li>
<li>object in package refers to object in other package in package: pkg1::A =&gt;
pkg2::pkg3::B;</li>
<li>object in package in package refers to object in package in package:
pkg1::pkg2::A =&gt; pkg3::pkg4::B.</li>
</ul>
</div>
</div>

<div id="outline-container-org1e907af" class="outline-4">
<h4 id="org1e907af"><span class="section-number-4">3.3.131</span> Add test model for disabling XML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-131">
<p>
At present we are not testing model generation with XML disabled.
</p>
</div>
</div>

<div id="outline-container-org13f21f9" class="outline-4">
<h4 id="org13f21f9"><span class="section-number-4">3.3.132</span> Add tests for disconnected connections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-132">
<p>
We should throw if a diagram has a disconnected inheritance or
composition relationship.
</p>

<p>
At present the error message for an inheritance object in dia which
has less than two connections is less than helpful:
</p>

<pre class="example">
2013-06-26 22:58:50.236488 [ERROR] [dia_to_sml.processor] Expected 2 connections but found: 1
2013-06-26 22:58:50.236917 [FATAL] [dogen] Error: /home/marco/Development/kitanda/dogen/projects/dia_to_sml/src/types/processor.cpp(166): Throw in function dogen::dia_to_sml::processed_object dogen::dia_to_sml::processor::process(const dogen::dia::object&amp;)
Dynamic exception type: boost::exception_detail::clone_impl&lt;dogen::dia_to_sml::processing_error&gt;
std::exception::what: Expected 2 connections but found: 1
[tag_workflow*] = Code generation failure.
</pre>


<p>
We should really try to detail which object ID failed, as well as
details of the connected object if possible, etc.
</p>
</div>
</div>

<div id="outline-container-orgb4c0b82" class="outline-4">
<h4 id="orgb4c0b82"><span class="section-number-4">3.3.133</span> Add run spec targets for each test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-133">
<p>
We could piggy back on the ctest functionality and add a target for
each test so one could <code>make enable_facet_domain</code> and <code>make
run_enable_facet_domain</code>. The targets need to be prefixed with module
name and test suite.
</p>
</div>
</div>

<div id="outline-container-orgb4b7835" class="outline-4">
<h4 id="orgb4b7835"><span class="section-number-4">3.3.134</span> Add specification comments to tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-134">
<p>
We started off by adding a technical specification as a doxygen
comment for a test but forgot to keep on doing it. Example:
</p>

<pre class="example">
/**
 * @brief It shall not be possible to create more terms than those
 * supported by a finite sequence, using std::generate_n.
 */
</pre>


<p>
This helps make the purpose of the test clearer when the name is not
sufficient.
</p>

<p>
This may not be required once we move over to Catch since the specs
become very readable.
</p>
</div>
</div>

<div id="outline-container-org8c0eb4c" class="outline-4">
<h4 id="org8c0eb4c"><span class="section-number-4">3.3.135</span> Create model with invalid built-in type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-3-135">
<p>
At present we are validating that all built-in types work but we don't
check that an invalid type doesn't work.
</p>
</div>
</div>
</div>

<div id="outline-container-orga8e28aa" class="outline-3">
<h3 id="orga8e28aa"><span class="section-number-3">3.4</span> Infrastructure</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Stories related to infrastructure improvements that we may or may not
achieve.
</p>
</div>

<div id="outline-container-org466ad7f" class="outline-4">
<h4 id="org466ad7f"><span class="section-number-4">3.4.1</span> Update the contributing to dogen doco&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
The MSSQL tools project has a great set of points on contributing. We
should merge most of them into our contributing doco. We should also
port it to org-mode.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/microsoft/sqltoolsservice">https://github.com/microsoft/sqltoolsservice</a></li>
</ul>
</div>
</div>

<div id="outline-container-org866a1ba" class="outline-4">
<h4 id="org866a1ba"><span class="section-number-4">3.4.2</span> Test cases show up as zero in report.ci&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
The <a href="https://report.ci/reports/gh/MASD-Project/dogen">report.ci</a> tool written by Klemens Morgenstern is now showing zero
test cases. According to Klemens:
</p>

<div class="epigraph"><blockquote>
<p>
I just checked, and the issue is that boost.test doesn't contain
passed test cases, only the suites. Since I now manually count them
(bc other test frameworks don't have it as a numerical value at the
end), it looks like it's zero. This is bad, but I dont want to spam
the report with "unnamed test case #42" either, so I'll probably need
to add a few more things, so it might take a bit.
</p>

<p>
In the meantime, you can add more information to your tests by setting
the log<sub>level</sub> &amp; report<sub>level</sub> of boost, report.ci will then also
generate annotations for passing
tests. <a href="https://www.boost.org/doc/libs/1_73_0/libs/test/doc/html/boost_test/utf_reference/rt_param_reference.html">https://www.boost.org/doc/libs/1_73_0/libs/test/doc/html/boost_test/utf_reference/rt_param_reference.html</a>
</p>

<p>
You can set a level to the badges (experiment here:
<a href="https://report.ci/badges">https://report.ci/badges</a>), the current default is `cases`, but you can
alternatively set it to `suites`, which gives you 8/8 or `checks`,
which counts the assertions (1901/1901).
</p>

<p>
Hope that helps, I also created an issue
<a href="https://github.com/report-ci/scripts/issues/16">https://github.com/report-ci/scripts/issues/16</a>
</p>

</blockquote></div>
</div>
</div>

<div id="outline-container-org6528b7a" class="outline-4">
<h4 id="org6528b7a"><span class="section-number-4">3.4.3</span> Upload release to github&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
At present we are manually uploading binaries on a release to
github. It would be nice to integrate this with CI.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/stefanbuck/ce788fee19ab6eb0b4447a85fc99f447">upload-github-release-asset.sh</a></li>
<li><a href="https://developer.github.com/v3/repos/releases/#upload-a-release-asset">Upload a release asset</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb8a8efc" class="outline-4">
<h4 id="orgb8a8efc"><span class="section-number-4">3.4.4</span> Consider adding support for kcov&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
In the past we used kcov and were very happy with it. However,
coveralls and codecov gave us a few problems so we ended up going to
llvm-cov. If we do decide to go back to kcov, look at commit
6cb01a132d.
</p>
</div>
</div>

<div id="outline-container-org14aaf39" class="outline-4">
<h4 id="org14aaf39"><span class="section-number-4">3.4.5</span> Add support for stack traces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-5">
<p>
At present when we throw we have very little context around the
exception. With recent versions of boost its possible to output a
stack trace. It would be nice to be able to do this on debug builds at
least.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_72_0/doc/html/stacktrace/getting_started.html#stacktrace.getting_started.exceptions_with_stacktrace">Exceptions with stacktrace</a></li>
</ul>
</div>
</div>

<div id="outline-container-org93d041e" class="outline-4">
<h4 id="org93d041e"><span class="section-number-4">3.4.6</span> Consider adding <code>ClangBuildAnalyzer</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-6">
<p>
Interesting clang tool:
</p>

<div class="epigraph"><blockquote>
<p>
Clang C/C++ build analysis tool when using Clang 9+ -ftime-trace. The
-ftime-trace compiler flag (see Aras' blog post or Clang 9 release
notes) can be useful to figure out what takes time during compilation
of one source file. This tool helps to aggregate time trace reports
from multiple compilations, and output "what took the most time"
summary[.]
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/aras-p/ClangBuildAnalyzer">https://github.com/aras-p/ClangBuildAnalyzer</a></li>
</ul>
</div>
</div>

<div id="outline-container-org364eceb" class="outline-4">
<h4 id="org364eceb"><span class="section-number-4">3.4.7</span> Add new c++ warnings to compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-7">
<ul class="org-ul">
<li><code>-Wunused-private-field</code>: Seems like this warning is not part of
<code>-Wall</code></li>
<li><code>-Winconsistent-missing-override</code>: new clang warning, probably 3.6.</li>
<li><code>-Wdocumentation</code>: clang doxygen warning.</li>
<li><code>-WExtra</code></li>
<li><code>-save-temps</code> <code>-Wextra</code> <code>-Wfloat-equal</code></li>
</ul>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="http://releases.llvm.org/5.0.0/tools/clang/docs/ReleaseNotes.html">Clang 5.0.0 Release Notes</a>, section "Improvements to Clangs
diagnostics".</li>
<li><a href="https://kristerw.blogspot.co.uk/2017/09/useful-gcc-warning-options-not-enabled.html">Useful GCC warning options not enabled by -Wall -Wextra</a></li>
<li><a href="http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/">Hardening C/C++ Programs: Part I  Stack Protector</a></li>
<li><a href="https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/">Recommended compiler and linker flags for GCC</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/grpux6/which_gcc_flags_do_you_use_often/">Which GCC flags do you use often?</a></li>
<li><a href="https://tobias.hieta.se/llvm11-release">LLVM 11.0.0 Released - Here are some highlights for C/C++
developers</a>: section on new warnings.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Consider enabling <code>-Wshadow</code></b>
</p>

<p>
We make use of shadowing on occasion so maybe this is why we disabled
this warning. Enable it and check to see what breaks.
</p>

<pre class="example">
# definition shadows another
# FIXME: causes too many problems.
# set(warning_flags "${warning_flags} -Wshadow")
</pre>


<p>
<b>Enable <code>maybe-uninitialized</code> warning</b>
</p>

<p>
This warning caused build breaks. The main problem seems to come from
boost variants using model types, which then rely on the variant's
swap function. This uses the move constructor. For some reason, the
compiler does not think the default move constructor is initialising
the member variables correctly. Not obvious why that would be.
</p>
</div>
</div>

<div id="outline-container-org6c7dd5b" class="outline-4">
<h4 id="org6c7dd5b"><span class="section-number-4">3.4.8</span> Investigate <code>modern-cpp-template</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-8">
<p>
This project seems to supply a very good base to use on our C++
projects: "A template for modern C++ projects using CMake,
Clang-Format, CI, unit testing and more, with support for downstream
inclusion."
</p>

<p>
In fact it seems there are quite a few of these. We need to find out
the differences between them.
</p>

<p>
Link:
</p>

<ul class="org-ul">
<li><a href="https://github.com/filipdutescu/modern-cpp-template">modern-cpp-template GH</a></li>
<li><a href="https://github.com/lefticus/cpp_starter_project">cpp<sub>starter</sub><sub>project</sub> GH</a>: A template CMake project to get you started
with C++ and tooling</li>
<li><a href="https://github.com/TheLartians/ModernCppStarter">ModernCppStarter GH</a>: Kick-start your C++! A template for modern C++
projects using CMake, CI, code coverage, clang-format, reproducible
dependency management and much more.</li>
</ul>
</div>
</div>

<div id="outline-container-org6f711e7" class="outline-4">
<h4 id="org6f711e7"><span class="section-number-4">3.4.9</span> Run ODB on nightlies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-9">
<p>
At present we are code-generating all code on dogen nightlies but we
are not running ODB. This means that if we have broken ODB pragma
generation, we will not find out until we manually run it. We should
run it as part of the "generate everything" approach in nightly.
</p>
</div>
</div>

<div id="outline-container-orge78d639" class="outline-4">
<h4 id="orge78d639"><span class="section-number-4">3.4.10</span> Check OSX packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-10">
<p>
We need to ensure OSX packages are still working. At present, the
build says:
</p>

<pre class="example">
FATALcould not find C++ runtime
</pre>


<p>
For this the problem appears to be that we are trying to add the C++
run time and not finding it. We need to test the OSX packages and see
if Dogen still works. If it does, remove this.
</p>

<pre class="example">
if(EXISTS "/usr/local/lib/i386/libstdc++.6.dylib")
    set (cpp_runtime_libs
        ${cpp_runtime_libs} "/usr/local/lib/i386/libstdc++.6.dylib")
    set (cpp_runtime_libs
        ${cpp_runtime_libs} "/usr/local/lib/i386/libgcc_s.1.dylib")
else()
    message(FATAL "could not find C++ runtime")
endif()
</pre>
</div>
</div>

<div id="outline-container-org6159b8e" class="outline-4">
<h4 id="org6159b8e"><span class="section-number-4">3.4.11</span> Move from doxygen to standardese&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-11">
<p>
We should try to use standardese to generate the documentation for
dogen. Seems easier to use and CMake friendly. Also, it seems more c++
compliant because it uses libclang.
</p>

<p>
Once the move is done, we should update dogen to generate comments in
either markup via a meta-data parameter (documentation markup?).
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/foonathan/standardese">https://github.com/foonathan/standardese</a></li>
</ul>
</div>
</div>

<div id="outline-container-org50c66d8" class="outline-4">
<h4 id="org50c66d8"><span class="section-number-4">3.4.12</span> Build dogen from docker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-12">
<ul class="org-ul">
<li>fix references to gcc etc</li>
<li>run:</li>
</ul>

<pre class="example">
docker exec -it zen_euclid env TERM=dumb
/home/marco/Development/DomainDrivenConsulting/dogen/build/scripts/build.linux.sh
Release 4 gcc /home/marco/local
</pre>


<p>
Merged stories:
</p>

<p>
<b>Build dogen docker images from travis</b>
</p>

<p>
We should build docker images with each commit into master.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://devblogs.microsoft.com/cppblog/using-multi-stage-containers-for-c-development/">Using multi-stage containers for C++ development</a></li>
<li><a href="https://github.com/GoogleCloudPlatform/cloud-builders/blob/master/bazel/Dockerfile">cloud-builders</a></li>
<li><a href="https://sebest.github.io/post/using-travis-ci-to-build-docker-images/">Using Travis.ci to build Docker images</a></li>
<li><a href="https://github.com/OpenSourceRisk/Engine/tree/master/tools/docker">ORE docker script</a></li>
<li><a href="https://giorgos.sealabs.net/build-and-test-against-docker-images-in-travis.html">Build and Test against Docker Images in Travis</a></li>
<li><a href="https://medium.com/travis-on-docker/triple-stage-docker-builds-with-go-and-angular-1b7d2006cb88">Triple-Stage Docker Builds with Go and Angular</a></li>
<li><a href="https://medium.com/travis-on-docker/multi-stage-docker-builds-for-creating-tiny-go-images-e0e1867efe5a">Multi-Stage Docker Builds for Creating Tiny Go Images</a></li>
<li><a href="https://github.com/gliderlabs/docker-alpine/issues/24">What is the alpine equivalent to build-essential?</a></li>
<li><a href="https://caveofcode.com/2017/03/continuous-delivery-to-kubernetes-with-travis-ci/">Continuous delivery to Kubernetes with Travis CI</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5d0746d" class="outline-4">
<h4 id="org5d0746d"><span class="section-number-4">3.4.13</span> Create a docker image for builds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-13">
<p>
GCP's cloud builde uses the idea of cloud-builder images. These
contain all of the basics required to build for a given language. Now,
we can't use their images directly as they do not have CMake, but it
does give us an interesting approach: we can create a MASD base build
image with:
</p>

<ul class="org-ul">
<li>clang, gcc</li>
<li>cmake</li>
</ul>

<p>
And then with it build vcpkg and build and install all of the deps. We
need to be careful not to push the build files (over 13 GB!). We can
then use this image for both Travis and the nightlies, as well as, one
day, cloud build.
</p>

<p>
While we're at it, we should also consider the points in the article below.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/GoogleCloudPlatform/cloud-builders/blob/master/bazel/Dockerfile">Bazel's cloud builder</a></li>
<li><a href="https://www.toptal.com/devops/better-google-cloud-continuous-deployment">A Better Approach to Google Cloud Continuous Deployment</a></li>
<li><a href="https://www.reddit.com/r/googlecloud/comments/9i093f/google_cloud_build_is_there_an_easier_way/">google cloud build is there an easier way?</a></li>
<li><a href="https://cloud.google.com/cloud-build/docs/configuring-builds/create-basic-configuration">Creating a basic build configuration file</a></li>
<li><a href="https://cloud.google.com/blog/products/devops-sre/cloud-build-brings-advanced-cicd-capabilities-to-github">Cloud Build brings advanced CI/CD capabilities to GitHub</a></li>
<li><a href="https://cloud.google.com/cloud-build/docs/quickstart-docker?hl=en_GB&amp;_ga=2.136964915.-2065564734.1572530049">Quickstart for Docker</a></li>
<li><a href="https://github.com/GoogleCloudPlatform/cloud-builders/blob/master/bazel/Dockerfile">Dockerfile</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgab28b70" class="outline-4">
<h4 id="orgab28b70"><span class="section-number-4">3.4.14</span> Linux and OSX binaries are not stripped&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-14">
<p>
At present our Linux and OSX build is much bigger than our windows
builds (3.8 MB on Windows vs 31 MB OSX and 15 MB on Linux). The
problem appears to be that we are not stripping the binaries on Linux.
</p>

<p>
We tried manually stripping:
</p>

<pre class="example">
 # strip the binaries in release
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -s")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s")
</pre>


<p>
However clang does not support this.
</p>

<p>
This may be related to the CMake build type of MinRelSize. Try doing a
build with this and see if the binaries are smaller. Actually this
does not work. We also tried:
</p>

<pre class="example">
CMAKE_INSTALL_DO_STRIP
</pre>


<p>
Which seems to have some effect but not exactly the same as a command
line <code>strip</code>. Supposedly this is a install level strip.
</p>

<p>
The only solution that appears to work is to add a custom command to
all targets in the build to strip:
</p>

<pre class="example">
add_custom_command(TARGET ${target} POST_BUILD
       COMMAND ${EMBREE_SIGN_FILE} $&lt;TARGET_FILE:${target}&gt;)
</pre>


<p>
However we need to be careful because stripping shared libraries may
cause problems. Also this is done for every build.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.technovelty.org/linux/stripping-shared-libraries.html">Stripping shared libraries</a></li>
<li><a href="https://cmake.org/pipermail/cmake/2012-March/049741.html">make install/strip does not strip static libraries</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc478a3f" class="outline-4">
<h4 id="orgc478a3f"><span class="section-number-4">3.4.15</span> Code coverage does not include odb files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-15">
<p>
The latest code coverage reports are excluding ODB files. We need to
understand why kcov is ignoring those.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://codecov.io/gh/MASD-Project/cpp_ref_impl/tree/master/projects/cpp_ref_impl.northwind">cpp<sub>ref</sub><sub>impl.northwind</sub> in codecov</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1af5ca9" class="outline-4">
<h4 id="org1af5ca9"><span class="section-number-4">3.4.16</span> Investigate the emblems used by Bit7z&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-3-4-16">
<p>
This project uses emblems for version, platform and compiler:
</p>

<p>
<a href="https://github.com/rikyoz/Bit7z">https://github.com/rikyoz/Bit7z</a>
</p>

<p>
This may or may not be useful to dogen.
</p>
</div>
</div>
<div id="outline-container-org887091f" class="outline-4">
<h4 id="org887091f"><span class="section-number-4">3.4.17</span> Mine <code>common-universal-cmake</code> for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-3-4-17">
<p>
This project seems interesting:
</p>

<ul class="org-ul">
<li><a href="https://github.com/polysquare/common-universal-cmake">common-universal-cmake</a></li>
</ul>

<p>
They seem to have added support for conan, appveyor, etc in an
extensible way. We need to figure out if anything can be nicked for
our infrastructure. This is also a useful template for when we
code-generate products.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>nice idea to create text files with all of the dependencies for the
different OSs (packages and repositories).</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org1791233" class="outline-2">
<h2 id="org1791233"><span class="section-number-2">4</span> V3 Release</h2>
<div class="outline-text-2" id="text-4">
<p>
Release goals:
</p>

<ul class="org-ul">
<li>define the Dogen ecosystem: <i>better tooling</i>. This involves all the
tooling around Dogen, including LSP support for both stitch and all
supported injectors (Dia, JSON, org-mode?).</li>
</ul>
</div>

<div id="outline-container-org9db674e" class="outline-3">
<h3 id="org9db674e"><span class="section-number-3">4.1</span> Candidates</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgbd35dae" class="outline-4">
<h4 id="orgbd35dae"><span class="section-number-4">4.1.1</span> Add support for SPDX licences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
We should try to create a model with all the SPDX licences, using
their naming conventions, format etc.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://spdx.org/licenses/">SPDX License List</a></li>
</ul>
</div>
</div>

<div id="outline-container-org12696f9" class="outline-4">
<h4 id="org12696f9"><span class="section-number-4">4.1.2</span> Tight integration of Dogen and <code>build2</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
In an ideal world, we should have a single command for managing the
entire life-cycle for a product. As luck would have it, all of the
packaging and building are already taken care of by Build2:
</p>

<ul class="org-ul">
<li><a href="https://build2.org/doc.xhtml">https://build2.org/doc.xhtml</a></li>
</ul>

<p>
Build2 has support for both the build system as well as the package
management. Were we to consume it as a library, we could integrate
this functionality into Dogen such that we wouldn't even create build
files at all. We would have dogen commands such as:
</p>

<pre class="example">
dogen new
dogen build
dogen test
dogen package
</pre>


<p>
And so on. We should copy these from <code>dotnet</code>. Then, internally, we
would call all of the required build2 commands to execute these. Dogen
would merely orchestrate build2 using the meta-information about the
product. Since not all libraries are on build2, we would only place
dogen libraries in build2 and use <code>vcpkg</code> as the supplier of all other
libraries. Actually, the disto could also supply these. The general
idea is that there are external packages in system directories. You
need to tell dogen about these. Everything else comes from Dogen's
integration with build2 (PDMs, etc). This also has the advantage that
build2 has support for modules.
</p>

<p>
The product transforms would then involve calls to download packages,
build, publish etc. Build2 does not know how to generate MSIs, DEBs
etc so there is still some work required to handle the final
packaging. Perhaps these can be encoded as post-processors within
Dogen. We could copy the code from CMake for this. Ideally you want a
C++ library for each type of package. We also need to take into
account the docker use case. Alternatively we could simply look at the
commands one runs to generate packages normally and literally encode
these into dogen as shell commands via boost process. Finally we
should publish the result into GitHub. The API keys etc should be
supplied to Dogen as environment variables. This approach is very
specific to C++ so we need to be careful we are not hard-coding too
many things that will not work for other languages.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we should also include building the documentation.</li>
<li>it should be possible to build docker images that have nothing
installed on it other than the product.</li>
<li>the build steps should take care to regenerate the components when
requested or to warn if the model is out of date if regeneration is
not requested.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new">dotnet new</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates">Custom templates for dotnet new</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd88ba87" class="outline-4">
<h4 id="orgd88ba87"><span class="section-number-4">4.1.3</span> Tighter vcpkg integration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
If the user requests, we should also generate a vcpkg project that is
a clone of vcpkg but builds all of the base dependencies and pushes
them to a known location (e.g. GCS). Then, the build steps should
first download from that known location and put it on the path. It
should be trivial to update the vcpkg clone, e.g.: user adds new vcpkg
dependency to the model; dogen updates the data file, user commits the
update, new vcpkg build is triggered and generates new vcpkg zip, with
a stamp. User updates model to point to the new stamp and pushes. Next
build will use new vcpkg libraries. Ideally vcpkg builds for all
supported platforms (this is requested in the product model).
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">vcpkg: Accelerate your team development environment with binary
caching and manifests</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf5b6521" class="outline-4">
<h4 id="orgf5b6521"><span class="section-number-4">4.1.4</span> Tighter integration of Dogen and Emacs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
There are a couple of areas where we could take advantage of code
generation and emacs:
</p>

<ul class="org-ul">
<li>running of tests: generate a org-mode test file which has a tree for
all configurations (Debug, Release) and compilers (gcc8, clang7,
etc). Then, for each of these we could have the test suites and the
tests. It runs all the tests and builds org-tables with the total
times. The runs are babel snippets. It updates the entries with the
status of passed, failed or not run. We need to find out how to run
all code snippets for a given subsection. We can use org properties
to supply the boost test variables such as log level etc. Because
Dogen knows of all of the test suites (e.g. these are declared as
model elements), it can parse them. We can also mark tests and test
suites as "generated" or "handcrafted".</li>
<li>files: Dogen could also output a generation model set for all types
in a product using a lisp like serialisation format. This could
somehow be read by emacs to give it visibility of all files dogen
knows off. Its still not clear what we'd do with it though. Some
kind of integration with projectile?</li>
<li>bookmarks: we could generate a org-mode file of bookmarks for all
key directories in a product such as say "coding include types",
etc. This can also use traditional emacs bookmarking format. It
should also include links to models.</li>
<li>run affected test suites: create a graph of includes per file such
that when you change a file, you can ask to run affected test
suites. This is computed based on the include graph. Won't work for
all technical spaces though.</li>
<li>build: it would be great if we could have the build scripts as
babel. However, instead of executing inside of org-mode, we want to
call the compilation buffer with it. This means we could have
bookmerks for all of the usual targets and even target combos such
as generate, convert and indent. For extra bonus points, once we
have code merging, we could have our own compilation targets added
manually.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=dljNabciEGg">Literate Devops with Emacs</a></li>
<li><a href="https://github.com/wlbr/cl-marshal">cl-marshal</a>: Simple and fast marshalling of Lisp datastructures.</li>
<li><a href="https://www.cliki.net/serialization">cliki</a>: Libraries to translate data structures to/from a format which
can be stored/retrieved</li>
</ul>
</div>
</div>

<div id="outline-container-org0710545" class="outline-4">
<h4 id="org0710545"><span class="section-number-4">4.1.5</span> User interface generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
we have not really thought about it that deeply but it should be
possible to use dogen to generate some basic uis, for example for wt.
</p>

<p>
It would be extremely interesting to see if we could encode these
meta-model elements within a org-mode document.
</p>

<p>
The gist of the approach is to add new meta-model elements to logic
that are on the UI domain. User models then instantiate those. We need
to look at the
</p>

<p>
links:
</p>

<ul class="org-ul">
<li><a href="http://plantuml.com/salt">salt</a>: plantuml wireframe language.</li>
<li><a href="https://en.wikipedia.org/wiki/Glade_Interface_Designer">Wikipedia: Glade Interface Designer</a>: GtkBuilder is the XML format
that the Glade Interface Designer uses to save its forms.</li>
<li><a href="https://gitlab.gnome.org/GNOME/gtk/blob/7601bca7587dd29bde3d1554e644a10ae6dafc18/gtk/gtkbuilder.rnc">RelaxNG schema for GTK builder XML</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Add support for GtkBuilder / Glade XML files</b>
</p>

<p>
There is nothing stopping us from using a GtkBuilder / Glade XML file
to do the boiler plate setup of the UI. With a bit more work one could
potentially even generate the bindings for a presentation model.
</p>
</div>
</div>

<div id="outline-container-org4fdffcd" class="outline-4">
<h4 id="org4fdffcd"><span class="section-number-4">4.1.6</span> Investigate support for automatic model updates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
For classes that are manually generated, it would be really nice if we
could update the properties of the class in the diagram from the
source code. This would work as follows:
</p>

<ul class="org-ul">
<li>user creates a class <code>x</code> and marks it as non-generatable; executes
dogen.</li>
<li>dogen creates the initial file and adds as much boilerplate as
possible. For instance if the user manually added properties or
operations to the class, dogen generates skeletons for these.</li>
<li>once the file exists, dogen will no longer touch it (see also the
merging code generation story, for a different take on this).</li>
<li>the user runs a second tool (the diagram updator, in need of a name)
which uses clang internally; it reads the diagram and looks for all
of the non-generatable classes; for each of these, it updates the
dia class with the properties found in the source file. Everything
else is left untouched.</li>
</ul>

<p>
This feature would be extremely powerful when in presence of many
other features such as mocking, remote method invocation, etc - the
user would have no effort at all in generating the
code. Implementation-wise we'd have to:
</p>

<ul class="org-ul">
<li>create an XML writer;</li>
<li>add write support for the dia model and ensure we generate valid dia
models;</li>
<li>integrate clang libraries with dogen;</li>
<li>create tool - or perhaps we should just have an "update diagram"
mode in dogen?</li>
</ul>
</div>
</div>

<div id="outline-container-orgda8a8b7" class="outline-4">
<h4 id="orgda8a8b7"><span class="section-number-4">4.1.7</span> Code generation as a service&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-7">
<p>
<b>Latest Understanding</b>
</p>

<ul class="org-ul">
<li>create a website using Wt: single screen with a few radio buttons to
upload files or edit/paste JSON input; command line options
available as text boxes.</li>
<li>create a service that receives requests for code generation and
returns a tarball/zip with the generated code: <code>jersey</code>. Archiving
libraries:
<ul class="org-ul">
<li><a href="https://github.com/libarchive/libarchive">https://github.com/libarchive/libarchive</a></li>
<li><a href="https://github.com/saboorian/moor">https://github.com/saboorian/moor</a></li>
<li><a href="https://github.com/do-m-en/libarchive_cpp_wrapper/">https://github.com/do-m-en/libarchive_cpp_wrapper/</a></li>
</ul></li>
<li>consider creating a simple HTTP wrapper around <code>jersey</code> just to see
how it works. <code>hem</code>.</li>
<li>two modes of operation: 1) upload a set of files, marking one as the
target 2) simple input box where user can type in JSON and code
generate.</li>
<li>tick boxes for main options.</li>
<li>potentially display a sample of one of the types.</li>
<li><code>jersey</code> receives a code generation request with the files as part of
the payload. This means we need to either save them down to a temp
directory and then pass paths over to knitter or we should have
support for different kinds of inputs such as streams in knitter.</li>
<li>save all requests and responses to a Postgres database for analysis
later (performance, bugs, etc). It would also be nice to have user
comments/complaints, perhaps linked to a user voice-like interface.</li>
<li>a more useful version of this service would allow: 1) ability add
types to existing models such as std and boost, or even create new
system models altogether. Some minimal UI for model editing would be
required, including meta-data support (includes, etc). Ideally, each
of these models should have an associated test model which would
automatically be updated with the new types so users could get
compilation feedback on their changes. 2) the ability to edit stitch
templates on the site or even the ability to add new facets or new
features for existing facets, and to code generate using those. Also
the ability to add helper methods for a given facet to a given
type. The testing for this could be achieved via a docker container
with an incremental build and simple validation (time out, etc). If
the user submits dodgy changes only the container would be
affected. Once built, the container is used for code generation. It
would be really nice to be able to test the template as one is
editing it, perhaps by choosing a type in a model; the user could
press "generate" at any time and see the file for that feature and
facet. Behind the scenes this is stitching, building, code
generating and then displaying the result for that one type. 3) the
ability to submit PR from within the site. Users log in using their
github accounts. They make their changes to a remote git repo. Using
github magic - in a similar way to how gitter forks and creates
PRs - when the user is happy enough with its changes, their are
submitted as a PR.</li>
<li>note that this advanced version would probably require having the
test models in JSON so that we could edit them via the site; it
would be cumbersome to add new types to a dia model
programmatically.</li>
<li>for extra bonus points, we should integrate with clang-format
generation sites such as <a href="http://zed0.co.uk/clang-format-configurator/">this one</a> and allow users to add their own
styles dynamically.</li>
<li>it should be possible to add more modelines/modeline groups,
licences, and even fields. This only makes sense if the fields are
totally dynamic such that the formatter could make use of the new
field directly. For this we would have to supply the ownership
hierarchy from within the stitch template.</li>
<li>we should create interesting end points such as: dia to json
conversion; merged model generation; merged model to code
generation, with language options; formatting; etc. Each is a
distinct end point.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we must cache system models so we don't reload them for every
request.</li>
<li>we should load per language (references?)</li>
<li>we need to verify the JSON input to avoid large blobs, buffer
overruns, etc.</li>
<li>support for workspaces so that users can save references.</li>
<li>system data: load once, reload on changes. Data "dirs" can be
stored/cached on redis or DB.</li>
<li>we need to move XML reader to memory.</li>
<li>hydrators need a data store scoped to the user.</li>
</ul>

<p>
<b>Previous Understanding</b>
</p>

<p>
One way of testing new functionality added to dogen is to try to
exercise it as part of the code generation itself. We have been doing
this with the bootstrapping, but there were limitations on
functionality such as ODB and EOS where we couldn't see any obvious
use for it in code generation. However, there is one way of exercising
this and a lot more of these sort of features: to create a Web-based code
generation service, along the lines of Web Sequence Diagrams or
YUML. We could create a simple bootstrap based website that forwards
requests to a set of end-points, all done within the dogen project.
</p>

<p>
We'd create a casablanca REST layer with a simple interface, with
functionality such:
</p>

<ul class="org-ul">
<li>create workspace: returns a UUID and creates some kind of internal
storage area.</li>
<li>upload target: uploads a Dia or JSON model to be used as the code
generation target.</li>
<li>upload reference: uploads a Dia or JSON model to be used as a
reference.</li>
<li>set options: which facets to generate, which languages, etc.</li>
<li>codegen: runs the code generation and returns a tarball with
generated files and the log file; or returns a set of code
generation errors.</li>
<li>we could integrate with google drive to load the files from there.</li>
</ul>

<p>
As a further layer we could create an ASIO service that is queried by
the casablanca REST. This would exercise all of the messaging
infrastructure. Internally it would create the engine and run code
generation. It could also exercise ODB by writing session information
to a database and keeping track of the historical usage of the
service, log files etc.
</p>

<p>
This stack would allow us to continuously exercise pretty much every
feature we need out of dogen. As an added bonus, when we get to the UI
we could also exercise that (Wt, GTK).
</p>

<p>
Finally, this would also allow us to play with Docker, and place each
service in their own container, create load balancing etc.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://codeplanet.io/principles-good-restful-api-design/">REST API Design</a></li>
<li><a href="http://www.drdobbs.com/tools/json-and-the-microsoft-c-rest-sdk/240164821">Using Microsoft REST SDK</a></li>
<li><a href="https://git.gnome.org/browse/dia/tree/doc/diagram.dtd">Dia DTD</a>: make sure all dia diagrams are valid according to DTD. Same
for JSON documents. Make sure there are size limits for names,
locations, documents, etc. See also <a href="https://security.stackexchange.com/questions/416/if-an-xml-document-is-not-validated-as-well-formed-or-checked-against-a-schema">If an XML document is not
validated as Well Formed or checked against a schema, what are the
risks?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4590a3c" class="outline-4">
<h4 id="org4590a3c"><span class="section-number-4">4.1.8</span> Consider replacing out libxml bindings with RapidXML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-8">
<p>
We rolled our own libxml bindings for reading the dia XML. However, it
may make more sense to use <a href="https://github.com/dwd/rapidxml">RapidXML</a> instead. It seems basic but our
needs are also very basic.
</p>
</div>
</div>

<div id="outline-container-org9828382" class="outline-4">
<h4 id="org9828382"><span class="section-number-4">4.1.9</span> Implement wale in terms of existing template libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-9">
<p>
Originally we implemented wale as a quick hack, but we stated:
</p>

<div class="epigraph"><blockquote>
<p>
A second point is the use of <a href="https://github.com/DomainDrivenConsulting/bustache">bustache</a> vs rolling our own trivial
mustache-like implementation:
</p>

<ul class="org-ul">
<li>if we use bustache we can, in the future, start to make use of
complex mustache templates. We don't have a use case for this now,
but there is no reason to preclude it either.</li>
<li>however, with bustache as a third-party dependency we now have to
worry about generating OSX and windows binaries for the
library. Until we do, the builds will break.</li>
</ul>

<p>
For now, to make life easier we will roll our own. As soon as we have
a stable windows environment we will move to bustache.
</p>

</blockquote></div>

<p>
We should really move to one of these mustache implementations. Inja
seems to be the most sensible one, even though it depends on a JSON
library. We will need JSON internally anyway, so it may be the time to
add a dependency. We should also have a way to associate an arbitrary
JSON document with a formatter so that users can create their own
templates with their own parameters and the model is merely used for
pass-through.
</p>

<p>
We should also start to create a standard set of variables that dogen
exports into inja such as object name, namespaces, etc. These are
"system variables" and do not require any action from the user. In
fact, if we use the JSON based approach, we could define a JSON schema
for meta-model elements which is MASD specific. These are used by the
templates.
</p>

<p>
Note that stitch only makes sense when we are creating a code
generator (at least given the use cases we have so far) whereas inja
makes sense even for regular models and can be applied to items in any
technical space.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/cierelabs/boostache/tree/develop">boostache</a></li>
<li><a href="https://github.com/no1msd/mstch">mstch</a></li>
<li><a href="https://github.com/mrtazz/plustache">plustache</a> (in vcpkg)</li>
<li><a href="https://github.com/melpon/ginger">ginger</a></li>
<li><a href="https://github.com/qicosmos/render">render</a></li>
<li><a href="https://github.com/pantor/inja">inja</a>: in vcpkg, needs JSON library.</li>
<li><a href="https://github.com/jrziviani/amps">amps</a></li>
<li><a href="https://github.com/OlafvdSpek/ctemplate">ctemplate</a>: This library provides an easy to use and lightning fast
text templating system to use with C++ programs. It was originally
called Google Templates, due to its origin as the template system
used for Google search result pages.</li>
<li><a href="https://github.com/moneymanagerex/ctpp">ctpp GH</a>: See also <a href="http://ctpp.havoc.ru/en/">homepage</a>. Seems a bit unmaintained but may have
some good ideas. See <a href="http://ctpp.havoc.ru/en/whatis.html">What is CTPP?</a></li>
<li><a href="https://github.com/blockspacer/CXXCTP">CXXCTP GH</a>: "Add custom features to C++ language, like metaclasses,
Rust-like traits, reflection and many more. A fully open source,
powerful solution for modification and generation of C++ source
code. Reduce the amount of boilerplate code in your C++ projects."</li>
<li><a href="https://github.com/flexferrum/autoprogrammer">autoprogrammer GH</a>: "Welcome to Autoprogrammer, the C++ code
generation tool! This tool helps you dramatically reduce the amount
of boilerplate code in your C++ projects. Based on clang frontend,
the 'autoprogrammer' parses your C++ source files and generates new
set C++ sources. For instance, it generates enum-to-string
converting functions for you. Instead of you."</li>
</ul>
</div>
</div>

<div id="outline-container-orgfc07e28" class="outline-4">
<h4 id="orgfc07e28"><span class="section-number-4">4.1.10</span> Org-mode schemas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-10">
<p>
Check to see if there is any concept of an org-mode schema, whereby
certain outlines, etc are mandatory in order for the document to be
compliant.
</p>
</div>
</div>

<div id="outline-container-org3e4374b" class="outline-4">
<h4 id="org3e4374b"><span class="section-number-4">4.1.11</span> Dogen Modeling Studio&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-11">
<p>
Assorted set of ideas of what an "integrated environment" for modeling
within Dogen would look like. Very random.
</p>

<ul class="org-ul">
<li>model management, concept of projects.</li>
<li>integration with git in order to link model versioning with version
control. References should point to specific versions (tags or
commits).</li>
<li>ability to view revisions for a given model set. That is, at model
version X, code looks like Y. Linkage between generated code and
model.</li>
<li>configuration for all models and for each models - e.g. product
families, component families.</li>
<li>load all revisions with model changes: given a git repo, show me all
the commits that changed a model and see these as a log for the
model. We should also be able to see the comments on the
commit. We can then visualise the model and see the diffs across
revisions somehow.</li>
<li>ability to config the git repo, model location, output
directory. Performs a clone of up to X depth. Then reads history of
model files.</li>
<li>it should be possible to select branches for a git repo as well.</li>
<li>for injectors with text formats, it would be nice to be able to edit
the models within the IDE.</li>
<li>ability to download a zip with generated code for the model at a
specified version.</li>
<li>support for tracing within the IDE so that we can browse and
navigate all of the generated tracing information. Visualisation of
JSON as a expandable tree.</li>
<li>ability to load/save models into a relational database.</li>
<li>it would be nice to have endpoints with different versions of
Dogen. That way we could generate code and diff it. We can also
check if a model will error in the future/past versions of
Dogen. There should also be an endpoint of "latest" which is always
the latest version.</li>
<li><p>
once we have warnings and validation, we can generate github
badges. Perhaps a <code>.dogen</code> file at the top could be used to describe
the settings (API tokens, location of models, etc). Then we could
provide the following information:
</p>

<ul class="org-ul">
<li>is the model green (no errors, no warnings).</li>
<li>if its not green, what warnings and errors is it generating.</li>
<li>is the code out of sync with the model?</li>
<li>model health reports, based on complexity measures, etc.</li>
</ul>

<p>
The idea is that we would provide feedback with each commit so that
users can be on top of it. Also, users can choose to point to latest
just to see whenever their models break with latest changes.
</p></li>
<li>this story has a lot in common with <a href="#orgcf8bf04">Consider adding a wt frontend</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org998d5d1" class="outline-4">
<h4 id="org998d5d1"><span class="section-number-4">4.1.12</span> dogen as a github integration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-12">
<p>
Perhaps there are some useful services dogen could provide to users in
terms of dogen integration. If, with every commit, we could regenerate
the model and read the current state in github, we could then provide
a status report:
</p>

<ul class="org-ul">
<li>the model does not build; red emblem. Some changes were made to the
model (or to dogen) that make the model invalid. User should take
action.</li>
<li>the model builds but generates files that are different from what's
checked in on github. yellow emblem. Provide a report with the
diffs. This can either be because the code generator has changed or
the user changed the model.</li>
<li>the model builds and generates exactly the same code; green emblem.</li>
</ul>

<p>
With this approach we have two advantages:
</p>

<ul class="org-ul">
<li>we do not need to add projects as part of the dogen tests; the
service takes its place. We can still add a few as the core tests,
but we don't need to expand it much beyond reference implementation
and dogen itself.</li>
<li>we exercise dogen itself as well as the rest endpoint generation
code in a way that is actually useful to end users; it would be nice
to know immediately when something breaks.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we'll need some kind of way of dealing with tokens and secrets in
order to support private GH projects.</li>
<li>with the addition of overrides, we can also have another check:
build with overrides. When setting up the project, the user can
define the override profile to use. The report will also provide
details on what fails with overrides.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://report.ci/">report.ci</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8bf5da3" class="outline-4">
<h4 id="org8bf5da3"><span class="section-number-4">4.1.13</span> LSP as a form of roundtrip support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-13">
<p>
Once we have LSP delegation, one thing we could consider doing is use
this information for roundtripping. It would not be a complete
roundtrip support, but instead a "localised" roundtrip:
</p>

<ul class="org-ul">
<li>for hand-crafted elements, we could keep track of any operations
that the user may have defined on the model elment. We could also
warn if the user did not define an operation. The problem with this
is that we do not want to issue a lot of warnings. If we had an
injection model for which we were confident we could make changes
without breaking anything (such as org-mode), we could try to
automatically inject the properties and operations into the element
but we need to make sure this is not going to generate a lot of
noise and/or result in losing user data. It would be nicer to have
this as a controlled operation (e.g. run dogen on
"update"/"roundtrip" mode) so that we could bring in the diffs
manually and inspect them.</li>
<li>for elements which are mainly generated (but may or may not have
merge support), this is not very useful. This is because we only
expect</li>
</ul>
</div>
</div>

<div id="outline-container-org53fdf3f" class="outline-4">
<h4 id="org53fdf3f"><span class="section-number-4">4.1.14</span> LSP damemon for Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-14">
<p>
We should be able to create a simple LSP daemon that helps with dogen
models and stitch templates. For dogen models:
</p>

<ul class="org-ul">
<li>provide completion of meta-data keys</li>
<li>model validation (flycheck)</li>
<li>completion of model elements, context sensitive.</li>
<li>completion of references (assuming a "reference directory"
parameter)</li>
<li>help hints for meta-data features: description of the feature and
example usage. This should be added to every feature.</li>
<li>help hints for types based on their documentation.</li>
</ul>

<p>
See also the MOP story for more ideas. In terms of implementation, we
probably need to know the current line of the model so that we can
figure out what modeling element we are sitting on. With this context,
we can build an assets model and extract all of the required
information.
</p>

<p>
For stitch templates:
</p>

<ul class="org-ul">
<li>mainly meta-data hints and help.</li>
<li>find a way to call the LSP daemon for c++ with the expanded
template, and then interpret the resulting errors in terms of
template lines (we have a story for this).</li>
<li>find a way to call the LSP daemon for c++ and obtain its view of
completion etc. This is slightly harder because we need to map the
current line to the expanded template line. It may be even
impossible if in a for loop etc.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we should consider "LSP delegation". That is, our LSP could call a
technical space specific LSP for the stitch fragments and for model
fragments. We just need to figure out if its possible to send the
current file contents to the LSP server rather than have it read
from the filesystem because otherwise we would have to regenerate
the model every time the user changes a fragment or a
template. Ideally we should regenerate in memory (in the LSP server
itself) and then send the new file to the LSP server such that the
actual file in the filesystem is not touched.</li>
<li>LSP delegation would work extremely well when combined with an
org-mode front-end. We could then allow users to edit fragments of
code, but map these to the LSP errors and completion coming out of
the delegated server. For errors in lines coming outside of this
fragment we could map these to some other location.</li>
<li>LSP delegation also means we can intercept <b>any</b> errors coming out
of the remote LSP server and use them to highlight model
elements. However, its not clear how this would work as normally we
need to notify the LSP server that we are working on a given
file. Perhaps here we need to integrate with the plain LSP server
somehow. However, we do have a list of files in the model so we can
easily filter for those and if there is a match, use that to display
an error. The error could be just pointing out to the model element
in question and stating there is an error. If the element is not
code-generated we could tell the user to go to the file.</li>
<li>we could also consider adding LSP for Dia. There is nothing about
LSP that makes it text-mode specific. We could easily monitor a dia
XML file from Dogen, resolve it into a model and then provide
answers for requests on the Dia front-end:
<ul class="org-ul">
<li>completion of types</li>
<li>errors and warnings (make font or backgroun red?)</li>
<li>documentation on hover</li>
<li>etc.</li>
</ul></li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.reddit.com/r/cpp/comments/eov5fh/critique_my_project_libclsp_a_c17_library/">Critique my project. Libclsp, a C++17 library</a></li>
<li><a href="https://github.com/otreblan/libclsp">libclsp</a>: A C++17 library for language servers.</li>
<li><a href="https://github.com/kuafuwang/LspCpp">LspCpp GH</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/implementors/sdks/">SDKs for LSP</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/implementors/servers/">LSP servers</a>: we could look at the C++ servers to see if any offer an
LSP library.</li>
</ul>
</div>
</div>

<div id="outline-container-org13700e3" class="outline-4">
<h4 id="org13700e3"><span class="section-number-4">4.1.15</span> Dogen studio: builds and binaries for users&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-15">
<p>
It would be nice if when a user code-generates a model in the dogen
studio site, we could do a travis build with the generated code. The
build would then produce static/shared libraries, assemblies, etc so
that the model is ready to use. We could even generate a debian
package. Dogen would produce all the required plumbing (CMake,
msbuild, etc).
</p>

<p>
We could even get away with having a single project in github/travis,
and doing a single commit that erases all previous state and instates
the new model. We would also need a queue telling users where they
are, so that all builds are serialised. For C#, it would be even
cooler if we could directly upload the model into nuget after the
build and supply the user with the nuget commands required to get the
model. However, the only problem may be that we'd end up with a lot of
dodgy code in nuget, so maybe this is not ideal.
</p>

<p>
Actually given we want to move away from Travis, it makes sense for
this to be done using regular cloud functionality (e.g. docker, etc).
</p>
</div>
</div>

<div id="outline-container-orgcbbbb3f" class="outline-4">
<h4 id="orgcbbbb3f"><span class="section-number-4">4.1.16</span> Add support for element renaming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-16">
<p>
This story is still in its early days. We could probably create a
simple tool that renames types. There are several things we may want
to achieve from this:
</p>

<ul class="org-ul">
<li>dia updating tool that receives new and old name and updates the
diagram. This makes renames easier because we keep missing places
where types are used.</li>
<li>dogen support: with access to new name and old name we can now
rename files which are not code generated. This avoids the usual
loss of work, git reverts etc.</li>
</ul>

<p>
The problem we have is that if we do not update the diagram
automatically, the rename is not that useful. However, updating the
diagram is not entirely trivial. We probably could record XPaths
against elements and then use those XPaths to update the XML
tree. This would be a multi-step process:
</p>

<ul class="org-ul">
<li>first we'd generate the final Yarn model;</li>
<li>then use the old ID to locate the element to rename and all of its
usages;</li>
<li>then update the XML based on the XPaths obtained from the renamed
elements and save it to file (maybe as <code>.new</code>?).</li>
<li>we can then reload the yarn model from the new and generate from
there.</li>
</ul>

<p>
A slightly more useful approach would be to integrate clang with
dogen. It would be a multi-step process:
</p>

<ul class="org-ul">
<li>update the input format (JSON, DIA)</li>
<li>run clang rename across all affected models; for this, we need to
know the references. This is more problematic across products, so
for now lets just imagine an update within a product. We would read
all models in a product to create a model dependency graph, then use
that to obtain a list of files that depend on the item to be
renamed. This is done by separating the generated and non-generated
files. The generated files we can infer dependencies from the
metamodel. The non-generated files we can infer dependencies from
the list of includes (for C++).</li>
<li>then we'd generate clang tool code to rename all of the dependent
files.</li>
<li>finally we'd code generate.</li>
</ul>

<p>
This process shares a lot of commonalities with finding deprecated
(not used) elements.
</p>

<p>
We should also take into account model renaming. This is probably
easier; we could add a renaming activity to CLI. This requires a bit
of thinking.
</p>

<p>
<b>Automatic Renames</b>
</p>

<p>
This could be potentially done automatically if we could access say
the existing version of the diagram and the new version; we could load
both models and then do a diff. This could be a bit dangerous though
if there are other changes, etc.
</p>

<p>
<b>Attribute Renames</b>
</p>

<p>
Another useful use case, is the renaming of attributes.
</p>

<p>
Merged stories:
</p>

<p>
<b>Detect moved files</b>
</p>

<p>
It would be nice if we could detect files that are non-generatable and
have been moved, so we could move them across. For this we need to
know:
</p>

<ul class="org-ul">
<li>that the file is not generatable: e.g. service, etc.</li>
<li>that the new file name is equal to the previous file name, just in a
different directory.</li>
</ul>

<p>
We could then just replace the empty file with the contents of the
previous file. Of course, we would still need updating namespaces,
etc.
</p>

<p>
Another way of doing this is to have UUIDs associated with each
type. The UUID is preserved into the file (ideally into a language
attribute, queryable by clang but could also be a comment). Before we
write the file we check to see if a file already exists with the same
UUID. If it does, we simply rename it to the new name matching the
UUID.
</p>

<p>
We should also issue an error if a file hasn't got a matching UUID and
at least to start off with force users to manually update it. Ideally
we should be able to use clang to update the UUID but for this we need
merging code generation support.
</p>
</div>
</div>

<div id="outline-container-org1bc0382" class="outline-4">
<h4 id="org1bc0382"><span class="section-number-4">4.1.17</span> Consider C++ itself as a front-end&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-4-1-17">
<p>
One can imagine a clang-based front-end that reads C++ code suitably
annotated, perhaps with <code>masd::generatable</code> or some such attributes -
basically all attributes required to build a sensible logical
model. The frontend will parse the code and generate an injector
format. We can then generate serialisation, hashing etc for the
hand-crafted code.
</p>

<p>
One very good use case for this is for legacy code bases. One could
benefit from adding serialisation and IO support to an existing legacy
code base. This raises the interesting problem that we would need to:
</p>

<ul class="org-ul">
<li>disable the types facet;</li>
<li>inject types created from the c++ code with the types facet
properties populated (namely include and file path).</li>
<li>to be totally non-intrusive: generate a shared library that provides
dogen code and requires the presence of the user code library.</li>
<li>we may also need to somehow add a whole load of supporting types in
order to be able to resolve references. So there would be a "target
model" that we need to somehow identify but there would also be the
supporting libraries (all other types the model references that we
do not wish to code generate). This will probably be tricky. If the
user needs to add these types manually it will not be
practical. However, it may not be trivial to distinguish between the
two.</li>
</ul>

<p>
This feature requires a bit of thinking as the architecture does not
support any of these.
</p>

<p>
The c++ frontend would also open some interesting possibilities:
</p>

<ul class="org-ul">
<li><b>read c++ and generate JSON</b>. This is a great way to import types into
dogen; given a set of libraries returns a basic JSON model for dogen
for them, with as much filled in as possible such as include
directories, etc. This would save us a lot of time instead of
manually adding these. The story for this was: As a dogen user, I
want to generate system models automatically so that I don't have to
create them manually.</li>
<li><b>read c++ and generate dia</b>. This would allow creating diagrams of
existing code bases. Not trivial because the layout of the diagram
would be quite hard to get right. We should create a separate tool
for this.</li>
<li><b>update existing diagrams</b>. See <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#investigate-support-for-automatic-diagram-updates">this story</a>.</li>
</ul>

<p>
It would be important to be able to filter the classes. This could be
achieved by either having to supply the header files to read or
probably better by supplying a list of class names one is interested
in. We will probably need a compilation database to instantiate clang
so this would mean we'd have visibility of the entire project.
</p>

<p>
Actually the right way to do this is to have an LSP-to-Dogen
approach. This would also allow us to support any LSP-compliant
lanugage in one go.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li>For clang source code transforms, see <a href="https://github.com/flexferrum/flex_lib">flex<sub>lib</sub></a> and this
presentation: <a href="https://www.youtube.com/watch?v%3DaPTyatTI42k">Automatic C++ source code generation with clang -
Sergei Sadovnikov</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf4dc8bf" class="outline-4">
<h4 id="orgf4dc8bf"><span class="section-number-4">4.1.18</span> Consider compiling generated code with clang&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-18">
<p>
It make sense to perform some kind of minimal sanity checks on the
code generated by <code>knit</code> to provide a heads up to users. A full
compilation may be beyond the scope (database compilation may not be
setup, etc) but it would be nice to pickup basic syntax errors.
</p>

<p>
This story needs to be updated in light of LSP.
</p>
</div>
</div>

<div id="outline-container-org564b191" class="outline-4">
<h4 id="org564b191"><span class="section-number-4">4.1.19</span> Compile stitch template output with clang&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-19">
<p>
Once we have integrated clang for formatting stitch output, it would
be great to also integrate it for compilation. It would work as
follows:
</p>

<ul class="org-ul">
<li>start creating compilation databases when we do a regular build with
clang;</li>
<li>within stitch, get clang to detect the compilation database "near"
the template; presumably clang has some infrastructure to do so
already - if not we could perform a file look up. Actually we should
just have a stitch command line parameter for the compilation
database as well as for the clang-format settings.</li>
<li>create a mapping of template lines to output lines during output
generation.</li>
<li>run clang with the compilation database options against the template
output. Use the mapping to provide a cross reference between the
template output and the template. We could use a scheme similar to
GCC (included from, etc).</li>
<li>apparently its possible to compile from a memory buffer. See <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2015-July/044029.html">this</a>
thread.</li>
</ul>

<p>
This story needs to be updated in light of LSP.
</p>
</div>
</div>

<div id="outline-container-org99d1fea" class="outline-4">
<h4 id="org99d1fea"><span class="section-number-4">4.1.20</span> Splitting facets out of a component&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-4-1-20">
<p>
It is not always desirable to generate a facet as part of the main
model. For example, say we want to support coherence, or a relational
representation. We don't want to generate a single shared object with
the model and also include coherence in it because this means everyone
will have to link against the coherence libraries. Instead, one would
like to create "project facets"; that is, to be able to somehow create
a top-level project just for that facet (or perhaps group of facets)
such that they would end up in a different project and thus different
shared object. For example:
</p>

<pre class="example">
project_a/cpp/types
project_a/cpp/coherence
</pre>


<p>
would become
</p>

<pre class="example">
project_a/cpp/types
project_a.coherence/cpp/coherence
</pre>


<p>
Or some such approach. Now that we have support for dot model names,
this is easier to do. We should have a meta-data element that
determines if a given facet is "built-in" ("shared"?) or if it is
"external".
</p>

<p>
This is not exclusive to facets like coherence. For example, we may
not need test data in production, particularly when we start
supporting test data types because we would then include a lot of data
in the binary (or start requiring data files to be distributed with
the model). This is useful to create system tests, but not ideal for
the production binary.
</p>

<p>
We may not need separate projects. Having different directories
complicates facet management a great deal. If we take the <a href="https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#proj-struct">build2
approach</a>, in that a single project can create multiple binaries, this
would make life <b>much</b> easier: we could then simply generate static or
dynamic libraries if the facet is not built-in. We could also
automatically add the dependency between the facet library and the
main library, or even between facet libraries because we have access
to the facet dependency graph. The user should just classify the facet
as "external"; it is up to CMake to determine if its a static or
shared library.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb2ddde7" class="outline-2">
<h2 id="orgb2ddde7"><span class="section-number-2">5</span> Future Releases</h2>
<div class="outline-text-2" id="text-5">
<p>
Stories that have not yet been allocated a release, by broad themes.
</p>
</div>

<div id="outline-container-org9b4a8fd" class="outline-3">
<h3 id="org9b4a8fd"><span class="section-number-3">5.1</span> Technical debt</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Ideas to improve the code base.
</p>
</div>

<div id="outline-container-org63ab8a3" class="outline-4">
<h4 id="org63ab8a3"><span class="section-number-4">5.1.1</span> Create a test model with SHA1 hash in generation marker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
At present we cannot test this feature because we are using all models
in both JSON and Dia generation. When we do this, the original model
produces different SHA1 hashes. We need to create a test for a model
which has only one injection type.
</p>
</div>
</div>

<div id="outline-container-org43eba65" class="outline-4">
<h4 id="org43eba65"><span class="section-number-4">5.1.2</span> Logging at info is very messy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Ideally when logging at info we want to see the spine of the program,
showing all transforms with their start and finishes and some
information about what they are processing (e.g. model).
</p>
</div>
</div>

<div id="outline-container-org8dddfeb" class="outline-4">
<h4 id="org8dddfeb"><span class="section-number-4">5.1.3</span> Check all of the dogen warnings in lgtm&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
We have <a href="https://lgtm.com/projects/g/MASD-Project/dogen/context:cpp">a number of warnings in lgtm</a>, some of which are actually
relevant. Even the FIXMEs should be dealt with - either create a story
or just make it a comment. The data has been saved as a file under:
</p>

<ul class="org-ul">
<li><a href="https://github.com/MASD-Project/dogen/tree/master/doc/lgtm.json">https://github.com/MASD-Project/dogen/tree/master/doc/lgtm.json</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge6b6e11" class="outline-4">
<h4 id="orge6b6e11"><span class="section-number-4">5.1.4</span> Convert utility exceptions into dogen exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
At present the utility model has a number of hand-crafted
exceptions. We need to convert them to dogen exceptions. We also need
to get rid of the invalid enum exception and use the
<code>std::argument...</code> exception instead.
</p>

<p>
This should wait until the utility model is moved out of dogen.
</p>
</div>
</div>

<div id="outline-container-org972380f" class="outline-4">
<h4 id="org972380f"><span class="section-number-4">5.1.5</span> Change order of includes according to Lakos major design rule&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-5">
<p>
Lakos says:
</p>

<div class="epigraph"><blockquote>
<p>
The .c file of every component should include its own .h file as the
first substantive line of code.
</p>

</blockquote></div>

<p>
We decided to include it as the last line. However, Lakos approach has
the side-effect of automatically detecting headers that are missing
includes. We used to do this manually by generating <code>.cpp</code> files that
just included the header but then had to remove it because it was
slowing down compilation. With Lakos approach we get the best of both
worlds.
</p>

<p>
We need to update the generated code to follow this approach. This
will require some thinking. We should create two include blocks to
make this distinction clear, e.g.:
</p>

<pre class="example">
// MAIN_HEADER
#include "XYZ"

// DEPS
#include "ZZZ"
</pre>


<p>
This means the include container should have two different containers
to match this structure.
</p>
</div>
</div>

<div id="outline-container-orgf877863" class="outline-4">
<h4 id="orgf877863"><span class="section-number-4">5.1.6</span> Consider making <code>disabled</code> a trace/log level&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-6">
<p>
At present we have two knobs to control tracing/logging:
</p>

<ul class="org-ul">
<li>enabled</li>
<li>level</li>
</ul>

<p>
According to the rule of making invalid states unrepresentable, we
should just have a log level of disabled, so that its not possible to
set the trace/log level when logging is disabled.
</p>
</div>
</div>

<div id="outline-container-orgf6f786e" class="outline-4">
<h4 id="orgf6f786e"><span class="section-number-4">5.1.7</span> Consider renaming log level <code>trace</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-7">
<p>
Its slightly confusing given that we also have <code>tracing</code>.
</p>
</div>
</div>

<div id="outline-container-orgb1658d2" class="outline-4">
<h4 id="orgb1658d2"><span class="section-number-4">5.1.8</span> Consider replacing the associations against object templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-8">
<p>
Object templates are really a higher level concept when compared to
objects, etc. We should not be using associations to denote the notion
of an object instantiating an object template. Perhaps the "implements
an interface" relationship is more appropriate. Check the UML books.
</p>
</div>
</div>

<div id="outline-container-org641c0b1" class="outline-4">
<h4 id="org641c0b1"><span class="section-number-4">5.1.9</span> Use DI in injection model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-9">
<p>
We need to use the boost.di injector in the injector model to register
the encoding and decoding transforms. This means we need to receive
lists of codecs in the main transform and then setup the reigstrar
internally. It also means we need state, which means we need to
propagate the DI pattern all the way to the top.
</p>
</div>
</div>

<div id="outline-container-org7efb7f9" class="outline-4">
<h4 id="org7efb7f9"><span class="section-number-4">5.1.10</span> Use <code>std::filesystem</code> instead of <code>boost::filesystem</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-10">
<p>
Now that we have upgraded to C++ 17 we can start to make use of
<code>std::filesystem</code>. Given our very limited use, all of the required
functionality should be available.
</p>
</div>
</div>

<div id="outline-container-org2a12961" class="outline-4">
<h4 id="org2a12961"><span class="section-number-4">5.1.11</span> Use <code>std::shared_ptr</code> instead of <code>boost::shared_ptr</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-11">
<p>
It seems it is now possible to serialise <code>std:shared_ptr</code> using
regular boost serialisation. We should start to move our pointers to
standard ones. The only slight problem is that we do not have boost
serialisation support for shared pointers.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/8115220/how-can-boostserialization-be-used-with-stdshared-ptr-from-c11">How can boost::serialization be used with std::shared<sub>ptr</sub> from C++11?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org57721ab" class="outline-4">
<h4 id="org57721ab"><span class="section-number-4">5.1.12</span> Consider renaming <code>object</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-12">
<p>
We started off by having the notion of "value objects" but this was
subsequently changed to just objects. Value objects as understood by
DDD are really for things with value semantics. What we were looking
for was something akin to:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">POJO</a></li>
<li><a href="https://en.wikipedia.org/wiki/Plain_old_CLR_object">POCO</a></li>
<li><a href="https://en.wikipedia.org/wiki/Passive_data_structure">Passive data structure</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_transfer_object">Data transfer object</a></li>
</ul>

<p>
However, in addition to these basic behaviours we also may have others
such as IO, test data etc. We need a name that reflects this. Ideas:
</p>

<ul class="org-ul">
<li>aggregate object</li>
<li>record</li>
</ul>

<p>
Interestingly, we could then have two levels: struct (no behaviour),
non-struct (behaviour).
</p>

<p>
In addition to this, we have made a mistake by transforming attributes
into getters and setters without any stereotyping. We need something
like <code>property</code> for this. Then we can say that for these kinds of
objects and their templates, the default attribute stereotype is
<code>property</code>. When not set, we should just code generate the attribute
with the correct visibility. This also means that the code templates
will be much easier, and support for real classes too (useful when we
can make use of protected regions).
</p>
</div>
</div>

<div id="outline-container-org9954659" class="outline-4">
<h4 id="org9954659"><span class="section-number-4">5.1.13</span> Cross-model transformations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-13">
<p>
Once we have interfaces, there are at least two very useful
transformations we could do:
</p>

<ul class="org-ul">
<li>remotable transformation: take a service and convert it into a set
of messages - possibly in an IDL (e.g. protocol buffers, grpc, brpc,
thrift), possibly in a c++ representation. For this we could have a
meta-model element (<code>dogen::remotable</code>?) and a meta-data parameter
pointing to the interface to make remotable, as well as the
implementation (internal implementation to be named with boost,
beast, etc (<code>mutu</code>?), gprc, protobuf, etc). Users can create a model
and customise globally these parameters, then "import" the required
services. When dogen spots a meta-model element of type remotable,
it locates the original service interface and then for each method
it creates messages. These are then processed depending on the
enabled facets (for example if protobuf is enabled, generates the
IDLs, etc). It is not possible to mix transport layers in a
model. The generated code also contains a wrapper interface for the
client which implements the original interface in terms of the
transport layer. Dogen should automatically enable the required
serialisation mechanisms (e.g. JSON, etc).</li>
<li><p>
interop transformation: take a service and generate a SWIG wrapper
for it. Interestingly, if we had access to ports, connect,
disconnect, etc (probably not much more) the SWIG wrapper would also
be able to cope with transport layer implementations as well,
allowing us to invoke remote services. However, this is probably not
important because we can either use HTTP or protobuf etc from the
scripting languages.
</p>

<p>
Links:
</p>

<p>
<a href="https://github.com/apache/incubator-brpc">brpc GH</a>: An industrial-grade RPC framework used throughout Baidu,
with 1,000,000+ instances(not counting clients) and thousands kinds
of services. "brpc" means "better RPC".
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgf7baf8f" class="outline-4">
<h4 id="orgf7baf8f"><span class="section-number-4">5.1.14</span> Add support for "ad-hoc" tracing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-14">
<p>
We have a set of inputs supplied to the tracer called "initial
input". This is not ideal. We need a way to generalise the "initial
input" dumping. In effect, what we are really saying is that within a
transform we may need to dump more state than just the initial
inputs. We need a way to express this in the probing API.
</p>
</div>
</div>

<div id="outline-container-org74ec36c" class="outline-4">
<h4 id="org74ec36c"><span class="section-number-4">5.1.15</span> Split registrar into two classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-15">
<p>
At present we do not distinguish between the setting up of the
registrar and the usage of the registrar. Up to know this is not a
major issue, although its a bit of a smell that we have to call
validate at some arbitrary point.
</p>

<p>
However, with the new parts/builder setup, this becomes even more of a
problem because we only want to build the parts once we have
registered all of the formatters. The right thing would have been to
have:
</p>

<ul class="org-ul">
<li>a registrar builder, used during registration;</li>
<li>a build step which returns the (validated) registrar. Once build is
called, we should throw if anyone attempts to add more formatters.</li>
</ul>

<p>
This makes it hard to misuse the API.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>how does this affect plugins? will it still be possible to register
formatters from a shared library?</li>
<li>actually this will happen anyway as we move towards using Boost.DI.</li>
</ul>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>create a registrar builder with most of the existing registrar
interface. On build it computes the parts, generates the repository,
etc and then supplies that to the registrar. The registrar itself is
no longer static, just a member of the workflow.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf52f939" class="outline-4">
<h4 id="orgf52f939"><span class="section-number-4">5.1.16</span> Use element ids for associations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-16">
<p>
There doesn't seem a need for having entire names for associations;
these are used to find information by ID anyway. We should try to
convert them to element id's instead and see what breaks.
</p>

<ul class="org-ul">
<li>transparent, opaque associations</li>
<li>base, derived visitor</li>
<li>contained by</li>
</ul>

<p>
We can't do this for:
</p>

<ul class="org-ul">
<li>visitor: we use the name in the formatter.</li>
</ul>

<p>
Actually there is a reason for this: we use the names to build the
file paths and the includes. We need to add some comments.
</p>
</div>
</div>

<div id="outline-container-orgf3958be" class="outline-4">
<h4 id="orgf3958be"><span class="section-number-4">5.1.17</span> Tidy-up "is floating point"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-17">
<p>
We should introduce "point type" enumeration to replace "is floating
point":
</p>

<ul class="org-ul">
<li>none</li>
<li>floating</li>
<li>fixed</li>
<li>exact</li>
</ul>
</div>
</div>

<div id="outline-container-org6d73eee" class="outline-4">
<h4 id="org6d73eee"><span class="section-number-4">5.1.18</span> Benchmarks do not work for utility tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-18">
<p>
When we run the benchmarks for utility we get an error:
</p>

<pre class="example">
Running 95 test cases...
/home/marco/Development/DomainDrivenConsulting/dogen/projects/utility/tests/asserter_tests.cpp(141): error: in "asserter_tests/assert_directory_good_data_set_returns_true": check asserter::assert_directory(e, a) has failed
</pre>


<p>
Seems like the tests do not clean up after themselves. We need to add
some clean up logic and re-enable the tests. We probably should just
remove all of the benchmarks infrastructure, given we never use it and
it has probably bit-rotted by now.
</p>
</div>
</div>

<div id="outline-container-orgfe31ed8" class="outline-4">
<h4 id="orgfe31ed8"><span class="section-number-4">5.1.19</span> Clean up comment formatter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-19">
<p>
Comment formatter is now a mess of ifs and boolean variables. We need
to create a proper state machine describing its internals and then
implement it.
</p>
</div>
</div>

<div id="outline-container-org793b665" class="outline-4">
<h4 id="org793b665"><span class="section-number-4">5.1.20</span> Language namespaces and modeling element locations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-20">
<p>
When we designed Dogen's meta-model yarn, we created a separation from
"physical space" and "modeling space". That is, a modeling element
living in modeling space does not know of any implementation specific
details such as serialisation or test data generation. Those are
concerns left to the kernels that implement "physical space" such as
the C++ kernel and are normally implemented as separate facets. Again,
facets are a "physical concept" and have no equivalent in modeling
space.
</p>

<p>
Facets normally tend to have a folder associated, originally
envisioned as a way keep the code a bit more manageable. If we take
the <a href="https://github.com/DomainDrivenConsulting/dogen/tree/master/projects/yarn/include/dogen/yarn">yarn model itself</a> as an example:
</p>

<ul class="org-ul">
<li>types: domain types</li>
<li>hash: support for std::hash</li>
<li>io: iostreams support</li>
<li>serialization: boost serialisation support</li>
<li>test<sub>data</sub>: test data generators</li>
</ul>

<p>
Crucially, modeling space is not aware at all of these folders and
thus they are not related to the modeling space concept of modules. So
it is that the domain type, housed in the types folder, is <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/projects/yarn/include/dogen/yarn/types/enumeration.hpp">defined as</a>:
</p>

<pre class="code"><code>...
namespace dogen {
namespace yarn {

/**
 * @brief Defines a bounded set of logically related values for a built-in type
 * or a string.
 */
class enumeration final : public dogen::yarn::element {
...
</code></pre>

<p>
And so forth (note the absence of "types" in the namespace
declaration). This worked well for C++. However, this approach may
cause problems for C# and will certainly cause problems for Java. This
is because in these languages, folders are supposed to correspond to
namespaces. In C# this is largely optional, but in Java it is
mandatory. Thus we need some way of injecting the facet directories as
internal modules before we code generate.
</p>

<p>
Actually this is non-trivial; all references to types will now have to
concern themselves with the facet. For example, say test data
generator is referring to the domain type; this now needs to be
qualified correctly, as they are in different namespaces. This
requires quite a bit of thinking in order to generate compilable
code.
</p>

<p>
On further thought, perhaps its not that bad. We just to be able to
distinguish proxy from non-proxy types (in order to know whether to
apply the "fake" facet namespace); then, we either apply the current
facet (say test data) or types. We don't refer to a third facet. In
addition, we can also use the facet folder as the fake namespace. So,
before we make use of a name, we need to call the assistant to inject
the fake internal module, either with the current facet or types; this
is done for all non-proxy names. The "is proxy" property needs to be
added to names.
</p>

<p>
In addition, we could define <code>using</code> declarations for all dependent
facets at the top of each file as we know these up front. Thus all
types are declared on a namespace specific to the facet, but each
facet includes dependent facets so that the templates themselves are
not affected (other than the using statement). Actually this will not
work if there are several referenced models which happen to have types
with the same name.
</p>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>add a meta-data flag to enable/disable this feature.</li>
<li>in assistant, during code generation, provide a function which
injects the internal module.</li>
</ul>
</div>
</div>

<div id="outline-container-org4c76d5c" class="outline-4">
<h4 id="org4c76d5c"><span class="section-number-4">5.1.21</span> Rename formatting assistant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-21">
<p>
With the introduction of assistants in C#, we now have overloaded the
term. We need to find another name to refer to the formatting
assistant in C++ so avoid confusion.
</p>
</div>
</div>

<div id="outline-container-org6e8e5ce" class="outline-4">
<h4 id="org6e8e5ce"><span class="section-number-4">5.1.22</span> Remove unused elements from logical model's final model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-22">
<p>
We could mark all used elements during resolution and then during the
transformation into the final model, we could drop all unused
elements. This could be done by a "reducer" transform.
</p>

<p>
This makes even more sense once we move all of the dependency
generation code from the kernels into assets, because then only
generated types are required. This means we have two levels of
removal:
</p>

<ul class="org-ul">
<li>types which are not referenced during resolution: slightly more
complicated now that we resolve in multiple places. However the key
is to be able to mark a type as "used" during any part of the
transform pipeline.</li>
<li>types which are not generatable. This can be removed as we finish
the parts of the pipeline that require them (e.g. variability, etc).</li>
</ul>

<p>
We could create transforms for each of these.
</p>

<p>
Merged stories:
</p>

<p>
<b>Filter out unused types from final model</b>
</p>

<p>
When we finished assembling the model we should be able to determine
which supporting types are in use and drop those that are not. This
can be done just before building the final model (or as part of that
task).
</p>

<p>
We should have a class responsible for removing all types from a model
which are not in use. This could be done as part of model assembly.
</p>

<p>
One way this could be achieved is by adding a "usages" property,
computed during resolution. Resolver could keep track of the
non-target names that are in use and return those.
</p>
</div>
</div>

<div id="outline-container-orga5ce588" class="outline-4">
<h4 id="orga5ce588"><span class="section-number-4">5.1.23</span> Model should contain set of built-in id's&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-23">
<p>
We are computing the set of all built-in id's in generation but this
should really be part of the logical model.
</p>

<p>
We need to double-check this - we have a built-ins model. This story
may have bit-rotted.
</p>
</div>
</div>

<div id="outline-container-org54aca00" class="outline-4">
<h4 id="org54aca00"><span class="section-number-4">5.1.24</span> Identifier parser has hard-coded built-ins&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-24">
<p>
Instead of using the hardware model, we have hard-coded all of the
built-ins. In addition, there are some built-ins which are C++
specific (<code>wchar_t</code>), as well as others which are only valid in
certain cases such as <code>void</code>. This needs a bit of thinking.
</p>

<p>
We could look for all built-ins in the global namespace. Or we could
have a tag in the types that describes them in a way that we can
filter: <code>hardware_type</code> flag? The problem is that we need the
identifier parser in order to load models and we need the loaded
models in order to locate these types.
</p>

<p>
One solution for this problem is to move the properties expansion to
later on after the front end workflow has finished executing. Once we
have a merged model we can then easily take the built-in container
and inject that into the identifier parser. The only slight problem is
that we need to know of the top-level modules for a given model in
order to use the identifier parser. This means we need to expand
unparsed types before merging. There is a circular dependency here.
</p>

<p>
We somehow need a first pass to obtain all the built-ins and a second
pass to parse.
</p>
</div>
</div>

<div id="outline-container-org6c69237" class="outline-4">
<h4 id="org6c69237"><span class="section-number-4">5.1.25</span> <code>always_in_heap</code> is not a very good name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-25">
<p>
What the name is trying to say is: I have a type parameter and that
type parameter is always allocated in the heap. But it does not quite
convey that at all - it seems like the type itself is always in heap
the way we use it in resolver.
</p>
</div>
</div>

<div id="outline-container-org81864f5" class="outline-4">
<h4 id="org81864f5"><span class="section-number-4">5.1.26</span> "current" is not the best of names in name tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-26">
<p>
We need to find a slightly more meaningful name for the "current" name
on the name tree. It was just about alright and then we went and
introduced <code>is_current_simple_type</code>, which is unintelligible.
</p>

<p>
We could call it just "data" and drop "current" from flag.
</p>
</div>
</div>

<div id="outline-container-orgcfc460e" class="outline-4">
<h4 id="orgcfc460e"><span class="section-number-4">5.1.27</span> Rename methods parsing name trees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-27">
<p>
We have a variety of names for the methods parsing name trees
recursively. The best one seems to be <code>walk_name_tree</code>. We should use
this name consistently.
</p>
</div>
</div>

<div id="outline-container-orge433afa" class="outline-4">
<h4 id="orge433afa"><span class="section-number-4">5.1.28</span> Create utility methods for <code>__type__</code> etc&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-28">
<p>
At present we've hard-coded the field name for <code>__type__</code> and so forth
in each formatter. This is not ideal. Create a simple utility method
that returns it and update all formatters to use it instead. List of
hard-coded things:
</p>

<ul class="org-ul">
<li><code>__type__</code></li>
<li><code>&lt;empty&gt;</code></li>
<li><code>data</code></li>
<li><code>value</code></li>
<li><code>memory</code></li>
<li>string helper variables: <code>&lt;new_line&gt;</code>, <code>&lt;quote&gt;</code></li>
<li><code>tidy_up_string</code></li>
</ul>
</div>
</div>

<div id="outline-container-orge599aee" class="outline-4">
<h4 id="orge599aee"><span class="section-number-4">5.1.29</span> Improve container details in JSON dump&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-29">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like to know how many elements
containers have so that I don't have to count it manually.
</p>

</blockquote></div>

<p>
It would be nice to have the container type and size in the JSON
output. In addition, it seems we are not outputting all containers
correctly. For example, for associative containers we have:
</p>

<pre class="example">
"elements": [
  [
    {
      "__type__": "key",
      "data": "&lt;std&gt;&lt;unordered_map&gt;"
    },
    {
      "__type__": "value",
      "data": {
        "__type__": "boost::shared_ptr",
</pre>


<p>
We should really be outputting the container type, as well as the key
and value types:
</p>

<pre class="example">
 "elements": {
    "__type__": "std::unordered_map",
    "count": 10,
    "entries": [
        {
            "__type__": "std::pair",
            "first": "&lt;std&gt;&lt;unordered_map&gt;", ==&gt; NOTE: just a string
            "second": {
                "__type__": "boost::shared_ptr",
...
</pre>


<p>
And so forth. The only problem with this approach is with simple
types. If we have a key
</p>
</div>
</div>

<div id="outline-container-orgbedbc7f" class="outline-4">
<h4 id="orgbedbc7f"><span class="section-number-4">5.1.30</span> Consider removing filtering ostream&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-30">
<p>
Originally we added a boost based stream to handle
indentation. However, since we moved over to stitch, there probably is
no need to use it any longer. We need to investigate if the formatters
model is making use of it (generating comments, namespaces, etc). If
not, remove it.
</p>
</div>
</div>

<div id="outline-container-org065ac71" class="outline-4">
<h4 id="org065ac71"><span class="section-number-4">5.1.31</span> Sequences that support multiple postfixes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-31">
<p>
In C# we encountered what is probably a new use case for sequences: a
single sequence with two different postfixes, depending on the element
we're processing. We solved the problem by using two separate
sequences, with lots of copy and paste and duplication. However, a
more elegant solution is to allow "indices" for the configuration,
e.g. instead of:
</p>

<pre class="example">
dogen::formatters::sequence_formatter sf1(o.local_attributes().size());
dogen::formatters::sequence_formatter sf2(o.local_attributes().size());
sf1.element_separator("");
sf2.element_separator("");
sf1.postfix_configuration().not_last(", true/*withSeparator*/");
sf2.postfix_configuration().not_last("   ");
sf1.postfix_configuration().last("");
sf2.postfix_configuration().last("");
</pre>


<p>
We'd do:
</p>

<pre class="example">
dogen::formatters::sequence_formatter sf(o.local_attributes().size());
sf.element_separator("");
sf.postfix_configuration(0).not_last(", true/*withSeparator*/");
sf.postfix_configuration(1).not_last("   ");
sf.postfix_configuration(0).last("");
sf.postfix_configuration(1).last("");
</pre>


<p>
And then, we'd use it as:
</p>

<pre class="example">
sf1.postfix(0)
</pre>


<p>
and so forth.
</p>

<p>
We lost the C# use case for this though, as we managed to make the API
symmetric for both use cases.
</p>
</div>
</div>

<div id="outline-container-org44af3ac" class="outline-4">
<h4 id="org44af3ac"><span class="section-number-4">5.1.32</span> Attribute types are always fully qualified&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-32">
<p>
When we code generate non-built-ins attributes we always fully qualify
them even if they are on the same namespace as the containing
type. This should be easy to fix by extending the resolver to take in
the internal module path of the context. We could even recurse up the
internal module path, allowing for references to types in containing
modules.
</p>
</div>
</div>

<div id="outline-container-org6261460" class="outline-4">
<h4 id="org6261460"><span class="section-number-4">5.1.33</span> Using default value with text collection throws&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-33">
<p>
We don't support default values with text collection, but if the user
tries to use it, the error that comes out is not particularly helpful:
</p>

<pre class="example">
Invalid or unsupported value type:
{ "__type__": "value_types", "value": "text_collection" }
</pre>


<p>
This is because we attempt to instantiate the field value in the
hydrator, but there is no support for text collection there:
</p>

<pre class="example">
2016-08-05 08:10:03.749580 [ERROR] [knitter] Error: ../../../../projects/dynamic/src/types/json_hydrator.cpp(150): Throw in function boost::shared_ptr&lt;dogen::dynamic::value&gt; dogen::dynamic::json_hydrator::create_value(dogen::dynamic::value_types, const string&amp;) const
Dynamic exception type: boost::exception_detail::clone_impl&lt;dogen::dynamic::hydration_error&gt;
std::exception::what: Invalid or unsupported value type: { "__type__": "value_types", "value": "text_collection" }
[tag_workflow*] = Code generation failure.
</pre>


<p>
The right thing to do is to throw a more sensible exception such as
"default value is not supported for text collections".
</p>

<p>
Once we have a use case for default values in text collections we
should add it.
</p>
</div>
</div>

<div id="outline-container-orgfe7ade9" class="outline-4">
<h4 id="orgfe7ade9"><span class="section-number-4">5.1.34</span> Perform lexical casts once only for error reporting&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-34">
<p>
There are a number of places in the code where we do lexical casts for
enumerations for the exception part:
</p>

<pre class="example">
BOOST_LOG_SEV(lg, error) &lt;&lt; unsupported_formatter_type &lt;&lt; ft
                         &lt;&lt; " name: " &lt;&lt; o.name();
BOOST_THROW_EXCEPTION(workflow_error(unsupported_formatter_type +
   boost::lexical_cast&lt;std::string&gt;(ft)));
</pre>


<p>
We should just do the lexical cast once at the top and use it for both
logging and the exception message.
</p>

<p>
In addition we should be using <code>string_converter</code> for qnames now
instead of io'ing them directly.
</p>
</div>
</div>

<div id="outline-container-orge92654e" class="outline-4">
<h4 id="orge92654e"><span class="section-number-4">5.1.35</span> Consider moving the mock factories into the test<sub>data</sub> directory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-35">
<p>
There is no good conceptual reason to split the mock factories from
the test<sub>data</sub> generators. However, we did it because we don't have a
good way to give dogen visibility of the existence of these files: we
could add regexes but then its not very maintainable and not visible
from the project diagram.
</p>

<p>
The correct solution for this may be to have some tags that state that
an object only has representations in certain facets. This is captured
by this story: <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#consider-adding-facet-specific-types">Consider adding facet specific types</a>.
</p>
</div>
</div>

<div id="outline-container-org28041c3" class="outline-4">
<h4 id="org28041c3"><span class="section-number-4">5.1.36</span> Use consistently the American spelling for license&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-36">
<p>
We have a mix of American and British spelling of license (e.g. data
file folder is called licence. For details on the subject see <a href="http://www.future-perfect.co.uk/grammar-tip/is-it-license-or-licence/">this
article</a>.
</p>

<p>
We are going to take the easy approach as we did for serialisation and
make all the code artefacts American. Documentation etc is not that
important.
</p>
</div>
</div>

<div id="outline-container-orgbdd8e73" class="outline-4">
<h4 id="orgbdd8e73"><span class="section-number-4">5.1.37</span> Clean up coding resolver tests by extending mock factory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-37">
<p>
Now that the mock factory has the concept of "stages" of processing,
we need to create a "stage" for merged but unresolved models and
remove the merger from the resolver tests. The flag for this has been
added, we just need to go through the different scenarios and add
handling code for them.
</p>
</div>
</div>

<div id="outline-container-orgec00bc1" class="outline-4">
<h4 id="orgec00bc1"><span class="section-number-4">5.1.38</span> Refactor coding mock factory method names&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-38">
<p>
We have a zoo of naming conventions, some starting with <code>build_</code>, some
starting with <code>object_</code> etc.
</p>
</div>
</div>

<div id="outline-container-org266017a" class="outline-4">
<h4 id="org266017a"><span class="section-number-4">5.1.39</span> Validate assets mock factory on its own tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-39">
<p>
At present we have a lot of code that ensures that the output of mock
factory actually corresponds to expectations. However, this validation
is in the tests that use the mock factory, resulting in duplication
and possibly missing coverage. We should really just have a mock
factory test with this validation.
</p>
</div>
</div>

<div id="outline-container-orgaa02b8f" class="outline-4">
<h4 id="orgaa02b8f"><span class="section-number-4">5.1.40</span> Split floating point stream settings from double&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-40">
<p>
We had a problem where the output of floating point numbers was being
truncated due to scientific notation being used. A quick fix was to
just update the properties of all streams which use either doubles,
floats or <span class="underline">bools</span> with precision etc settings. The real fix is to
distinguish between the two such that we only enable <code>bool</code> related
settings when dealing with bools and floating point settings when
dealing with <code>double</code> or <code>float</code>.
</p>
</div>
</div>

<div id="outline-container-org98cf732" class="outline-4">
<h4 id="org98cf732"><span class="section-number-4">5.1.41</span> Split is floating point like from int like in view model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-41">
<p>
At present we only have a single test data generator helper method for
any numeric type: <code>is_int_like</code>. This works ok, but it means we are not
generating useful test data for doubles, e.g: <code>1.0</code> instead of a
slightly more useful <code>1.2345</code> or some such number.
</p>

<p>
We need a <code>is_floating_point_like</code> method to be able to distinguish
between them, and then the associated changes in the generators to
create floating point numbers.
</p>
</div>
</div>

<div id="outline-container-org736849d" class="outline-4">
<h4 id="org736849d"><span class="section-number-4">5.1.42</span> Inline comments in <code>comment_formatter</code> are a hack&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-42">
<p>
We need to tidy-up comment formatter. We had introduced
<code>documenting_previous_identifier</code> rather than "comment inline" but in
reality we do need to distinguish these two use cases. If there are
several lines, we want to finish each line with a new line. However,
if thee is just one line, as is the case with enumerations, we do not
want to add any new lines. This is because the stitch template will
add new lines so we end up with too many of them.
</p>
</div>
</div>

<div id="outline-container-orgc158025" class="outline-4">
<h4 id="orgc158025"><span class="section-number-4">5.1.43</span> Assignment operator should be protected in ABC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-43">
<p>
As per MEC 33. We should probably do the same for the move and copy
constructors.
</p>
</div>
</div>

<div id="outline-container-orgb5fd8b7" class="outline-4">
<h4 id="orgb5fd8b7"><span class="section-number-4">5.1.44</span> Full constructor parameter comments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-44">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want the complete constructor to be
documented automatically so that I don't have to do it manually.
</p>

</blockquote></div>

<p>
We could use the comments in properties to populate the comments for
the full constructor for each parameter. This would require taking the
first line of the documentation of each property and then stitching
them together for the full constructor.
</p>
</div>
</div>

<div id="outline-container-org22c805f" class="outline-4">
<h4 id="org22c805f"><span class="section-number-4">5.1.45</span> Header only models shall not generate projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-45">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to generate models with just headers
that do not result in full blown projects.
</p>

</blockquote></div>

<p>
A project with just exceptions does not need a make file, and fails to
compile if a makefile is generated. We need a way to not generate a
makefile if there are no implementation files generated.
</p>

<p>
Actually we still need a CMakeFile. We need to figure out what the
conventions are for header only projects.
</p>
</div>
</div>

<div id="outline-container-org7a8be87" class="outline-4">
<h4 id="org7a8be87"><span class="section-number-4">5.1.46</span> IO header could depend on types forward declaration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-46">
<p>
At present we are depending on the types header but it seems we could
depend only on the forward declarations.
</p>
</div>
</div>

<div id="outline-container-org7f9ea9f" class="outline-4">
<h4 id="org7f9ea9f"><span class="section-number-4">5.1.47</span> Improve streaming of empty expressions in stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-47">
<p>
We have a problem with empty expressions:
</p>

<pre class="example">
&lt;#= #&gt;
</pre>


<p>
Results in:
</p>

<pre class="example">
s &lt;&lt; &lt;&lt;
</pre>


<p>
We need to ignore empty expressions.
</p>
</div>
</div>

<div id="outline-container-org369720a" class="outline-4">
<h4 id="org369720a"><span class="section-number-4">5.1.48</span> Rename sequence formatter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-48">
<p>
The <code>sequence_formatter</code> is actually not a formatter, but a helper or
assistant.
</p>
</div>
</div>

<div id="outline-container-org54ebb19" class="outline-4">
<h4 id="org54ebb19"><span class="section-number-4">5.1.49</span> Create more "utility" members for formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-1-49">
<p>
One way of making the templates a bit more manageable is to avoid
having really complex conditions. We could simplify these by giving
them intelligible names and making them properties of the
formattables - mainly class info as that's where the complexity seems
to stem from. For example:
</p>

<pre class="example">
if ((!c.all_properties().empty() || c.is_parent()) &amp;&amp; !c.is_immutable()) {
</pre>


<p>
could be replaced with <code>has_swap</code>, or perhaps even <code>has_public_swap</code> /
<code>has_protected_swap</code>.
</p>
</div>
</div>

<div id="outline-container-orgd7a2e27" class="outline-4">
<h4 id="orgd7a2e27"><span class="section-number-4">5.1.50</span> Investigate the integration of <code>boost::log</code> with throw exception&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-50">
<p>
At present we write a lot of code like this:
</p>

<pre class="example">
BOOST_LOG_SEV(lg, error) &lt;&lt; object_not_found &lt;&lt; qn;
BOOST_THROW_EXCEPTION(indexing_error(object_not_found +
    boost::lexical_cast&lt;std::string&gt;(qn)));
</pre>


<p>
This is to ensure we log the fact that an exception occurred to make
debugging problems easier. However, it leads to a lot of duplicated
code. We need to figure out a way of simplifying this, most likely
through a macro.
</p>

<p>
Actually an even easier way would be to generate IO for exceptions; we
could simply create the exception, populate all data values, dump it
to the log file and then throw the exception.
</p>

<p>
We can then create a helper in utility to throw exceptions that
performs both the throwing and the logging. It could be a function
that assumes lg to be in the global namespace, as that is how we
normally use it. We just need to populate the exception up front.
</p>
</div>
</div>

<div id="outline-container-org7f9ed25" class="outline-4">
<h4 id="org7f9ed25"><span class="section-number-4">5.1.51</span> Change stitch's standard control block start marker to match t4&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-51">
<p>
For some reason we used <code>&lt;#+</code> as the start marker for standard control
blocks; t4 uses <code>&lt;#</code>. We should use the same as t4. One disadvantage
of t4's choice is that we now need to ensure we are not in the
presence of a expression block. We could check for expression blocks
first and if not, then check for standard control blocks.
</p>
</div>
</div>

<div id="outline-container-orgecb3814" class="outline-4">
<h4 id="orgecb3814"><span class="section-number-4">5.1.52</span> Improve stitch's processing of inline statements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-52">
<p>
At present we have very different handling for the different kinds of
inline statements:
</p>

<ul class="org-ul">
<li>directives</li>
<li>expression blocks</li>
<li>standard control blocks</li>
</ul>

<p>
However, they follow the same pattern and could be implemented with
largely the same algorithm:
</p>

<p>
Generic processing of an inline statement:
</p>

<ul class="org-ul">
<li>check start and end markers: <code>validate_start_and_end_markers</code>.</li>
<li>strip start and end markers: <code>strip_start_and_end_markers</code>.</li>
<li>check for any marker, if present error: has<sub>markers</sub>=.</li>
<li>if directive, check for kvp form.</li>
</ul>

<p>
There is no need for looping etc.
</p>
</div>
</div>

<div id="outline-container-orgc9928eb" class="outline-4">
<h4 id="orgc9928eb"><span class="section-number-4">5.1.53</span> Consider moving <code>add_model_module</code> to flags&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-53">
<p>
When we implemented support for <code>add_model_module</code> in yarn mock factory
we added the flag to all relevant methods. We could have added it to
the flags instead. The downside of this approach is that we have
static factories in specs, so all tests will have the same set of
flags. Still, intuitively it sounds like all tests should have it
either on or off for a given class being tested. Patch:
</p>

<pre class="example">
@@ -82,7 +82,8 @@ public:
             const bool resolved = false,
             const bool concepts_indexed = false,
             const bool properties_indexed = false,
-            const bool associations_indexed = false);
+            const bool associations_indexed = false,
+            const bool add_model_module = false);

     public:
         /**
@@ -139,6 +140,14 @@ public:
         void associations_indexed(const bool v);
         /**@}*/

+        /**
+         * @brief If true, adds a module for the model.
+         */
+        /**@{*/
+        bool add_model_module() const;
+        void add_model_module(const bool v);
+        /**@}*/
+
     private:
         bool tagged_;
         bool merged_;
@@ -146,6 +155,7 @@ public:
         bool concepts_indexed_;
         bool properties_indexed_;
         bool associations_indexed_;
+        bool add_model_module_;
     };
</pre>
</div>
</div>

<div id="outline-container-orgfa781eb" class="outline-4">
<h4 id="orgfa781eb"><span class="section-number-4">5.1.54</span> Add a configuration class to logical model's mock factory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-54">
<p>
Every time we need to extend the mock factory we are finding we need
to modify every single function. This is particularly painful due to
the fact we rely on defaults. For example, we can't easily add an
external module path because we need to modify every single method. We
need to look into patterns for this. One option would be to create a
factory configuration class that has the super set of all parameters
required and pass that configuration to each function.
</p>

<p>
We did add the flags to the constructor, but it would be better if we
could pass in the configuration for each method invocation rather than
for the entire factory.
</p>
</div>
</div>

<div id="outline-container-org520a5e5" class="outline-4">
<h4 id="org520a5e5"><span class="section-number-4">5.1.55</span> Consider using boost pointer container for formatters&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-55">
<p>
At present we are using a container of shared pointers to house the
different formatter types. These are then encased on a "container"
class. However, in reality we are passing around references to that
container class; it seems we do not need shared pointers at all. We
should look into using a <a href="http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/ptr_container.html#motivation">boost pointer container</a>. We do not have dogen
support for this so we would have to add it first.
</p>
</div>
</div>

<div id="outline-container-orgba20554" class="outline-4">
<h4 id="orgba20554"><span class="section-number-4">5.1.56</span> Clean up stitch terminology using markup fundamentals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-56">
<p>
We came up with a number of quick definitions for stitch because we
needed them for our use cases. However, the names we chose were fairly
random. We should look into the theory around markup languages to name
these things properly.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Markup_language">Wikipedia's page on Markup Languages</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb3394df" class="outline-4">
<h4 id="orgb3394df"><span class="section-number-4">5.1.57</span> Consider adding stitch support for class feature control blocks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-1-57">
<p>
T4 supports an additional type of control blocks called class
features. These permit declaring methods on the class (external
functions for us) that can then be called by the standard control
blocks.
</p>

<p>
From a stitch perspective we don't necessarily need these, because the
stitch template is not bound to a given function (such as the
transform function in the T4 case); rather, one has to declare the
function that wraps the template within the template itself.
</p>

<p>
At any rate, this story is a place holder for further analysis on this
in case there is a sensible way to use these class feature control
blocks within stitch.
</p>

<p>
One interesting twist to this is that class feature blocks can also
contain text blocks. This means we would have two separate cases of
mixed blocks.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.olegsych.com/2008/02/t4-class-feature-blocks/">Understanding T4: Class Feature Blocks</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/bb126478.aspx">Writing a t4 template</a> (section Class feature control blocks).</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdc74ce9" class="outline-3">
<h3 id="orgdc74ce9"><span class="section-number-3">5.2</span> Unclassified</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org3d7bb1f" class="outline-4">
<h4 id="org3d7bb1f"><span class="section-number-4">5.2.1</span> Handling empty primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
In certain cases we may want to represent the notion of an empty /
optional primitive. This could easily be achieved by having an
optional of the primitive. However, maybe the primitive itself could
have support for optionality? Given we use primitives for very simple
types, we could probably "optimise" it instead of having pointers to
ints etc.
</p>
</div>
</div>

<div id="outline-container-org77c2d9c" class="outline-4">
<h4 id="org77c2d9c"><span class="section-number-4">5.2.2</span> Add equals operator to primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
At present we need to extract the value in order to make comparisons.
</p>
</div>
</div>

<div id="outline-container-orge1d0a45" class="outline-4">
<h4 id="orge1d0a45"><span class="section-number-4">5.2.3</span> Org-mode and rountripping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-2-3">
<p>
With org-mode we will be able to sync selected elements from the
source code:
</p>

<ul class="org-ul">
<li>get properties from manually crafted classes. No use case for this
yet.</li>
<li>get all test names. This can be used to generate the org-mode test
file with org-babel.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb7c1f77" class="outline-3">
<h3 id="orgb7c1f77"><span class="section-number-3">5.3</span> Injection</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Changes to injection.
</p>
</div>
</div>

<div id="outline-container-org0a55f85" class="outline-3">
<h3 id="org0a55f85"><span class="section-number-3">5.4</span> Logical Model</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Changes to the core.
</p>
</div>
</div>

<div id="outline-container-org5abcd4a" class="outline-3">
<h3 id="org5abcd4a"><span class="section-number-3">5.5</span> Extraction</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Changes to facets, formatters, etc.
</p>
</div>
</div>

<div id="outline-container-orgb578006" class="outline-3">
<h3 id="orgb578006"><span class="section-number-3">5.6</span> Feature Heap</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Features for which there is no urgency but we'd like to see them
implemented at some point. They may require some alterations to the
core, but not fundamental rethinking.
</p>
</div>


<div id="outline-container-org5178aca" class="outline-4">
<h4 id="org5178aca"><span class="section-number-4">5.6.1</span> Consider using PMR strings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
We should create a report that provides a size distribution of files
in Dogen. This would enable us to figure out if there is a "common
size" that most files have. If so, it may make sense to create PMR
strings to represent files so that we do not require dynamic
allocation for string concatenation when generating files. However, we
should probably only look into this after considering a move to <code>fmt</code>.
</p>

<p>
Even if we don't use PMR, this could still be useful if there is a way
to pre-allocate these strings like one can do with vectors. We should
also try to use the content string for the formatting.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://blog.feabhas.com/2019/03/thanks-for-the-memory-allocator/">Thanks for the memory (allocator)</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgec8be6f" class="outline-4">
<h4 id="orgec8be6f"><span class="section-number-4">5.6.2</span> Consider adding attributes to meta-model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-2">
<p>
Programming languages such as C#, Java and C++ support annotating
types with attributes. This should be really easy to do via
meta-data. We just need to capture these as attributes in the
meta-model and then code-generate the appropriately. We should also
allow attributes in properties.
</p>
</div>
</div>

<div id="outline-container-org0d06cc8" class="outline-4">
<h4 id="org0d06cc8"><span class="section-number-4">5.6.3</span> Consider making conversions a generation concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-3">
<p>
Strange idea, and one for which we haven't given a lot of thought, but
captured just so we don't forget. At present we have Dia model files
side by side with JSON model files (well, not exactly side by side but
in proximity). Which makes one wonder: what if the conversion into
different injection formats was supported directly in the dogen
meta-model? That is, imagine a world where there is a meta-model
element representing the model itself. Its not a big stretch to think
that we could also have a second representation for the model, with
some feature indicating a conversion is required and a pointer to the
model (it could a meta-type specific for this, such as
<code>model::conversion</code> or some such and with the appropriate
"destination" injector). Then dogen would run a conversion of that
model. This would make our life easier because every time we generated
a model, we would automatically convert it into any of the types we
set the model to convert to. If the tests were then clever enough to
test all supported formats then we wouldn't even have to remember to
add models.
</p>
</div>
</div>

<div id="outline-container-orgdb1e783" class="outline-4">
<h4 id="orgdb1e783"><span class="section-number-4">5.6.4</span> Consider generating model generation tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-4">
<p>
At present we are manually adding model generation tests (e.g. the
tests that check if a model's output is the same as what is currently
in the file system). This is a bit painful and we end up forgetting to
add new models. Ideally we want dogen to generate these tests. We also
want dogen to automatically test all the supported injectors (e.g. if
there are files for injection X we want the tests to pick that up
dynamically and test them).
</p>

<p>
One slight problem though is that we don't want to generate all
generated tests on regular builds; we just want to generate these
tests. Then, on the nightly we want to generate all tests. This
requires some thinking.
</p>
</div>
</div>

<div id="outline-container-org7a07462" class="outline-4">
<h4 id="org7a07462"><span class="section-number-4">5.6.5</span> Consider computing hashes only once for immutable types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-5">
<p>
if a type is immutable the hash should be computed once at
construction and then cached. Not quite sure how this would be
implemented though since we have hashing as a totally separate aspect
from types.
</p>
</div>
</div>

<div id="outline-container-org80e712b" class="outline-4">
<h4 id="org80e712b"><span class="section-number-4">5.6.6</span> Dump transforms as serialisable data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-6">
<p>
Now we have detailed transform information, it would be great if we
could also load the serialised data. At present this is not possible
because we are using IO output so that it is easily diffable. However,
we could either:
</p>

<ul class="org-ul">
<li>add rapid JSON support, so its both readable and serialisable;</li>
<li>add command-line options to determine the output format, so that we
can dump data as boost serialisation instead.</li>
</ul>

<p>
The second is low-hanging fruit.
</p>

<p>
Once we have this, we can then write simple tests that read the
serialised data and use it to reproduce bugs, narrowed to a specific
transform. This would be extremely useful once we have
code-generationa as a service.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add a file format parameter to tracing for model dumps</b>
</p>

<p>
At present we are dumping all models in probing as JSON. It would be
nice to be able to dump them as boost serialisation so we can plug
them into tests or to reproduce some problem. It would be even nicer
if we could plug that data back in to dogen but its not obvious how
that would work; we need to have some kind of concept of "stages", and
then supply the inputs and the stage so that dogen could continue from
there.
</p>

<p>
One slight downside of this is that we'd need serialisation support
for all core models. But its still very useful.
</p>
</div>
</div>

<div id="outline-container-org863a415" class="outline-4">
<h4 id="org863a415"><span class="section-number-4">5.6.7</span> Add a new annotation type of "pair"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-7">
<p>
It would be nice to be able to declare a annotation type with a value
type of "pair" or "key value pair" and have the annotations
automatically perform the splitting. The separator should not be
equals, since we already use that for annotations kvps, but it could
be comma, pipe, etc. The API would be augmented to return a
<code>std::pair</code> with key and value.
</p>

<p>
One slight snag: the value could be of any type:
</p>

<ul class="org-ul">
<li>boolean</li>
<li>string</li>
<li>enumeration (when we support these)</li>
<li>even text collection</li>
</ul>

<p>
We can start by just supporting strings, but probably worthwhile
having a think on how to specify the type.
</p>
</div>
</div>

<div id="outline-container-org1951a71" class="outline-4">
<h4 id="org1951a71"><span class="section-number-4">5.6.8</span> Add support for "colour themes" to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-8">
<p>
At present we arbitrarily colour coded the UML elements according to
our preferences, mapping stereotypes to colours. The extensible way to
do this is to add a feature to a named configuration called
colour. Then once we have a python API we could ask python to retrieve
the mapping between stereotypes and colours and apply it (as per
current script). If we make the colours standard RGB, they can also be
used in other frontends. We must also include entries for metamodel
elements such as <code>dogen::enumeration</code>.
</p>

<p>
We should have a metamodel element for this. The keys could be simply:
</p>

<pre class="example">
masd.METAMODEL_ELEMENT.colour=RGB
</pre>


<p>
Then, we could expose the metamodel element from SWIG into python.
</p>

<p>
Actually this is even more useful in the context of Plant UML. We just
need to create a "table" of identifiers, either by meta-model element
name or by stereotype. The meta-model element should work like
profiles allowing inheritance. Or at least dogen could define a base
"table" for elements which can be overriden by the user.
</p>
</div>
</div>

<div id="outline-container-org66d3790" class="outline-4">
<h4 id="org66d3790"><span class="section-number-4">5.6.9</span> Consider adding inheritance support to modelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-9">
<p>
Though it is probably overkill, it would be nice to be able to
inherit from modelines; then we could define all the common fields
on a parent.
</p>

<p>
A slightly different take is that modelines, enums, etc could benefit
greatly from templates just like objects. However the only problem is
we can't use the exact same approach, or we'd end up with 2N
elements. We need some kind of way of declaring a template (what we
will in the future call traits) and associate it with a meta-model
element.
</p>
</div>
</div>

<div id="outline-container-orgc8a1819" class="outline-4">
<h4 id="orgc8a1819"><span class="section-number-4">5.6.10</span> Create a mock factory facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-10">
<p>
A very common pattern we have in dogen is that for a small number of
types we need to create a mock factory. This is normally made in a
test folder and the file must be hand-crafted. It would be nice to
have dogen code-generate the skeletons for the mock factories. For
this we would need a meta-element for mock factories (with the new
ideas on meta-model transparency, we can't just add a switch to the
target element any longer). Ideally we would also have an associated
wale template to give us a good head start.
</p>
</div>
</div>

<div id="outline-container-org9a91249" class="outline-4">
<h4 id="org9a91249"><span class="section-number-4">5.6.11</span> Consider making editor a meta-data element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-11">
<p>
When we create meta-data elements for technical space, facet, etc we
should also consider making one for editors. We probably only need a
few properties such as start of modeline, etc.
</p>
</div>
</div>

<div id="outline-container-org1e02c0a" class="outline-4">
<h4 id="org1e02c0a"><span class="section-number-4">5.6.12</span> Add support for multiple profile binds per modeling element&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-12">
<p>
At present we can only bind an element to one profile. The reason why
is because we've already expanded the profile graphs into a flat
annotation and if we were to apply two of these expanded annotations
with common parents, the second application would overwrite the
first. Of course, we bumped into the exact same problem when doing
profile inheritance; there it was solved by ensuring each parent
profile is applied only once for each graph.
</p>

<p>
One possible solution for this problem is to consider each model
element as a "dynamic profile" (for want of a better name; on the fly
profile?). We would create a profile which is named after each of the
profiles it includes, e.g. say we include <code>dogen::hashable</code> and
<code>dogen::pretty_printable</code> for model element e0. Then the "on the fly
profile" would be:
</p>

<pre class="example">
dogen::hashable_dogen::pretty_printable
</pre>


<p>
It would be generated by the profiler, with parents <code>dogen::hashable</code>
and <code>dogen::pretty_printable</code>, and cached so that if anyone shows up
with that same profile we can reuse it. Because of the additive nature
of profile graphs this would have the desired result. Actually we
could probably have a two pass-process; first identify all of the
required dynamic profiles and generate them; then process them. This
way we can rely on a const data structure.
</p>

<p>
This will all be made easier when we have a two-pass pipeline because
we can do the profile processing on the first pass, and we can even
generate the "dynamic profiles" as real meta-model elements, created
on the fly.
</p>

<p>
Note that this is a very complex story with the potential to cause a
lot of problems. We should only start to tackle it when there is a
very good use case.
</p>
</div>
</div>

<div id="outline-container-orgfff5bae" class="outline-4">
<h4 id="orgfff5bae"><span class="section-number-4">5.6.13</span> Consider adding text transform details to generation marker&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-13">
<p>
It would be nice if we could tell which formatter generated which
file. We could add this to the generation marker:
</p>

<pre class="example">
add_model_to_text_transform_details
</pre>


<p>
In reality, since the formatter binds to the archetype, we could just
print the fully qualified physical location. We need to understand how
that would work in the existing boilerplate formatter - we need an
additional field to be added.
</p>
</div>
</div>

<div id="outline-container-org55926e1" class="outline-4">
<h4 id="org55926e1"><span class="section-number-4">5.6.14</span> Add a "info" activity to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-14">
<p>
This is somewhat similar to the dry run mode and diff mode so we need
to think about it properly. The gist of it is that we want a mode that
dumps lots of details about a model:
</p>

<ul class="org-ul">
<li>all the models it will load and their SHA1 hashes and git SHA1
hashes</li>
<li>whether generation would work or what errors it found.</li>
<li>details on the objects found in each model.</li>
<li>whether generation would modify any files and if so which files
(just the names).</li>
</ul>

<p>
Note that we've already have a dumpspecs activity. We need to make
sure there is a clear distinction between the two so users don't get
confused.
</p>
</div>
</div>

<div id="outline-container-org706c75b" class="outline-4">
<h4 id="org706c75b"><span class="section-number-4">5.6.15</span> Allow user supplied enumerator values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-15">
<p>
Now that we have value support in injection, it should be fairly
straightforward to allow users to supply their own enumeration
values. When this happens we need to check that:
</p>

<ul class="org-ul">
<li>they are unique and valid according to enumeration type;</li>
<li>they do not class with invalid value.</li>
</ul>

<p>
Actually we have implemented this but using meta-data for some
reason. We need to remove the meta-data support and use the value
field instead.
</p>

<pre class="example" id="org511490d">
    {
      "name": "features::enumerator",
      "documentation": "Parameters related to enumerators.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "property",
        "masd.variability.archetype_location.kernel": "masd",
        "masd.variability.template_kind": "instance"
      },
      "attributes": [
        {
          "name": "masd.enumerator.value",
          "type": "masd::variability::text",
          "documentation": "Value to use for this enumerator. Must be unique for an enumeration.\n",
          "tagged_values": {
            "masd.variability.qualified_name": "masd.enumerator.value",
            "masd.variability.is_optional": "true"
          }
        }
      ]
    },
</pre>
</div>
</div>

<div id="outline-container-orgceb75a5" class="outline-4">
<h4 id="orgceb75a5"><span class="section-number-4">5.6.16</span> Consider adding support for JWT&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-16">
<p>
JSON Web Tokens (JWT) are used in web apps.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Thalhammer/jwt-cpp">jwt-cpp</a>: A header only library for creating and validating json web
tokens in c++.</li>
<li><a href="https://github.com/arun11299/cpp-jwt">cpp-jwt</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc39a04a" class="outline-4">
<h4 id="orgc39a04a"><span class="section-number-4">5.6.17</span> Investigate the uses of <code>nameOf</code> in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-17">
<p>
Seems like someone ported <code>nameOf</code> from C# into C++. This is a useful
idea: instead of using a string to copy across a name, it enforces
that the string and the name are in sync. For example:
</p>

<pre class="example">
const std::string book = "book";
</pre>


<p>
The problem is that you can rename the variable <code>book</code> to a different
name and this would then result in silly errors. With <code>nameOf</code>:
</p>

<pre class="example">
const std::string book = nameOf(book);
</pre>


<p>
Now if you change <code>book</code> then this will not compile.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Neargye/nameof">nameof GH</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgdb4e265" class="outline-4">
<h4 id="orgdb4e265"><span class="section-number-4">5.6.18</span> Consider adding support for secure string&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-18">
<p>
Interesting project to port the secure string ideas from C# to C++:
"SecureString is a C++ class that does not save data as plain-text in
memory."
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/alex-caelus/SecureString">SecureString</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf2f592c" class="outline-4">
<h4 id="orgf2f592c"><span class="section-number-4">5.6.19</span> Update static strings to string views&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-19">
<p>
Now we're on C++17 we can start making use of its new features. One
low hanging fruit is string view. We use static strings quite a lot
for logging etc. We can just replace these with string views.
</p>

<p>
Example:
</p>

<pre class="example">
#include &lt;string_view&gt;
constexpr std::string_view foo("abc");
</pre>


<p>
We started implementing this story but it will take a while to
complete it across the entire codebase.
</p>

<p>
Problems:
</p>

<ul class="org-ul">
<li>cannot do XML text reader because we do not have a good way to
convert string<sub>view</sub> to cstr. See <a href="https://stackoverflow.com/questions/48081436/how-you-convert-a-stdstring-view-to-a-const-char">How you convert a std::string<sub>view</sub>
to a const char*?</a></li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.bfilipek.com/2018/10/strings17talk.html">Let's Talk About String Operations in C++17</a></li>
<li><a href="https://developercommunity.visualstudio.com/content/problem/24487/constexpr-stdstring-view-from-string-literal.html">constexpr std::string<sub>view</sub> from string literal</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/cw35kk/best_practices_for_efficient_string_constants/">Best practices for efficient string constants</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1764da0" class="outline-4">
<h4 id="org1764da0"><span class="section-number-4">5.6.20</span> Add string view to dogen exception constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-20">
<p>
At present we cannot build an exception if the string passed in is a
string view.
</p>
</div>
</div>

<div id="outline-container-org206470a" class="outline-4">
<h4 id="org206470a"><span class="section-number-4">5.6.21</span> Add support for the "badge" pattern&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-21">
<p>
We should be able to implement this pattern in Dogen.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://awesomekling.github.io/Serenity-C++-patterns-The-Badge/">Serenity C++ patterns: The Badge</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/bzjbu1/serenity_c_patterns_the_badge/">reddit discussion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1ac7278" class="outline-4">
<h4 id="org1ac7278"><span class="section-number-4">5.6.22</span> Add support for <code>fixed_storage_arrays</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-22">
<p>
This is a library with some fixed size arrays. We need to check to see
if we support array syntax at present.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/recatek/fixed_storage_arrays">github</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1d8a282" class="outline-4">
<h4 id="org1d8a282"><span class="section-number-4">5.6.23</span> Consider exceptions with stream to build exception message&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-23">
<p>
Consider adding some functionality to exceptions whereby we could
create the exception with a stream:
</p>

<pre class="example">
exception e;
e &lt;&lt; "some blurb" &lt;&lt; 123;
throw e;
</pre>


<p>
Or maybe we need an exception builder that takes in a type T:
</p>

<pre class="example">
exception_builder&lt;exception&gt; b;
b &lt;&lt; "some blurb" &lt;&lt; 123;
throw b.build();
</pre>


<p>
This is a really common use case.
</p>

<p>
Actually we just need to understand boost exception better. It seems
it already supports all of these use cases out of the box.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_72_0/libs/exception/doc/tutorial_transporting_data.html">Transporting of Arbitrary Data to the Catch Site</a></li>
<li><a href="https://theboostcpplibraries.com/boost.exception">Chapter 56. Boost.Exception</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd0eee8a" class="outline-4">
<h4 id="orgd0eee8a"><span class="section-number-4">5.6.24</span> Add support for proper JSON serialisation in C++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-24">
<p>
We need to add support for JSON in C++. It will eventually have to
roundtrip to JSON in C# but that will be handled as two separate
stories. We need to support multiple available backends because there
are so many c++ libraries available. Different users may have
different needs (e.g. if you are already using boost spirit it may
make sense to use it, if you have casablanca you may want its support
etc.). This does complicate things for testing. We should limit
ourselves to libraries that have vcpkg ports. Tests can roundtrip
between different implementations.
</p>

<p>
We will not replace the current IO implementation; it should continue
to exist as is, requiring no external dependencies.
</p>

<p>
We should consider supporting multiple JSON libraries: instead of
making the mistake we did with serialisation where we bound the name
<code>serialization</code> with boost serialisation, we should call it by its
real name, e.g. <code>json_spirit</code> etc. Then when a user creates a
stereotype for a profile such as <code>Serializable</code> it can choose which
serialisation codecs to enable for which language. This means that the
same stereotypes can have different meanings in different
architectures, which is the desired behaviour.
</p>

<p>
We should create a serialise / deserialise functions following the
same logic as boost:
</p>

<pre class="code"><code><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">serialize</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span>, <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">object</span>&amp; <span style="color: #85DDFF;">o</span><span style="color: #C586C0;">)</span>;
<span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">serialize</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span>, <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">base</span>&amp; <span style="color: #85DDFF;">b</span><span style="color: #C586C0;">)</span>;

<span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">deserialize</span><span style="color: #C586C0;">(</span><span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span>, <span style="color: #35CDAF;">object</span>&amp; <span style="color: #85DDFF;">o</span><span style="color: #C586C0;">)</span>;
<span style="color: #35CDAF;">base</span>* <span style="color: #D9DAA2;">deserialize</span><span style="color: #C586C0;">(</span><span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span><span style="color: #C586C0;">)</span>;
</code></pre>

<p>
Or perhaps even better, we can make the above the internal methods and
use <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> as the external methods:
</p>

<pre class="code"><code><span style="color: #35CDAF;">void</span> <span style="color: #339CDB; font-weight: bold;">operator</span><span style="color: #D9DAA2;">&lt;&lt;</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span>, <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">object</span>&amp; <span style="color: #85DDFF;">o</span><span style="color: #C586C0;">)</span>;
<span style="color: #35CDAF;">void</span> <span style="color: #339CDB; font-weight: bold;">operator</span><span style="color: #D9DAA2;">&gt;&gt;</span><span style="color: #C586C0;">(</span><span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">Value</span>&amp; <span style="color: #85DDFF;">v</span>, <span style="color: #35CDAF;">object</span>&amp; <span style="color: #85DDFF;">o</span><span style="color: #C586C0;">)</span>;
</code></pre>

<p>
Notes:
</p>

<ul class="org-ul">
<li>create a registrar with a map for each base type. The function
returns a base type pointer.</li>
<li>when you deserialize a base type pointer, you call the pointer
deserialize above. Same for when you have a pointer to an object. It
will internally call the registrar (if its a base type) and get the
right function.</li>
<li>this means we only need to look at type for inheritance. Although we
should probably always do it for validation? However, what happens
if we want to make a model so we can read external JSON? It won't
contain type markings.</li>
<li><code>operator&gt;&gt;</code> will not be defined for pointers or base classes.</li>
<li>this wont work for the case of <code>doc &lt;&lt; base</code>. For this we need a map
that looks up on type<sub>index</sub>.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://bitbucket.org/sobjectizerteam/json_dto-0.2/src/default/#markdown-header-what-is-json_dto">JSON DTO</a>: "json<sub>dto</sub> library is a small header-only helper for
converting data between json representation and c++ structs."</li>
<li><a href="https://github.com/Tencent/rapidjson">RapidJSON</a></li>
<li><a href="https://github.com/nlohmann/json">JSON</a></li>
<li><a href="https://github.com/open-source-parsers/jsoncpp">JSON CPP</a></li>
<li><a href="https://github.com/Donerkebap13/DonerSerializer">DonerSerializer</a></li>
<li><a href="https://www.codeproject.com/Articles/20027/JSON-Spirit-A-C-JSON-Parser-Generator-Implemented">JSON Spirit</a></li>
<li><a href="https://github.com/miloyip/nativejson-benchmark">nativejson-benchmark</a>: project comparing JSON libraries.</li>
<li><a href="https://github.com/dropbox/json11">Json11</a></li>
<li><a href="https://github.com/beached/daw_json_link">daw<sub>json</sub><sub>link</sub></a>: more "static" JSON library. Also has its own code
generator: <a href="https://github.com/beached/json_to_cpp">json<sub>to</sub><sub>cpp</sub></a>.</li>
<li><a href="https://github.com/simdjson/simdjson">simdjson</a>: parsing gigabytes of JSON per second
<a href="https://simdjson.org">https://simdjson.org</a>. See also <a href="https://lemire.me/blog/2020/03/31/we-released-simdjson-0-3-the-fastest-json-parser-in-the-world-is-even-better/">this post</a>.</li>
<li><a href="https://github.com/awangk/ujson">ujson</a>: json is a a small, C++11, UTF-8, JSON library</li>
<li><a href="https://github.com/ultrajson/ultrajson">ultrajson</a>: Ultra fast JSON decoder and encoder written in C with
Python bindings</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Rapid JSON support</b>
</p>

<p>
For the previous attempt to integrate RapidJson see this commit:
</p>

<p>
b2cce41 * third party: remove includes and rapid json
fc4edeb416 integration generation.cpp: remove rapid json remnants
</p>

<p>
<b>Add support for JSON serialisation</b>
</p>

<p>
We should have proper JSON serialisation support, for both reading and
writing. We can then implement IO in terms of JSON.
</p>

<p>
<b>Raw JSON vs cooked JSON</b>
</p>

<p>
If we do implement customisable JSON serialisation, we should still
use the raw format in streaming. We need a way to disable the cooked
JSON internally. We should also re-implement streaming in terms of
this JSON mode.
</p>

<p>
<b>Add serialisation support for JSON</b>
</p>

<p>
It seems we do not yet have a story for this. The idea is to have some
basic JSON roundtripping support. The user can configure the backend.
</p>
</div>
</div>

<div id="outline-container-org3451596" class="outline-4">
<h4 id="org3451596"><span class="section-number-4">5.6.25</span> Consider adding support for Hypothesis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-25">
<p>
This seems like a very interesting property based testing
framework. Perhaps we can understand the basic concepts and port it to
Dogen.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://hypothesis.works/">https://hypothesis.works/</a>: main site</li>
<li><a href="https://hypothesis.works/articles/intro/">articles on hypothesis</a></li>
<li><a href="https://hypothesis.works/articles/what-is-hypothesis/">What is Hypothesis?</a></li>
<li><a href="https://github.com/HypothesisWorks/hypothesis/tree/master/hypothesis-python">GH hypothesis python</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1d1337c" class="outline-4">
<h4 id="org1d1337c"><span class="section-number-4">5.6.26</span> Investigate <code>machine.specifications</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-26">
<p>
Yet another approach to testing:
</p>

<div class="epigraph"><blockquote>
<p>
Machine.Specifications is a Context/Specification framework geared
towards removing language noise and simplifying tests. [&#x2026;] MSpec is
called a "context/specification" test framework because of the
"grammar" that is used in describing and coding the tests or "specs".
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/machine/machine.specifications">GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org36e88ee" class="outline-4">
<h4 id="org36e88ee"><span class="section-number-4">5.6.27</span> Finish adding support for Language Agnostic Models (LAM)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-27">
<p>
Tasks:
</p>

<ul class="org-ul">
<li>add the missing types to LAM.</li>
<li>add optional to the list of types. This is actually quite
complicated because for some types in C# you want to map it to
nullable, to others just a pointer will do.</li>
</ul>

<p>
LAM type map:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">C++</th>
<th scope="col" class="org-left">C#</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">lam::byte</td>
<td class="org-left">unsigned char</td>
<td class="org-left">uchar</td>
</tr>

<tr>
<td class="org-left">lam::character</td>
<td class="org-left">char</td>
<td class="org-left">char</td>
</tr>

<tr>
<td class="org-left">lam::integer8</td>
<td class="org-left">std::int8<sub>t</sub></td>
<td class="org-left">sbyte</td>
</tr>

<tr>
<td class="org-left">lam::integer16</td>
<td class="org-left">std::int16<sub>t</sub></td>
<td class="org-left">System.Int16</td>
</tr>

<tr>
<td class="org-left">lam::integer32</td>
<td class="org-left">std::int32<sub>t</sub></td>
<td class="org-left">System.Int32</td>
</tr>

<tr>
<td class="org-left">lam::integer64</td>
<td class="org-left">std::int64<sub>t</sub></td>
<td class="org-left">System.Int64</td>
</tr>

<tr>
<td class="org-left">lam::integer</td>
<td class="org-left">int</td>
<td class="org-left">int</td>
</tr>

<tr>
<td class="org-left">lam::single<sub>floating</sub></td>
<td class="org-left">float</td>
<td class="org-left">float</td>
</tr>

<tr>
<td class="org-left">lam::double<sub>floating</sub></td>
<td class="org-left">double</td>
<td class="org-left">double</td>
</tr>

<tr>
<td class="org-left">lam::boolean</td>
<td class="org-left">bool</td>
<td class="org-left">bool</td>
</tr>

<tr>
<td class="org-left">lam::string</td>
<td class="org-left">std::string</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">lam::date</td>
<td class="org-left">boost::gregorian::date</td>
<td class="org-left">System.DateTime</td>
</tr>

<tr>
<td class="org-left">lam::time</td>
<td class="org-left">boost::posix<sub>time</sub>::time<sub>duration</sub></td>
<td class="org-left">System.TimeSpan</td>
</tr>

<tr>
<td class="org-left">lam::date<sub>time</sub></td>
<td class="org-left">boost::posix<sub>time</sub>::ptime</td>
<td class="org-left">System.DateTime</td>
</tr>

<tr>
<td class="org-left">lam::decimal</td>
<td class="org-left">std::decimal</td>
<td class="org-left">System.Decimal</td>
</tr>

<tr>
<td class="org-left">lam::dynamic<sub>array</sub>&lt;T&gt;</td>
<td class="org-left">std::vector&lt;T&gt;</td>
<td class="org-left">System.Collections.Generic.List&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::static<sub>array</sub>&lt;T&gt;</td>
<td class="org-left">std::array&lt;T&gt;</td>
<td class="org-left">System.Collections.Generic.Array&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::unordered<sub>dictionary</sub>&lt;K, V&gt;</td>
<td class="org-left">std::unordered<sub>map</sub>&lt;K, V&gt;</td>
<td class="org-left">System.Collections.Generic.Dictionary&lt;K, V&gt;</td>
</tr>

<tr>
<td class="org-left">lam::ordered<sub>dictionary</sub>&lt;K, V&gt;</td>
<td class="org-left">std::map&lt;K, V&gt;</td>
<td class="org-left">System.Collections.Generic.SortedDictionary&lt;K, V&gt;</td>
</tr>

<tr>
<td class="org-left">lam::unordered<sub>set</sub>&lt;K&gt;</td>
<td class="org-left">std::unordered<sub>set</sub>&lt;K&gt;</td>
<td class="org-left">System.Collections.Generic.HashSet&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::ordered<sub>set</sub>&lt;K&gt;</td>
<td class="org-left">std::set&lt;K&gt;</td>
<td class="org-left">System.Collections.Generic.SortedSet&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::queue&lt;T&gt;</td>
<td class="org-left">std::queue&lt;T&gt;</td>
<td class="org-left">System.Collections.Generic.Queue&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::stack&lt;T&gt;</td>
<td class="org-left">std::stack&lt;T&gt;</td>
<td class="org-left">System.Collections.Generic.Stack&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::linked<sub>list</sub>&lt;T&gt;</td>
<td class="org-left">std::list&lt;T&gt;</td>
<td class="org-left">System.Collections.Generic.LinkedList&lt;T&gt;</td>
</tr>

<tr>
<td class="org-left">lam::pointer&lt;T&gt;</td>
<td class="org-left">boost::shared<sub>ptr</sub>&lt;T&gt;</td>
<td class="org-left">&lt;erase&gt;</td>
</tr>
</tbody>
</table>

<p>
<b>Previous Understanding</b>
</p>

<p>
When we start supporting more than one language, one interesting
feature would be to be able to define a model once and have it
generated for all supported languages. This would be achieved by
having a system model (or set of system models) that define all the
key types in a language agnostic manner. For example:
</p>

<pre class="example">
lam::string
lam::int
lam::int16
</pre>


<p>
Each of these types then has a set of meta-data fields that map them
to a type in a supported language:
</p>

<pre class="example">
lam:string: cpp.concrete_type_mapping = std::string
lam:string: csharp.concrete_type_mapping = string
</pre>


<p>
And so on. We load the user model that makes use of LAM, we generate
the merged model still with LAM types and then we perform a
translation for each of the supported and enabled languages: for every
LAM type, we replace all its references with the corresponding
concrete type. We need to split the supplied mapping into a QName, use
the QName to load the system models for that language, look up the
type and replace it. After the translation no LAM types are left. We
end up with N yarn merged models where N is the number of supported and
enabled languages.
</p>

<p>
Each of these models is then sent down to code generation. This should
be equivalent to manually generating models per language - we could
use this as a test.
</p>

<p>
Once we have LAM, it would be great to be able to exchange data
between languages. This could be done as follows:
</p>

<ul class="org-ul">
<li>XML: create a "LAM" XML schema, and a set of formatters that read
and write from it. This is kind of like reverse mapping the types
back to LAM types when writing the XML.</li>
<li>JSON: similar approach to XML, minus the schema.</li>
<li>POF: use the coherence libraries to dump the models into POF.</li>
</ul>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>create the LAM model with a set of basic types.</li>
<li>add a set of mapping fields into yarn: <code>yarn.mapping.csharp</code>, etc
and populate the types with entries for each supported language.</li>
<li>create a notion of mapping of intermediate models into
languages. The input is the merged intermediate model and the output
is N models one per language. We also need a way to associate
backends with languages. Each model is sent down to its backend.</li>
<li>note that reverse mapping is possible: we should be able to
associate a type on a given language with it's lam type. This means
that, given a model in say C#, we could reconstruct a yarn lam model
(or tell the user about the list of failures to map). This should be
logged as a separate story.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/741054/mapping-between-stl-c-and-c-sharp-containers">Mapping between stl C++ and C# containers</a></li>
<li><a href="http://stackoverflow.com/questions/3659044/comparison-of-c-stl-collections-and-c-sharp-collections">Comparison of C++ STL collections and C# collections?</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb02c50e" class="outline-4">
<h4 id="orgb02c50e"><span class="section-number-4">5.6.28</span> Add support for "naming rules"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-28">
<p>
The framework design guidelines has a number of suggestions for how
naming should be done for different meta-types such as enums, etc. We
could have "naming profiles" that validate that the user is following
those guidelines. We could also have a "dictionary" that checks the
spelling, looking for things such as log<sub>in</sub> vs login etc.
</p>

<p>
We should have numbers (or names) for each of these warnings and add a
convention such as <code>-W</code> and <code>-Wno</code> so that users can enable and
disable warnings. These can be placed globally or locally on elements.
</p>
</div>
</div>

<div id="outline-container-org2a5c798" class="outline-4">
<h4 id="org2a5c798"><span class="section-number-4">5.6.29</span> Add knobs to control output of constructors and operators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-29">
<p>
At present we are outputting all of the default constructors and the
operators in the handcrafted templates. Ideally it should just be the
class name. We need a way of controlling all of the default
constructors and all of the operators in one go so we can set it on
the handcrafted profile.
</p>
</div>
</div>

<div id="outline-container-org881ec21" class="outline-4">
<h4 id="org881ec21"><span class="section-number-4">5.6.30</span> Add support for type<sub>index</sub>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-30">
<p>
At present we cannot create containers using <code>std::type_index</code> as a
key because we do not have hashing, IO and serialisation support. This
will require PDM support.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/36219532/serializing-stdtype-index">Serializing `std::type<sub>index</sub>`</a></li>
<li><a href="https://www.boost.org/doc/libs/1_69_0/doc/html/boost_typeindex.html">Boost typeindex</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0c194d2" class="outline-4">
<h4 id="org0c194d2"><span class="section-number-4">5.6.31</span> Support only specific attributes for certain facets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-31">
<p>
Whenever an object has a unique identifier, it may make sense to make
use of it for:
</p>

<ul class="org-ul">
<li>hashing</li>
<li>equality</li>
<li>less than</li>
</ul>

<p>
And so forth. For example, names and name trees don't really require
comparing the entire state of the object. We need a way to mark
properties against each facet in the meta-data. This should ideally
join in with the ORM concept of a primary key. We need to extract that
notion out of ORM and generalise it. Users can then decide if they
want to use all attributes or just the primary key. For less than we
need to know that all attributes in the key support less than. This
must be supplied by the PDM.
</p>
</div>
</div>

<div id="outline-container-org2504a97" class="outline-4">
<h4 id="org2504a97"><span class="section-number-4">5.6.32</span> Consider supporting non-boost exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-32">
<p>
It should be fairly trivial to disable the use of boost exception when
generating exceptions. This would allow us to create a model that is
totally independent of boost. We could do this via meta-data flags. We
probably should have several "types" of exceptions:
</p>

<ul class="org-ul">
<li>user defined (no dependencies)</li>
<li>inherits <code>std::exception</code></li>
<li>inherits <code>boost::exception</code></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Consider supporting user supplied exception base class</b>
</p>

<p>
For models that interface with other models, it may make sense to have
an exception class that is derived from a user defined class. We could
easily support an exception base class supplied via meta-data. The
user would have to expose the type via JSON.
</p>
</div>
</div>

<div id="outline-container-org2efbab7" class="outline-4">
<h4 id="org2efbab7"><span class="section-number-4">5.6.33</span> Serialisable and ioable exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-33">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to send exceptions across the wire so
that I can report errors to remote users. I also want to dump
exceptions to the log file.
</p>

</blockquote></div>

<p>
At present we only generate the types facet for exceptions. However,
there is nothing stopping us from adding serialisation support for
exceptions. This would be useful for example for services to convey
errors on the remote end point. The same logic applies to io.
</p>

<p>
This should be fairly straightforward since exceptions are simple
types. We haven't got a use case for it yet though.
</p>
</div>
</div>

<div id="outline-container-orgf48998e" class="outline-4">
<h4 id="orgf48998e"><span class="section-number-4">5.6.34</span> Use error codes in exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-34">
<p>
Avoid breaking tests every time the exception text changes by creating
a error code property in exceptions.
</p>

<p>
After some investigation it was found that boost already supports this
approach in <code>system</code>, as per <a href="http://en.highscore.de/cpp/boost/errorhandling.html">boost book</a>. We could define a new
category per model and then create an enumeration of all error codes
in dia, for which the values would be the strings to use for the
error. The user could then create an exception and pass in the error
code in the constructor.
</p>

<p>
We should also make use of string tables to define all the error
messages.
</p>

<p>
Could we just have an exception factory that handles all of the
machinery of creating an exception with the right code, message etc?
it could also be responsible for appending more content to an existing
exception so that we'd have the tags all in one place.
</p>

<p>
Alternatively we could have each exception define the supported error
codes. This would allow us to code generate them. The only problem is
if multiple exceptions share an error code, but this should probably
not happen?
</p>
</div>
</div>

<div id="outline-container-orga057e6e" class="outline-4">
<h4 id="orga057e6e"><span class="section-number-4">5.6.35</span> Control the emission of pragma once with meta-data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-35">
<p>
At present we are always adding <code>#pragrma once</code> to the header guard:
</p>

<pre class="example">
#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
#pragma once
#endif
</pre>


<p>
This should really be optional and controlled via dynamic extensions,
probably at the c++ model level.
</p>
</div>
</div>

<div id="outline-container-org597e5b2" class="outline-4">
<h4 id="org597e5b2"><span class="section-number-4">5.6.36</span> Consider adding <code>with</code> support for fluent properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-36">
<p>
It seems the java guys have decided to add the prefix <code>with</code> when
using fluent interfaces, e.g.:
</p>

<pre class="example">
x.with_property_x(false).with_property_y(true);
</pre>


<p>
We could easily add this via dynamic extensions, e.g.: fluent prefix.
</p>
</div>
</div>

<div id="outline-container-org18eaf4b" class="outline-4">
<h4 id="org18eaf4b"><span class="section-number-4">5.6.37</span> Consider creating a netty like builder for fluency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-37">
<p>
An alternative to fluent properties is to have a fluent builder, as
used by Netty quite extensively. This allows the class itself to
remain immutable; the builder just calls the complete constructor at
the end. We could easily have a "buildable" stereotype that generates
a builder just like we do for visitor.
</p>

<p>
See <a href="https://github.com/netty/netty/blob/master/example/src/main/java/io/netty/example/echo/EchoServer.java">this example</a> (ServerBootstrap in particular).
</p>

<p>
The slight problem though is that we would then require the builder to
propagate down through all objects the object has attributes of (and
their objects and so forth). So we'd have to create a lot of builders
by just marking one type as buildable. Alternatively, it would be up
to the user to mark those types individually and we just expect the
user to give us a value for a given type (probably much more
sensible).
</p>

<p>
Stereotype: <code>masd::buildable</code>.
</p>
</div>
</div>

<div id="outline-container-orgb92f6c3" class="outline-4">
<h4 id="orgb92f6c3"><span class="section-number-4">5.6.38</span> Make test data generator more configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-38">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to configure test data generation so
that I don't have to handle corner cases manually.
</p>

</blockquote></div>

<p>
One thing that would be useful is to have a way to attach lambdas to
test data generator. Let <code>a</code> be a class with a property <code>prop</code> of type
string. It would be nice to be able to do:
</p>

<pre class="example">
a_generator g;
g.prop([](const unsigned int seed) {
    std::ostringstream s;
    s &lt;&lt; "my property " &lt;&lt; seed * 10;
    return s.str();
});
</pre>


<p>
And so on, for all member variables. The generators would have some
default behaviour, but it could be overridden at any point by the
user. With this, test data generator would be a great starting point
as a way of generating random data for test systems.
</p>

<p>
See also <a href="http://www.json-generator.com/">JSON generator</a>.
</p>
</div>
</div>

<div id="outline-container-org6e038e8" class="outline-4">
<h4 id="org6e038e8"><span class="section-number-4">5.6.39</span> Use coroutines in test data generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-39">
<p>
We should look at these articles for ideas on how to create generators
that use coroutines.
</p>

<ul class="org-ul">
<li><a href="https://kirit.com/How%2520C%252B%252B%2520coroutines%2520work/Generating%2520Iterators">Generating Iterators</a></li>
<li><a href="https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/generator.hpp">generator.hpp</a>: sample generator for C++ 20.</li>
<li><a href="https://github.com/MiSo1289/asiochan">asiochan GH</a>: "This library provides golang-inspired channel types to
be used with ASIO awaitable coroutines. Channels allow bidirectional
message passing and synchronization between coroutines. Both
standalone and boost versions of ASIO are supported. See the
installing section on how to install and select the ASIO
distribution used."</li>
<li><a href="https://github.com/bloomberg/quantum">quantum GH</a>: "Quantum is a full-featured and powerful C++ framework
build on top of the Boost coroutine library. The framework allows
users to dispatch units of work (a.k.a. tasks) as coroutines and
execute them concurrently using the 'reactor' pattern."</li>
</ul>
</div>
</div>

<div id="outline-container-orgbf635c3" class="outline-4">
<h4 id="orgbf635c3"><span class="section-number-4">5.6.40</span> Add support for <code>std::forward_list</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-40">
<p>
We have been using <code>std::list</code> quite liberally. However, on hindsight,
for the vast majority of cases, we don't require a full blown list; a
simple forward list would do. Problem is Dogen does not support
forward lists just yet. We need to add support for these, including
solving the missing boost serialisation problem.
</p>

<p>
We seem to have partial support for this at present; the type is in
library.
</p>
</div>
</div>

<div id="outline-container-orgc74ca3c" class="outline-4">
<h4 id="orgc74ca3c"><span class="section-number-4">5.6.41</span> Add support for boost and/or std tuple&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-41">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of tuples in dogen so
that I don't have to manually generate code for types that use it.
</p>

</blockquote></div>

<p>
It would be nice to be able to use <code>std::tuple</code> and/or <code>boost::tuple</code>
from dogen. The processing would be rather similar to containers. It
would be even nicer if one could associate an enumeration to a tuple
so that the gets would be more meaningful, e.g.:
</p>

<pre class="example">
std::get&lt;my_field&gt;()
</pre>


<p>
rather than
</p>

<pre class="example">
std::get&lt;0&gt;()
</pre>


<p>
Using <code>std::tuple</code> would mean we'd have to create our own serialisers
for it most likely.
</p>
</div>
</div>

<div id="outline-container-orge75adcd" class="outline-4">
<h4 id="orge75adcd"><span class="section-number-4">5.6.42</span> Add support for posix<sub>time</sub><sub>zone</sub>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-42">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of boost posix<sub>time</sub><sub>zone</sub>
so that I don't have to manually generate code for types that use it.
</p>

</blockquote></div>

<p>
At present we need to use std::string to convey time zone
information. We should be able to use the time zones available in
boost date time library.
</p>

<p>
See boost documentation: <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/date_time/local_time.html#date_time.local_time.posix_time_zone">Posix Time Zone</a>
</p>
</div>
</div>

<div id="outline-container-orgdfb39e0" class="outline-4">
<h4 id="orgdfb39e0"><span class="section-number-4">5.6.43</span> Add support for structs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-43">
<p>
Even in C++ it is useful sometimes to define a type as a plain struct,
with no getters and setters and all members public. We could still
generate IO etc as per usual (well, almost as the API would be
different).
</p>

<p>
For this we would need a different stereotype. We need to do more
research on POCOs/PODs/POJOs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">POJO</a></li>
<li><a href="https://en.wikipedia.org/wiki/Plain_old_CLR_object">POCO</a></li>
<li><a href="https://en.wikipedia.org/wiki/Passive_data_structure">Passive data structure</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data_transfer_object">Data transfer object</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgaf7ca0f" class="outline-4">
<h4 id="orgaf7ca0f"><span class="section-number-4">5.6.44</span> Code generate C# models using msbuild&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-44">
<p>
At present we did a quick hack to code generate in C#: a simple bash
script that runs dogen. However, this is not how we expect the end
user to consume it; there should be a msbuild target that:
</p>

<ul class="org-ul">
<li>detects the code generator;</li>
<li>contains the configuration (e.g. options, location of models);'</li>
<li>runs the code generator - possibly every time models change;</li>
<li>has a tailor target to generate JSON.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb7ebc30" class="outline-4">
<h4 id="orgb7ebc30"><span class="section-number-4">5.6.45</span> Add support for package installation scripts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-45">
<p>
Once it is possible to declare dependencies and map them to different
packaging systems such as vcpkg, the next logical step is to generate
batch files for each platform to build the product dependencies. These
should be standardised.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>generate the script with a well defined name.</li>
<li>create the entire vcpkg workflow (download, build, export, upload to
dropbox).</li>
<li>create cmakefile / script to download export from dropbox.</li>
</ul>
</div>
</div>

<div id="outline-container-org2dde47c" class="outline-4">
<h4 id="org2dde47c"><span class="section-number-4">5.6.46</span> Consider adding support for iguana&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-46">
<p>
Iguana is yet another serialisation framework.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/qicosmos/iguana">https://github.com/qicosmos/iguana</a></li>
</ul>
</div>
</div>

<div id="outline-container-org130ef4d" class="outline-4">
<h4 id="org130ef4d"><span class="section-number-4">5.6.47</span> Consider adding support for ormpp&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-47">
<p>
Yet another ORM framework. It would be nice to target ODB and ormpp
using exactly the same metamodel constructs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/qicosmos/ormpp">https://github.com/qicosmos/ormpp</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6861699" class="outline-4">
<h4 id="org6861699"><span class="section-number-4">5.6.48</span> Consider adding support for Apache Arrow IPC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-48">
<p>
Yet another serialisation format.
</p>

<p>
Links:
</p>
<ul class="org-ul">
<li><a href="https://github.com/apache/arrow/tree/master/cpp/src/arrow/ipc">https://github.com/apache/arrow/tree/master/cpp/src/arrow/ipc</a></li>
</ul>
</div>
</div>

<div id="outline-container-org17f4ba4" class="outline-4">
<h4 id="org17f4ba4"><span class="section-number-4">5.6.49</span> Consider adding C#/C++ attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-49">
<p>
It may be a good idea to have attributes for generated and hand
crafted code, e.g.:
</p>

<pre class="example">
[[masd::generated]]
[[masd::handcrafted]]
</pre>


<p>
This would allow us to build some clang tool that determines if all
generated code is used from handcrafted code or not. Presumably
something similar can be done for C# and Java.
</p>

<p>
We need to compile with some kind of ignore flag
(<code>-Wattributes</code>). Once these attributes are in, we could do queries in
LSP to determine what types are used. For example, we could
find-references for a given type and then build some kind of DAG and
determine if any of that code is accessed by non-generated code.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/attributes">Attribute specifier sequence</a></li>
<li><a href="https://www.bfilipek.com/2017/07/cpp17-in-details-attributes.html">C++17 in details: Attributes</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3f0e0c1" class="outline-4">
<h4 id="org3f0e0c1"><span class="section-number-4">5.6.50</span> Consider adding a swagger frontend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-50">
<p>
Once we have HTTP API support, we can consider having a frontend for
swagger. The idea is that the user submits one or more swagger JSON
files (one per supported version of the API, e.g. <code>v1</code>, <code>v2</code> etc)
possibly with a dogen model in JSON or dia. Dogen then converts the
swagger specification into elements. We can then code-generate:
</p>

<ul class="org-ul">
<li>all the data objects;</li>
<li>all the routing code;</li>
<li>an interface that the user can implement;</li>
<li>bridge into the HTTP API support for the Rest SDK/Beast code that
binds the HTTP processing with the routing;</li>
</ul>

<p>
The generated project should be a binary with the static library
generation enabled so we can test the web code. However, users should
be allowed to choose if they want a static or shared library
instead. This is a bit tricky if there is no dogen model because we
have no way to supply meta-data.
</p>

<p>
We need to ensure we do not hard-code the OpenAPI implementation
against a specific HTTP library such as Boost.Beast or Casablanca. It
should be possible to plug it in with different libraries (even if at
generation time only, since users don't really need more than one
library at the same time).
</p>

<p>
In addition, in keeping with the move towards meta-elements to
represent all concepts, we should either implement the OpenAPI
concepts as meta-elements or as meta-data parameters. However, in this
case we probably want to keep the input in YAML (parsing it using
something like <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>) but then instantiate meta-model elements that
model OpenAPI. These are then used by the templates to generate code
(after possibly some enrichment). Interestingly, with OpenAPI we have
all that is required in order to create a service definition. The only
slight problem is that we cannot bind back to the underlying library,
even given a interface definition, because there is such a big
mismatch between the swagger API and a regular programming language
interface. From this perspective, it perhaps makes more sense to have
swagger metamodel elements instead of relying on YAML because we could
automatically generate them from the interface declaration (what is
hard is the opposite).
</p>

<p>
It appears there already exists a framework to add swagger support to
C++: <a href="https://oatpp.io/">Oat++</a>. The good news is the support looks pretty
comprehensive. The bad news is they did not build it on top of ASIO
and Best/Boost, but instead coded everything from scratch including
coroutines etc. It also means we cannot use existing Dogen JSON
support - they have their own DTO. This may not be an ideal end-state
but it seems it is really easy to get something up and running
quickly. We could just create the Swagger/OpenAPI yaml parser and then
generate Oat++ code first. The parser would be useful for other
backends. The templates themselves are probably easy to do (for
Oat). The integration with the dogen interface should be very similar,
regardless of the swagger backend (dispatch of the data coming in from
HTTP and out of the service). The only difference is that we'd be
relying on their DTO objects so we'd probably need two representations
for each object - one as a proper domain model, and a second one as a
oat DTO. We could conceivably code-generate conversion wrappers, given
that the objects are identical from a meta-model perspective. Or we
could talk to the Oat people and figure out if its possible to
integrate other DTOs with Oat. It is also not clear how JWT would be
handled - is it Oat's responsibility or the lower layers.
</p>

<p>
Finally, it may also be worthwhile trying to "port" oat++ into
Beast. That is, try to figure out how their <a href="https://github.com/oatpp/oatpp-swagger">swagger infrastructure</a>
would look like under Beast and copy across as required. They have
already done all of the artwork, HTML etc so much can be reused. The
good thing about the Dogen approach is that we do not need any
run-time support (e.g. reflection, etc). All meta-data can be
generated at compile time from the meta-model. In addition, we can
place objects in the stack as much as possible and pre-generate JSON
and reuse it.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/oatpp/oatpp">https://github.com/oatpp/oatpp</a></li>
<li><a href="http://docs.servicestack.net/swagger-api">ServiceStack Swagger integration</a></li>
<li><a href="http://radar.oreilly.com/2015/09/building-apis-with-swagger.html">Building APIs with Swagger</a></li>
<li><a href="http://petstore.swagger.io/v2/swagger.json">Swagger JSON example</a></li>
<li><a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a>: Swagger has been renamed to OpenAPI. See also <a href="https://swagger.io/specification/">this page</a>.</li>
<li><a href="https://github.com/eidheim/Simple-Web-Server">Simple-Web-Server</a>: alternative to beast.</li>
<li><a href="https://github.com/Stiffstream/restinio">RESTinio</a>: another HTTP/websockets framework based on asio.</li>
<li><a href="https://github.com/swagger-api/swagger-codegen">Swagger codegen</a>: tool for code generation of swagger APIs. See also
<a href="https://swagger.io/tools/swagger-codegen/">this link</a>.</li>
<li><a href="https://github.com/OAI/OpenAPI-Specification/tree/master/examples/v3.0">OpenAPI examples</a>: YAML documents with examples.</li>
<li><a href="https://github.com/matt-42/silicon">silicon</a>: yet another C++ HTTP framework.</li>
<li><a href="https://github.com/qicosmos/cinatra">cinatra</a>: another HTTP framework. Example site: <a href="http://purecpp.org/">http://purecpp.org/</a></li>
<li>OpenApi code generator examples: <a href="https://github.com/OpenAPITools/openapi-generator/tree/master/samples/server/petstore/cpp-pistache">petstore/cpp-pistache</a>, <a href="https://github.com/OpenAPITools/openapi-generator/tree/master/samples/server/petstore/cpp-restbed">cpp-restbed</a></li>
<li><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp GH</a>: "yaml-cpp is a YAML parser and emitter in C++ matching
the YAML 1.2 spec."</li>
</ul>
</div>
</div>

<div id="outline-container-org72eeb2c" class="outline-4">
<h4 id="org72eeb2c"><span class="section-number-4">5.6.51</span> Factory method instead of complete constructor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-51">
<p>
Perhaps it is useful to give users the option to create a static
factory method on a class instead of (in addition to?) a complete
constructor. This would be specially useful for classes that are meant
to be used as pointers. We need metadata for the given variation
points (return pointer, return object, etc). We could also then demote
the complete constructor to private so no one else can make use of
it. This would be a metadata parameter of the complete constructor.
</p>

<p>
Users can then package up this feature configuration into a sensible
"profile" such as <code>FactoryMethodConstruction</code>. It would be great if
the users could set the package to "transitive" or "non-transitive",
causing all associated objects to also have it or not.
</p>
</div>
</div>

<div id="outline-container-orga545501" class="outline-4">
<h4 id="orga545501"><span class="section-number-4">5.6.52</span> Null assertion on pointers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-52">
<p>
For languages such as C# and Java it would be nice if setters could
check if the pointer is null. This is also useful for C++. This could
be a meta-data parameter, either global or local.
</p>

<p>
Users may want to provide their own assert function which throws the
adequate exception for their use case.
</p>

<p>
Actually these should be meta-data parameters for when using a pointer
type:
</p>

<ul class="org-ul">
<li>check for null</li>
<li>exception to throw</li>
</ul>

<p>
This also means we should get the constructors to call the setters
instead of setting variables directly. We can also do this for
immutable types, but make the setters private.
</p>
</div>
</div>

<div id="outline-container-org25c6297" class="outline-4">
<h4 id="org25c6297"><span class="section-number-4">5.6.53</span> Add support for primitive validation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-53">
<p>
When defining a primitive, it may be useful to define associated
validation. For example:
</p>

<ul class="org-ul">
<li>integers in a certain range (e.g. &lt; 1000, etc).</li>
<li>strings that follow a regex</li>
</ul>

<p>
It would be nice if these validation expressions could be supplied as
meta data with the primitive in the model and then validation code
would be generated for them. We could then trigger the validation code
in the constructor.
</p>

<p>
Merged stores:
</p>

<p>
<b>Add additional primitive validation</b>
</p>

<p>
The classes that we are thinking about adding for test data are useful
in other ways such as for validation. We could have out of the box
validators for each class (where it makes sense, e.g. IP address,
etc). This is mostly useful when converting from an "untyped type"
like std::string to a stronger type such as IP Address.
</p>
</div>
</div>

<div id="outline-container-orgac3a5f0" class="outline-4">
<h4 id="orgac3a5f0"><span class="section-number-4">5.6.54</span> Add test data "types" for generated data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-54">
<p>
At present we are creating really "dumb" test data, just a prefix for
strings and a simple counter for numbers. A much better approach is
the one used by mockaroo. They have the idea of "classes", that is a
"type" for the field which is in addition to the programming type. For
example:
</p>

<ul class="org-ul">
<li>ip address</li>
<li>first name</li>
<li>last name</li>
<li>email address</li>
</ul>

<p>
and so forth (more examples below). We could easily create a set of
classes such as these ones, including constraints (e.g. maximum
characters, etc) and then encode them into dogen. These are just
configuration parameters for the test data facet. For each type we
could have an authoritative source which is just a text file. Users
can then submit new sources. Or perhaps even better: we could create a
separate open source project that is responsible for maintaining the
test data bundles. Any user can submit and make use of these
bundles. Periodically dogen snapshots the bundles and includes them
with its releases. This way we benefit from anyone who wants to help
out. The bundles should be split by language so that we can have
translations. We should use the exact same approach as regular
<a href="https://developer.wordpress.org/themes/functionality/localization/">translation files</a>.
</p>

<p>
Once we have the types, the next logical thing is to create mock
endpoints. This can be done very easily because of remoting. In
reality, we just implement the remote end point as a "fountain" using
the test data generator to produce the data. We know all of the
endpoint details due to remoting so this should be fairly trivial.
</p>

<p>
Another option is to have "local fountains". Users can supply a path
to a fountain file with data and some kind of "process" to describe
how to read the data (e.g. linear, uniform random, etc). Users can
associate the path with a type (possibly via primitives, or directly
on an attribute). Dogen creates static data structures with the data
and accesses them at run time. This exact same approach can also be
applied to the bundles described above.
</p>

<p>
We should also have an option to mark each entry as "valid" or
"invalid" so that test data sets can also include invalid data. There
should be a comment as to the purpose of the test (e.g. invalid
because). These can then be used to generate unit or system tests. For
example, for usernames we should take into account the comments in
<a href="https://www.b-list.org/weblog/2018/feb/11/usernames/">Lets talk about usernames</a> and look at <a href="https://github.com/ubernostrum/django-registration/blob/1d7d0f01a24b916977016c1d66823a5e4a33f2a0/registration/validators.py#L25">django validators</a>. We can then
perhaps create generators that are either "valid" or "invalid".
</p>

<p>
We could even have a "combined" generator that generates a percentage
of "valids" and "invalids" as supplied by the user.
</p>

<p>
In effect, instead of one generator, we would have many:
</p>

<ul class="org-ul">
<li>trivial generator: prefix for strings, with postfix; numbers in a
range, etc. Random strings with configurable sizes (readable and
unreadable characters).</li>
<li>valid realistic generator: valid entries from a domain.</li>
<li>invalid realistic generator: invalid entries from a domain</li>
<li>realistic generator: valid and invalid entries, according to
percentages.</li>
</ul>

<p>
Each generator group is associated with a class.
</p>

<p>
Actually maybe we can have multiple bundles for a given item. For
example, take company names: we may want fortune 500 or just small
companies (certain patterns with names may only appear in say small
businesses). So company names is the class, with a default bundle, but
there may be multiple bundles.
</p>

<p>
<b>More ideas</b>
</p>

<p>
Fountains are code generated from CSV files, themselves created from
massaging external project files. The fountains could have a structure
like:
</p>

<ul class="org-ul">
<li><code>masd/core/fountain/phone_number_fountain.hpp</code></li>
</ul>

<p>
Each fountain could have additional meta-data configuration,
e.g. country, partial phone numbers, etc. These are supplied by users
as meta-data when they make use of a fountain. For example, consider
primitive <code>phone_number</code> with underlying type string associated with
fountain <code>phone_number_fountain</code>. It would have meta-data setting the
country, etc. Or maybe we should just allow specialised fountains
(full phone number, partial phone number, invalid phone number,
etc). This means we could even create a composite fountain that takes
in a set of fountains and a random number distribution and then reads
from each fountain using the distribution (e.g. uniform, etc). We
could also handle countries this way (e.g. use iso codes for phone
numbers, <code>en_phone_numbers</code> etc.).
</p>

<p>
<b>More Ideas</b>
</p>

<p>
Actually a better take on this would be to create an actual
product. We could have one repository which is made up of simple test
data files, with some form of organisation. Then we could add support
to dogen to generate data generators based on those files. These could
be for any language that dogen supports. Then we'd create a product
for each language that export these generators, with a PDM mapping
that exports these so that models could consume them. This means
anyone could use the product outside of dogen and dogen binds to
it. It could live in the MASD umbrella or perhaps have its own
organisation (since we will have many languages it may just pollute
MASD). Interestingly, there is some kind of weird correlation between
"regular" PDMs and the generators. For example:
</p>

<ul class="org-ul">
<li>the boost PDM exports a type such as date time.</li>
<li><p>
the generator could contain dates, say birthdays, holiday calendars,
etc. These then can be expressed in a number of types, depending on
the library you are using. Therefore in an ideal world, the boost
PDM library should have a dependency (as far as test data generation
goes) on this new product. We could use a simple interface for this
(for example all dates are exported in some type supported by the C
library). Then the PDM uses a wrapper on top of the original
exporter to generate data in the boost format:
</p>

<p>
C time -&gt; boost time
</p>

<p>
Of course, users may then want dates as strings, etc. The key thing
is to allow for arbitrary composition of these data streams (a-la Rx
event streams, in a way).
</p></li>
</ul>

<p>
<b>Fuzzing</b>
</p>

<p>
Interestingly, the same principles could be used for fuzzing. We could
somehow have a fuzz fountain for each type which generates values from
a corpus. These could be sensitive to the type.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://mockaroo.com/">https://mockaroo.com/</a></li>
<li><a href="https://github.com/Devskiller/jfairy/tree/master/src/main/resources">jfairy</a>: seems like there is an existing open source project for
this. See also <a href="https://medium.freecodecamp.org/how-our-test-data-generator-makes-fake-data-look-real-ace01c5bde4a">this post</a>.</li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/8004406/">Automated Generator for Complex and Realistic Test Data</a>: paper on
the subject. Tool they created: <a href="https://github.com/mrfranta/jop-discontinued">jop</a></li>
<li><a href="https://gitlab.com/daamien/postgresql_anonymizer">Postgresql Anonymizer</a>: similar idea but at the database level. We
need to mine their approach for ideas.</li>
<li><a href="https://github.com/minimaxir/big-list-of-naughty-strings">Big List of Naughty Strings</a>: The Big List of Naughty Strings is an
evolving list of strings which have a high probability of causing
issues when used as user-input data.</li>
<li><a href="https://github.com/dariusk/corpora">corpora</a>: A collection of small corpuses of interesting data for the
creation of bots and similar stuff.</li>
<li><a href="https://github.com/joke2k/faker">faker</a>: Faker is a Python package that generates fake data for you.</li>
<li><a href="https://github.com/schoentoon/cxxfaker">cxxfaker</a>: basic C++ faker.</li>
<li><a href="https://github.com/vrok/randodo">randodo</a>: random strings generator</li>
<li><a href="https://github.com/emirozer/fake2db">fake2db</a>: Generate fake but valid data filled databases for test
purposes using most popular patterns.</li>
<li><a href="https://devarea.com/python-understanding-generators/#.XKX5tXVKiV4">Python  understanding generators</a></li>
<li><a href="https://picsum.photos/">Lorem picsum</a>: Lorem Ipsum but for photos. Could be used for pictures
for profiles, etc. Also: <a href="http://lorempixel.com/">lorempixel</a>. For splash screens:
<a href="https://source.unsplash.com/">unsplash</a>. <a href="https://placeimg.com/">placeimg</a> for images of places.</li>
<li><a href="https://llvm.org/docs/LibFuzzer.html">LibFuzzer</a></li>
<li><a href="https://blog.trailofbits.com/2019/05/31/fuzzing-unit-tests-with-deepstate-and-eclipser/">Fuzzing Unit Tests with DeepState and Eclipser</a></li>
<li><a href="https://generated.photos">Generated Photos</a>: AI generated realistic pictures of people. We
could download a fixed set or use the API.</li>
<li><a href="https://github.com/minimaxir/big-list-of-naughty-strings">GH big-list-of-naughty-strings</a>: The Big List of Naughty Strings is a
list of strings which have a high probability of causing issues when
used as user-input data.</li>
<li><a href="https://github.com/eliabieri/blnscpp">GH blnscpp</a>: Single header C++ API for the Big List of Naughty
Strings.</li>
<li><a href="https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words">GH List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words</a>: List of
Dirty, Naughty, Obscene, and Otherwise Bad Words</li>
<li><a href="https://voice.mozilla.org/en/about">Mozilla Common Voice</a>: Common Voice is part of Mozilla's initiative
to help teach machines how real people speak. In addition to the
Common Voice dataset, were also building an open source speech
recognition engine called Deep Speech.</li>
</ul>

<p>
Fantasy:
</p>

<ul class="org-ul">
<li><a href="https://www.mithrilandmages.com/utilities/StreetNames.php">Street and Road Name Generator</a></li>
<li><a href="https://www.mithrilandmages.com/utilities/ModernBrowse.php">List of Modern Names</a></li>
<li><a href="https://www.mithrilandmages.com/utilities/BankNames.php">Bank and Financial Services Name Generator</a></li>
<li><a href="https://www.mithrilandmages.com/utilities/CityNames.php">City &amp; Town Name Generator</a></li>
<li><a href="https://www.namegenerator2.com/country-name-generator.php#generator-bookmark">Country Name Generator</a></li>
</ul>

<p>
<b>Realistic Model Generation</b>
</p>

<p>
Another topic of interest is the generation of dogen models. If we
could somehow capture some basic notions on the fountains such as:
</p>

<ul class="org-ul">
<li>class names</li>
<li>attributes related to a class</li>
<li>relationships</li>
</ul>

<p>
We could generate realistic models. The models don't have to be
realistic in the sense of "making sense" for a given domain, they just
need to have similar characteristics to real models such as:
</p>

<ul class="org-ul">
<li>number of classes</li>
<li>number of attributes per class</li>
<li>diversity of those attributes</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org7ee51b5"></a>Example Types<br />
<div class="outline-text-5" id="text-5-6-54-1">
<ul class="org-ul">
<li>Animal Common Name</li>
<li>Animal Scientific Name</li>
<li>App Bundle ID. Three part app bundle id (com.google.powerflex, com.microsoft.prodder)</li>
<li>App Name</li>
<li>Avatar. Random avatar image url.</li>
<li>Base64 Image URL. data:image/png;base64,iVBORwoA&#x2026;</li>
<li>Binomial Distribution.</li>
<li>Bitcoin Address</li>
<li>Blank. Always generates a null value</li>
<li>Boolean</li>
<li>Buzzword</li>
<li>Car Make</li>
<li>Car Model</li>
<li>Car Model Year</li>
<li>Car VIN. A random car VIN number, not correlated to other car fields.</li>
<li>Catch Phrase</li>
<li>Character Sequence</li>
<li>City</li>
<li>Color</li>
<li>Company Name</li>
<li>Country</li>
<li>Country Code</li>
<li>Credit Card number</li>
<li>Credit Card Type. visa, mastercard, americanexpress</li>
<li>Currency. Dollar</li>
<li>Currency Code (USD, EUR, MXN)</li>
<li>Custom List. Picks items randomly or sequentially from a custom list of values</li>
<li>Dataset Column. Pick records randomly or sequentially from one of my datasets</li>
<li>Date. 07/04/2013</li>
<li>Department (Corporate). Human Resources, Accounting, Engineering</li>
<li>Department (Retail). Grocery, Books, Health &amp; Beauty</li>
<li>Digit Sequence. Create simple sequences of characters, digits, and symbols</li>
<li>Domain Name. google.com</li>
<li>Drug Company. Eli Lilly and Company, Novartis Pharmaceuticals Corporation</li>
<li>Drug Name (Brand). Cialis, Nexium, Lipitor</li>
<li>Drug Name (Generic). Naproxen Sodium, Selenium Sulfide, Acetaminophen</li>
<li>Dummy Image URL. Image url from dummyimage.com. <a href="http://dummyimage.com/250x100">http://dummyimage.com/250x100</a></li>
<li>DUNS Number. Randomly generated DUNS numbers</li>
<li>EIN. Randomly generated employer identification numbers</li>
<li>Email Address</li>
<li>Encrypt. Simulates encrypted text</li>
<li>Exponential Distribution. Generates numbers based on an exponential distribution with a specific  rate.</li>
<li>Fake Company Name. Morar Group,  Stark-Glover, Sawayn and Sons</li>
<li>Family Name (Chinese)</li>
<li>FDA NDC Code</li>
<li>File Name. lobortis.pptx, erat<sub>volutpat.csv</sub>, TortorSollicitudin.docx</li>
<li>First Name. Jim, Mark, Sasha</li>
<li>First Name (European). Choose language? Grel, Marie-jose, Hlne</li>
<li>First Name (Female). Susan, Jessica, Sasha</li>
<li>First Name (Male). Mark, Bob, Tim</li>
<li>Formula. Compute a value based on data from other columns</li>
<li>Frequency. Never, Once, Seldom, Often, Daily, Weekly, Monthly, Yearly</li>
<li>Full Name. Nancy Smith, Tim Fisher, Al Jones</li>
<li>Gender. Male, Female. Missing new genders. Should have "classical"
and "modern" gender.</li>
<li>Gender (abbrev). M, F</li>
<li>Geometric Distribution. Generates numbers based on a geometric distribution with a specific probability of success.</li>
<li>Given Name (Chinese)</li>
<li>GUID. 36 character hex guid</li>
<li>Hex Color. #142a0b</li>
<li>IBAN. FR73 5960 2948 07N1 L9TC PVYX E17, SE85 4302 3680 7231 4238 1624</li>
<li>ICD10 Diagnosis Code. ICD10 diagnosis code. Source: cms.gov.</li>
<li>IP Address v4. 121.150.202.132</li>
<li>IP Address v4 CIDR. 188.245.97.43/27</li>
<li>IP Address v6. 770:44c0:1c4:9996:2fd:6907:3045:9627</li>
<li>IP Address v6 CIDR. 9ea4:2b0b:11ba:47a3:47a8:ede4:2ddd:c5f8/115</li>
<li>ISBN. 574398570-7</li>
<li>Job Title. Design Engineer, General Manager, Help Desk Technician</li>
<li>JSON Array. Generates an array of objects in json format.</li>
<li>Language. German, English, Spanish</li>
<li>Last Name. Smith, Jones, Miller</li>
<li>Latitude. 48.52469361225269, 72.26886762838888, -12.592370752117404</li>
<li>LinkedIn Skill. Algorithms, Sports Nutrition, Payroll</li>
<li>Longitude. -45.15259533671917, 115.70563293321999, 81.9426325226724</li>
<li>MAC Address. 2C-D6-9B-77-E5-0B, 2C:D6:9B:77:E5:0B, 2c:d6:9b:77:e5:0b</li>
<li>MD5. Random hex encoded MD5 hash</li>
<li>MIME Type. text/plain, image/png, application/pdf</li>
<li>Money. $3.00, 12.94, 127,54</li>
<li>MongoDB ObjectID. Globally unique identifiers for MongoDB objects</li>
<li>Movie Genres. Action | Suspense, Thriller, Comedy</li>
<li>Movie Title. Goodfellas, Titanic, Silverado</li>
<li>Naughty String. Strings which have a high probability of causing issues when used as user-input data.</li>
<li>NHS Number. 10-digit NHS number with mod11 checksum</li>
<li>Normal Distribution. Generates random numbers in a normal distribution using the Box-Muller algorithm</li>
<li>Number. 0.25, 5.2, 1000</li>
<li>Paragraphs. Chosen randomly from lorem ipsum</li>
<li>Password. A random string of 6-12 characters. bnTZ28AFZ,
u1vn6SIM5KBA</li>
<li>Phone. 8-(598)633-6672</li>
<li>Plant Common Name. Abietinella Moss, Silver Fir, Sedge</li>
<li>Plant Family. Thuidiaceae, Pinaceae, Cyperaceae</li>
<li>Plant Scientific Name. Abietinella abietina, Abies alba</li>
<li>Poisson Distribution. Generates numbers based on a Poisson distribution with a specific mean value.</li>
<li>Postal Code. Region-specific postal codes (not available for all locations).</li>
<li>Product (Grocery). Tomato - Green, Spinach - Baby, Avocado</li>
<li>Race. Filipino, Venezuelan, Asian</li>
<li>Regular Expression. Generate random data based on a regular expression</li>
<li>Repeating Element. Repeats an XML element a specified number of times</li>
<li>Row Number. 1, 2, 3</li>
<li>Scenario. Generates a number using a saved scenario</li>
<li>Sentences. Chosen randomly from lorem ipsum</li>
<li>Sequence. Generates a sequence of numbers with adjustable step and repeat options.</li>
<li>SHA1. Random hex encoded SHA1 hash</li>
<li>SHA256. Random hex encoded SHA256 hash</li>
<li>Shirt Size. S, M, L</li>
<li>Short Hex Color. #14b, #a32, #926</li>
<li>Slogan. Randomly generated marketing slogans</li>
<li>SQL Expression. Specify a SQL expression to use as the inserted value.</li>
<li>SSN. 678-59-9455, 312-20-4597, 684-62-5799</li>
<li>State. State/Province names, US and worldwide</li>
<li>State (abbrev). Two character state/province abbreviations, US and worldwide</li>
<li>Stock Industry. Semiconductors, Major Banks, Oil &amp; Gas Production</li>
<li>Stock Market. NYSE, NASDAQ,</li>
<li>Stock Market Cap. $33.03B, $54.29M, $41.02M</li>
<li>Stock Name. Microsoft Corporation, NetApp, Inc., The Bancorp, Inc.</li>
<li>Stock Sector. Technology, Capital Goods, Finance</li>
<li>Stock Symbol. MSFT, NTAP, TBBK</li>
<li>Street Address. Street number, name, and suffix. 6449 Pine View Drive</li>
<li>Street Name. Street name and suffix. Pine View Drive</li>
<li>Street Number. A street number between 1 and 5 digits, 6449</li>
<li>Street Suffix. Drive, Terrace, Street</li>
<li>Suffix. Jr, Sr, III</li>
<li>Template. Concatenate values from several columns into one</li>
<li>Time. 3:30 PM, 15:30</li>
</ul>
<p>
0 Time Zone. America/Los<sub>Angeles</sub>, Europe/Budapest, Pacific/Fiji
</p>
<ul class="org-ul">
<li>Title. Mr, Ms, Dr</li>
<li>Top Level Domain. com, edu, org</li>
<li>University. The Johns Hopkins University, Pepperdine University, University of Texas</li>
<li>URL. <a href="https://facebook.com">https://facebook.com</a>, <a href="http://google.com/path?foo=bar">http://google.com/path?foo=bar</a>, /foo/bar</li>
<li>User Agent. A user agent string from a popular web browser or bot.</li>
<li>Username. jdoe, twilliams, jfang</li>
<li>Words. Chosen randomly from lorem ipsum</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgcba7220" class="outline-4">
<h4 id="orgcba7220"><span class="section-number-4">5.6.55</span> Add support for RPC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-55">
<p>
It would be nice to be able to mark a type as a service and then have
dogen generate all the comms for it:
</p>

<ul class="org-ul">
<li>generate a service interface with appropriate async such as using
<code>=boost::future</code> or <code>std::future</code> depending on user options. User
then has to implement this interface.</li>
<li>generate a new model called comms. For each method <code>M</code> in the
service, create two new classes named <code>M_request</code> and
<code>M_response</code>. These classes are composed of the types from the
method. Also, they will have additional fields such as security
token, status, error message, etc.</li>
<li>in comms we need to create a server. This is made up of several
layers: 1) socket setup: create a socket, open it, etc. 2)
serialiser: convert from/to raw serialisation format. 3) dispatcher:
given a message, call the appropriate method on the service and
construct the appropriate response. The server implementation owns a
service, receives messages, unpacks them and calls the service; then
takes the result packs it and returns the response.</li>
<li>similarly, we also need a client with the responsibility of calling
the server over a socket. We need to be able to support both "raw"
sockets as well as HTTP.</li>
<li>in an ideal world, we would also generate console client and server
binaries. These would automatically have the command line options
setup for them given the service request/response. They would make
use of comms.</li>
<li>validation of the security token must be done by the generated code
somehow, as must session ID management and message IDs. Generated
code must do all the logging of received messages (requests and
responses) with their correlation IDs. Composition of services must
be done by routing (e.g. assume <a href="https://github.com/envoyproxy/envoy">envoy</a> is used).</li>
<li>name of the comms model must be "original model" + <code>.comms</code>. Similar
approach for all dependent models.</li>
<li>since dogen has been hard-wired to generate one model, we need some
kind of command line parameter that we can supply to generate
RPC. Or alternatively, if there is RPC for a given model, we just
automatically generate all dependent models. Users can
enable/disable client/server etc via meta-data.</li>
<li>stereotype: <code>dogen::rpc::service</code>. We then manually create objects
with the dependent stereotypes, e.g. <code>dogen::rpm::message</code>,
etc. Note that creating these objects manually or automatically
should result in exactly the same behaviour, e.g. first implement
them manually. The automatically generated models still follow the
same approach for facets such as <code>types</code>, etc. They just have more
types such as dispatcher, serialisers, etc. These can be injected
into a model manually (e.g. <code>dogen::rpc::dispatcher</code>, etc).</li>
<li>because the service is async (or can be), the server needs to chain
to a future for the processing. Similarly, the client provides an
async interface, with a coroutine. We must use the exact same
approach for HTTP and raw socket (ideally even the same class).</li>
<li>for HTTP, users may need to set the method (e.g. PUT, POST,
etc). This could be done as meta-data. But however, we should have
an RPC stereotype that maps to these, so that we can use the same
information for both "raw" sockets and HTTP. Dia supports
stereotypes in methods, so we could have something like
<code>dogen::rpc::put</code> as a stereotype.</li>
<li>we have a story for type framing. We should implement this feature
first and then make use of it. Basically, the entire RPC
infrastructure is made up of discrete dogen features. These can be
used stand-alone.</li>
<li>we should automatically add the async and sync infrastructure. The
user can choose one or both, and we generate the
interfaces. However, user needs to manually implement the service
methods.</li>
<li>by having a single library for comms it means we will ship both
client and server on it (as well as raw and HTTP). This is not ideal
since it means clients will link to server code and also means we
will pull in the domain library. However, in practice its probably
OK because in most cases we will need to make use of the domain
library anyway unless the service is trivial. The alternative is to
have a <code>=comms.server</code> and a <code>comms.client</code> project. But since they
will share a lot of code, this sounds like overkill.</li>
<li>we need a way to set the available serialisation formats. This can
be done via meta-data. The service could also have meta-data for RPC
or non-RPC.</li>
<li>in order for this to work with the current transform chains, we need
some way to supply the target and obtain the RPC models; then we
start the existing code generation chain. However, the chains at
present are not design to receive a model as an input. We need to
wire them differently in order to cope with this use case. In
addition, we may not need all of the post-processing we have in the
text model chain at present (e.g. visitor, etc) given that we know
exactly what the generated types will be. Perhaps we can have chains
designed specifically for this use case?</li>
<li>we need to copy a lot of the model properties for the generated
models such as licence, copyright, etc, but not model name. In
theory we should be able to just override that one and copy all the
other ones. We also need to inject references.</li>
<li>If the user has enabled both C++ and C#, this should still work
(assuming we have RPC support for C#).</li>
<li>we need to add support for executables, operations, program options,
main, etc etc before we can satisfy the client/server use cases. We
need to break down this epic into all of its dependent stories.</li>
<li>ServiceStack like API interfaces should be generated automatically
if HTTP is enabled. See ServiceStack/swagger story for
details. Service comments are used for swagger comments.</li>
<li>we need to manually inject command line options such as host name,
port, log level etc. Remaining options are taken from the operations
in service. Comments provided by users on the operations can be used
for the command line description.</li>
<li>it would be great if the client could have a <code>--interactive</code> option
in which case it would then use readline and allow users to send
commands. For simple types this is trivial (perhaps quotes for
strings) but for non-simple types it would require a bit of
thinking.</li>
<li>before we start defining stereotypes, we need to read: "Towards a
UML Profile for Service-Oriented Architectures" by Reiko Heckel,
Marc Lohmann and Sebastian Thne.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Remote method invocation</b>
</p>

<p>
Look for type framing, Model and type enums stories.
</p>

<p>
It seems fairly straightforward to add remote method invocation to a
few select types. The following would have to be done:
</p>

<ul class="org-ul">
<li>create a new stereotype like <code>dispatchable</code>, <code>remotable</code> or suchlike</li>
<li>for languages which support this natively, we could map to their
technology (e.g. Beans in Java, etc).</li>
<li>create a new stereotype: interface.</li>
<li>add support for interface code generation.</li>
<li>validation: model must have a model ID, thought to be unique across
models.</li>
<li>validation: types must be marked as both <code>remotable</code> and
<code>interface</code> and have a unique type ID in the model.</li>
<li>validation: types must have at least one public method</li>
<li>injector: if at least one type is <code>remotable</code>, a new facet is
created: <code>rmi</code>.</li>
<li>injector: a system enumeration will be created with all the
supported serialisation types. actually, we should create this
anyway in serialisation or reflection.</li>
<li>rmi will contain one class that represents a "frame". this
frame will be composed as follows: model ID, type ID, serialisation
type, raw buffer. we need to look at RMI terminology to come up with
a good name for this frame.</li>
<li>messages: for each method that exists in each dispatchable service,
a message class will be created with a name following some well
defined convention such as <code>CLASS_NAME_METHOD_NAME</code>. we need
examples to make up a sensible convention. or perhaps an
implementation specific parameter can override the class name. the
message class is a data object and has as attributes all of the
parameters of the method.</li>
<li>a dispatcher class will be created in dispatching. it will have as
constructor arguments references to all the dispatchable
services. when passed in a frame, it will hydrate it and dispatch it
to the correct service.</li>
<li>a "framer" class will be created in dispatching. it will be
configured for a given serialisation type. it will take a message
object, serialise it and frame it.</li>
<li>we could support the notion of callbacks. for this we need to be
able to serialise stubs as references such that when the other end
receives it, it calls a registrar to activate a client stub.</li>
</ul>

<p>
Now we just need a way of creating some generic interfaces that take a
wire client and a wire service and plug the framer and the dispatcher
into it.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we need basic support for operations so that we can convert the
operations into messages.</li>
<li>we need some wire format support such as flat buffers.</li>
</ul>
</div>
</div>

<div id="outline-container-orgea63f06" class="outline-4">
<h4 id="orgea63f06"><span class="section-number-4">5.6.56</span> Add support for dependency graphs and complexity data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-56">
<p>
It would be nice to incorporate some of the complexity measures found
in Lako's Large-Scale C++ Software Design. We could copy across some
of the code of TomTom's <a href="https://github.com/tomtom-international/cpp-dependencies">cpp-dependencies</a> and make use of it against
the dogen model.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://gamesfromwithin.com/physical-structure-and-c-part-1-a-first-look">Physical Structure and C++  Part 1: A First Look</a></li>
<li><a href="http://gamesfromwithin.com/physical-structure-and-c-part-2-build-times">Physical Structure and C++  Part 2: Build Times</a></li>
<li><a href="https://github.com/metrixplusplus/metrixplusplus">GH metrixplusplus</a>: Metrix++ is an extendable tool for code metrics
collection and analysis.</li>
</ul>
</div>
</div>

<div id="outline-container-org2fa516d" class="outline-4">
<h4 id="org2fa516d"><span class="section-number-4">5.6.57</span> Add support for configuration as environment variables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-57">
<p>
One of the principles in the <a href="https://www.12factor.net/">12 factor app</a> is using environment
variables for all <a href="https://www.12factor.net/config">config</a>. This can then be <a href="https://www.nginx.com/blog/microservices-reference-architecture-nginx-twelve-factor-app/">managed externally</a>. Dogen
can help with the process by allowing users to define configurations
as meta-model elements. These can then be obtained from factories,
using <code>std::getenv</code>. They can have all the right types (e.g. perform
casting as required) and can even have built-in validation. For this
we can rely on the taxonomy made for test data (this will be on a
separate story). In addition, this will make mocking easier: we can
either create an interface for the factory with a mock implementation,
or the factory could receive a map on one of its constructors.
</p>

<p>
We should also take into account the story on config, as well as the
support for env variables built in to <a href="https://www.boost.org/doc/libs/1_68_0/doc/html/program_options/overview.html#id-1.3.31.5.10.3">program options</a>. The good thing
about using program options is that we'd also have support for command
line arguments as well as env variables. We'd also need a way to
describe the env variable name separately from the command line option
name, e.g. <code>hostname</code> vs <code>MY_APPLICATION_HOSTNAME</code>.
</p>

<p>
Configuration should be read by a singleton, which is initialised at
program start up. Initialisation validates config. All other calls
return the cached configuration.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/utility/program/getenv">std::getenv</a></li>
<li><a href="https://stackoverflow.com/questions/44819569/how-to-extract-environment-variable-with-boostprogram-options">How to extract environment variable with boost::program<sub>options</sub>?</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Create a base options class across all tools</b>
</p>

<p>
At present we are copying and pasting a bit of code related to general
options across all the command line tools (knitter, darter, stitcher,
tailor). We could create a base class that has the common options and
then have a factory that populates the boost program options
associated with that class.
</p>

<p>
Ideally we should also have a log initialisation class that uses those
common options.
</p>
</div>
</div>

<div id="outline-container-orgd247f18" class="outline-4">
<h4 id="orgd247f18"><span class="section-number-4">5.6.58</span> Consider adding support for SBE&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-58">
<p>
There is an efficient serialisation protocol: Simple Binary
Encoding. It supports multiple languages. We could add a facet for it.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/real-logic/simple-binary-encoding">https://github.com/real-logic/simple-binary-encoding</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9b901c9" class="outline-4">
<h4 id="org9b901c9"><span class="section-number-4">5.6.59</span> Consider adding support for magic enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-59">
<p>
Yet another enum library: <a href="https://github.com/Neargye/magic_enum">https://github.com/Neargye/magic_enum</a>. C++
17 only.
</p>
</div>
</div>

<div id="outline-container-org40f826c" class="outline-4">
<h4 id="org40f826c"><span class="section-number-4">5.6.60</span> Consider adding support for the <code>enum.hpp</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-60">
<p>
See the github repo.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/BlackMATov/enum.hpp">https://github.com/BlackMATov/enum.hpp</a></li>
</ul>
</div>
</div>

<div id="outline-container-org176adf4" class="outline-4">
<h4 id="org176adf4"><span class="section-number-4">5.6.61</span> Consider adding support for Meta Enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-61">
<p>
Meta Enum provides a number of features for enumerations. We could
simply declare enums using their library. A second useful thing is to
copy all of their features and offer them as plain code generation
features.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/therocode/meta_enum">https://github.com/therocode/meta_enum</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6cc1057" class="outline-4">
<h4 id="org6cc1057"><span class="section-number-4">5.6.62</span> Consider adding support for Better Enums library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-62">
<p>
Interesting library that wraps enumerations.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/aantron/better-enums">https://github.com/aantron/better-enums</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga1ea1a3" class="outline-4">
<h4 id="orga1ea1a3"><span class="section-number-4">5.6.63</span> Consider adding support for FWK enum library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-63">
<p>
Yet another enum library.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nadult/fwk_enum">https://github.com/nadult/fwk_enum</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgde9c1ae" class="outline-4">
<h4 id="orgde9c1ae"><span class="section-number-4">5.6.64</span> Consider adding support for bitsery serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-64">
<p>
There is yet another modern c++ serialisation library: bitsery. It
seems pretty trivial to add support for it as a facet.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/fraillt/bitsery/">https://github.com/fraillt/bitsery/</a></li>
</ul>
</div>
</div>

<div id="outline-container-org816de89" class="outline-4">
<h4 id="org816de89"><span class="section-number-4">5.6.65</span> Consider adding support for the spaceship operator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-65">
<p>
It seems C++ 20 will introduce a new operator: <code>&lt;=&gt;</code>. We should be
able to support it within Dogen. However, it will require knowing the
C++ version to ensure we do not generate it when using C++ 17 or
below.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://blog.tartanllama.xyz/spaceship-operator/">Spaceship Operator</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7257fcb" class="outline-4">
<h4 id="org7257fcb"><span class="section-number-4">5.6.66</span> Consider adding support for OutOfLine&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-66">
<p>
OutOfLine seems like an interesting pattern to improve cache
locality. It would be nice if we could make it a meta-pattern so that
we could annotate classes (e.g. <code>out_of_line</code>?) and then generate the
code to match the solution below.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://blog.headlandstech.com/2018/08/15/outofline-a-memory-locality-pattern-for-high-performance-c/">OutOfLine  A Memory-Locality Pattern for High Performance C++</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5620c7b" class="outline-4">
<h4 id="org5620c7b"><span class="section-number-4">5.6.67</span> Consider adding support for GraphQL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-67">
<p>
GraphQL is a DSL for RESTful APIs. Its largely based on JSON and a
JSON like format for queries:
</p>

<pre class="example">
getUser(id: "user_123") {
 currency,
 email,
 subscriptions
}
</pre>


<p>
Users can request specific attributes in objects from an object graph
rather than get massive objects and then pick the attributes of
interest. It raises several questions:
</p>

<ul class="org-ul">
<li>the meta-data describing all objects must be auto-generated. This
can easily be done by creating a new facet for GraphQL that contains
the meta-data for each object of interest.</li>
<li>the JSON serialisation of objects must only serialise fields of
interest as per query. The JSON serialiser must have some kind of
flags at the field level for each object which it queries to
determine if a field is enabled or not. However, we do not want to
do this on all cases or else it will slow down all JSON
serialisation. So we need two different kinds of JSON
serialisers. In addition, we will not be able to deserialise from
these JSON objects (given they are incomplete).</li>
<li>we should also develop a "querying" layer that is independent of
GraphQL so that we could reuse it for other backends. However, there
are trade-offs to be made here. We do not want arbitrary complex
queries (querying by primary key or foreign key is sufficient for
most cases) whereas GraphQL probably supports very complex queries
including joins etc.</li>
<li>complete support for GraphQL may be difficult as the DSL appears to
be very large. Perhaps we could start by supporting the basic
functionality once there are use cases.</li>
</ul>

<p>
Actually maybe we should see GraphQL as an injector rather than just
as a run time thing. In other words:
</p>

<ul class="org-ul">
<li>user creates a schema using GraphQL notation. <a href="https://github.com/graphql/libgraphqlparser/blob/master/test/schema-kitchen-sink.graphql">Example schema</a>.</li>
<li>dogen has an injector metamodel for graphql that implements facebook
representation in json of graphql. that is we use their library to
parse graphql schemas and generate json objects. we also create
entities (meta-model) for their json entities. <a href="https://github.com/graphql/libgraphqlparser/blob/master/test/schema-kitchen-sink.json">Example schema after
parse</a>. Note that the schema is parsed and interpreted "at compile
time"; that is, we generate code for the model described by the
schema.</li>
<li>at runtime we take instance documents of the schema (<a href="https://github.com/graphql/libgraphqlparser/blob/master/test/kitchen-sink.graphql">example</a>) and
convert these into JSON (<a href="https://github.com/graphql/libgraphqlparser/blob/master/test/kitchen-sink.json">example</a>). Note that the generated
meta-model must be able to represent instances of the queries.</li>
<li>at this point we have a query representation in memory. The system
then needs to go and execute the query (domain code). Once the
results come back, we then convert them into the generated model and
"somehow" supply the query as parameterisation for JSON
serialisation; that is, the query states which fields we should
serialise out.</li>
</ul>

<p>
Either way, it seems there are two approaches:
</p>

<ul class="org-ul">
<li>we can start with a GraphQL schema and treat it as a model
(injector); or</li>
<li>we can start with a model and generate its GraphQL schema.</li>
</ul>

<p>
In either case, we then need to have some model that represents
GraphQL queries dynamically, and the ability to only serialise out a
subset of elements in a given object as per the query.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://brandur.org/graphql">https://brandur.org/graphql</a></li>
<li><a href="https://github.com/graphql/libgraphqlparser">https://github.com/graphql/libgraphqlparser</a></li>
<li><a href="https://github.com/microsoft/cppgraphqlgen">https://github.com/microsoft/cppgraphqlgen</a></li>
<li><a href="http://graphql.github.io/learn/queries/">http://graphql.github.io/learn/queries/</a></li>
<li><a href="https://github.com/DavidUser/GraphQL-Cpp">https://github.com/DavidUser/GraphQL-Cpp</a></li>
<li><a href="https://github.com/caffeinetv/CaffQL">https://github.com/caffeinetv/CaffQL</a></li>
<li><a href="https://github.com/chentsulin/awesome-graphql">https://github.com/chentsulin/awesome-graphql</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7448547" class="outline-4">
<h4 id="org7448547"><span class="section-number-4">5.6.68</span> Consider adding support for compile time mocking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-68">
<p>
In a post in HN, a user <a href="https://news.ycombinator.com/item?id=17504197">suggested the following</a>:
</p>

<pre class="example">
mehrdadn 1 hour ago [-]

I'm just saying do conditional compilation instead of virtual dispatch, since
you generally shouldn't really need both the test and production
implementations to run inside the same program. So if you have reason to
require
  // widget.h
  class Widget { virtual void throb(); };
  // widget.cc
  class WidgetImpl : public Widget { void throb() { ... } };
  class WidgetTest : public Widget { void throb() { ... } };
then, instead of that, just do
  // widget.h
  class Widget { void throb(); };
  // widget.cc
  void Widget::throb() { ... }
  // widget.test.cc
  void Widget::throb() { ... }
where you only compile widget.cc for the production build, and only compile
widget.test.cc for the test build.
</pre>


<p>
Dogen could automatically support this by having a "compile time mock"
stereotype. The targets for tests and for the binary would be
automatically generated adding the correct object files. However, this
could easily cause problems if we're not careful. For example, what if
a library A wants to use mocks from library B. Library A should only
include its mocks when it is built in "test mode" but not in
production mode, so this means we need two different builds of the
library. However, if we officialised these builds, e.g.:
</p>

<ul class="org-ul">
<li>A.mock.so</li>
<li>A.so</li>
</ul>

<p>
And created targets specifically for these then perhaps there would be
no confusion. The other problem is that when we mock we must mock
everything (as there is only one mock build for the library). Thus we
cannot test selectively. We should also not inline any functions in
the header. For this we could put comments/attributes marking the
class as "compile time mockable" so that developers are aware.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.fluentcpp.com/2018/08/21/default-parameters-mocking/">Integrating Mocking With C++ Default Parameters</a>: article with
techniques to simulate mocking without a mock framework.</li>
</ul>
</div>
</div>

<div id="outline-container-org9699583" class="outline-4">
<h4 id="org9699583"><span class="section-number-4">5.6.69</span> Consider integrating a sqitch like approach&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-69">
<p>
It would be nice to have a way to manage relational schemas, etc from
within a dogen model. Sqitch seems to have an interesting approach,
which may even suit ODB.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://metacpan.org/pod/sqitchtutorial">https://metacpan.org/pod/sqitchtutorial</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc346ee1" class="outline-4">
<h4 id="orgc346ee1"><span class="section-number-4">5.6.70</span> Add support for entity framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-70">
<p>
It seems there is a C# entity framework which is some kind of ORM.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/ef/core/">Entity Framework Core Quick Overview</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbc68a92" class="outline-4">
<h4 id="orgbc68a92"><span class="section-number-4">5.6.71</span> Add dogen specific binary serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-71">
<p>
Given we know the internals of the model types to serialise, there is
nothing to stop us from serialising types directly instead of relying
on third party serialisation APIs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://legacy.gitbook.com/book/arobenko/comms-protocols-cpp/details">Guide to Implementing Communication Protocols in C++ (for Embedded
Systems)</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4cc4359" class="outline-4">
<h4 id="org4cc4359"><span class="section-number-4">5.6.72</span> Add support for MARISA&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-72">
<p>
This seems like a useful data structure:
</p>

<ul class="org-ul">
<li><a href="https://github.com/s-yata/marisa-trie">marisa-trie</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbdd2f11" class="outline-4">
<h4 id="orgbdd2f11"><span class="section-number-4">5.6.73</span> Consider using Boost.PolyCollection in model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-73">
<p>
We have a collection of elements at present in model. It appears there
is a more efficient way of storing collections of base types by using
Boost.PolyCollection. We just need to expose these types. We also need
to figure out their serialisation support.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_67_0/doc/html/poly_collection.html">Boost.PolyCollection</a></li>
</ul>
</div>
</div>

<div id="outline-container-org28c66b9" class="outline-4">
<h4 id="org28c66b9"><span class="section-number-4">5.6.74</span> Add support for units&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-74">
<p>
It would be good to add support for the different units libraries:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nholthaus/units">units</a></li>
<li><a href="http://www.boost.org/doc/libs/1_65_1/doc/html/boost_units.html">boost units</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9b752a1" class="outline-4">
<h4 id="org9b752a1"><span class="section-number-4">5.6.75</span> Add support for boost UUID&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-75">
<p>
It seems boost has a proper UUID type. We should use this instead of
strings.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.boost.org/doc/libs/1_65_1/libs/uuid/uuid.html">Uuid docs</a></li>
</ul>
</div>
</div>

<div id="outline-container-org164f9fc" class="outline-4">
<h4 id="org164f9fc"><span class="section-number-4">5.6.76</span> Add support for object cloning&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-76">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to be able to clone object state so
that I don't have to do this manually.
</p>

</blockquote></div>

<p>
We should have a clone method which copy constructs all non-pointer
types, and then creates new objects for pointer types.
</p>

<p>
Ideally users should be able to mark specific object as "cloneable"
rather than generate clone methods for all objects in a model since it
only makes sense for objects which have pointers. We need some
meta-data knob to control the generation of the clone method.
</p>
</div>
</div>

<div id="outline-container-orgb87a7f6" class="outline-4">
<h4 id="orgb87a7f6"><span class="section-number-4">5.6.77</span> Add support for boost pointer container&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-77">
<p>
It should be fairly straightforward to add support for the boost
pointer containers: list, vector, array, set, map, unordered set and
unordered map. In general we can rely on the existing families for the
STL containers. The only snag is that the element on the pointer
container is a pointer in some cases - but no all, as the container
will automatically dereference sometimes. This means we may have some
weird impedance mismatches.
</p>

<p>
We already have serialisation support for all containers.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.boost.org/doc/libs/1_64_0/libs/ptr_container/doc/headers.html">Pointer Container Library - Library Headers</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6630db2" class="outline-4">
<h4 id="org6630db2"><span class="section-number-4">5.6.78</span> Use pointer container&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-78">
<p>
We should look for cases where we can simplify things using pointer
containers. Two use cases spring to mind:
</p>

<ul class="org-ul">
<li>at present we are using shared pointers on all registrars. This
makes no sense as the pointer ownership is clear (the registrar owns
the pointer). We should use a boost pointer container and pass
references around, via reference wrapper where required.</li>
<li>model has a container of shared pointer of element. We don't really
need the shared pointer abilities; once allocated these are pretty
const.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd18ca62" class="outline-4">
<h4 id="orgd18ca62"><span class="section-number-4">5.6.79</span> Add support to foreign keys in ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-79">
<p>
At present we are not generating foreign keys for ODB.
</p>
</div>
</div>

<div id="outline-container-org4774f82" class="outline-4">
<h4 id="org4774f82"><span class="section-number-4">5.6.80</span> Add column name support to ORM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-80">
<p>
At present we need to fall back to ODB pragmas in order to rename a
column. We should have <code>yarn.orm.column_name</code>.
</p>
</div>
</div>

<div id="outline-container-org2eca98f" class="outline-4">
<h4 id="org2eca98f"><span class="section-number-4">5.6.81</span> Allow users to override string prefixes in test data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-81">
<p>
At present we have a hard-coded string prefix in test data:
=a<sub>string</sub>_". This has been is fine up to now, but we have bumped into
a problem when using it with ORM: some fields in the database are too
small to fit the prefix (e.g. <code>VARCHAR[5]</code>). The quick solution for
this is to make the prefix customisable when we instantiate the
generator.
</p>

<p>
Actually this is not quite that straightforward: in order to allow
users to configure the string prefix, we'd have to extend all helpers
to have a "prefix" argument of type string because we do not know
which helpers are the string helpers. An alternative is to have a test
data configuration, with the following configurable points:
</p>

<ul class="org-ul">
<li>string prefix</li>
<li>path prefix</li>
<li>numeric start</li>
<li>date start</li>
</ul>

<p>
The configuration is an optional parameter supplied to the
generator. If empty we use the default configuration which could
potentially be read from meta-data, although we do not have a use case
for this.
</p>

<p>
However, we have a slight problem: if a model M0 has types from
another model M1, we will end up with two configurations (one per
model). When we call a M0 generator which calls an M1 generator, we
need to somehow send the configuration across as well. Since they are
different types (even though identical in layout) we need to copy the
configuration across. This could be achieved with a template
method. Alternatively we could make all helper methods a template
method that takes in a configuration:
</p>

<pre class="code"><code><span style="color: #339CDB; font-weight: bold;">template</span><span style="color: #C586C0;">&lt;</span><span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #35CDAF;">Configuration</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #D9DAA2;">create_XYZ</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">unsigned</span> <span style="color: #35CDAF;">int</span> <span style="color: #85DDFF;">position</span>, <span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">Configuratio</span>&amp; <span style="color: #85DDFF;">c</span><span style="color: #C586C0;">)</span> <span style="color: #C586C0;">{</span>
...
<span style="color: #C586C0;">}</span>
</code></pre>

<p>
Actually this won't work: we still have the problem of calling
external generators.
</p>

<p>
A simpler but less typed solution is to use <code>std::tuple</code>:
</p>

<pre class="example">
std::tuple&lt;std::string, std::string, int, int&gt; configuration
</pre>


<p>
The other interesting point is that this is perhaps an ORM
problem. After all, we could have a <code>VARCHAR[2]</code> string, and
configuring the prefix won't help. What we really need is to figure
out how many digits one can put in the string, given the available
size. Users can supply the sizes as part of the ORM configuration. We
can then do a simple heuristic:
</p>

<ul class="org-ul">
<li>does the prefix fit? if not, drop it.</li>
<li>what is the max value for the counter that will fit the string size?
Use it as a modulus.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfba41e0" class="outline-4">
<h4 id="orgfba41e0"><span class="section-number-4">5.6.82</span> Add a top-level "Visual Studio" knob&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-82">
<p>
We have a number of features that only make sense when on Windows and
building for Visual Studio. We should have a top-level knob that
enables or disables all of these features in one go:
</p>

<ul class="org-ul">
<li><code>quilt.cpp.visual_studio.enabled</code></li>
</ul>

<p>
However, we don't really seem to have a way to "link" features such
that when a feature is enabled all of its sub-features are enabled. We
have some hacks for this for the relationship between facets and
formatters but this is not general. We need a general way to declare a
dependency between two "things" and to state a few rules for B depends
on A:
</p>

<ul class="org-ul">
<li>if A is explicitly enabled, it does not matter if B is enabled or
disabled.</li>
<li>if A is not explicitly enabled, it is enabled if B is enabled and
vice-versa; it defaults to B.</li>
<li>if B is not explicitly enabled, it uses its default value.</li>
</ul>

<p>
It should be possible to declare arbitrary graphs with these
dependencies.
</p>

<p>
In this way we'd see features as a graph, with platform-independent
and platform-specific nodes:
</p>

<ul class="org-ul">
<li>platform independent: types, test<sub>data</sub>, io, serialisation, visual
studio, etc.</li>
<li>platform specific: c++ types. c++ test data. boost serialisation,
c++ visual studio, etc.</li>
</ul>

<p>
Dependencies between features can be static or dynamic:
</p>

<ul class="org-ul">
<li>static means that the state of the instances of the meta-model are
not relevant to determining the outcome.</li>
<li>dynamic means the opposite.</li>
</ul>

<p>
For example, forward declarations has a dynamic dependency on types
because depending on the state of the type we may need to force it to
come out. For example, if there is a pointer.
</p>

<p>
It would be nice if we could move all of these machinery into yarn or
quilt. It doesn't make a lot of sense to place it in either, to be
fair, since its not a platform-independent meta-model concept
(e.g. yarn) and whilst it is a platform-specific concept, it is not
kernel specific. Perhaps it should leave on its own model.
</p>

<p>
There are several aspects:
</p>

<ul class="org-ul">
<li>the total list of formatters and facets</li>
<li>the relationships between them</li>
<li>functions for the dynamic dependencies that take in an element</li>
<li>the computation of the enablement.</li>
</ul>

<p>
Actually this should be implemented in terms of profiles.
</p>
</div>
</div>

<div id="outline-container-org8f044ca" class="outline-4">
<h4 id="org8f044ca"><span class="section-number-4">5.6.83</span> Add support for Visual Studio C++ projects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-83">
<p>
Visual studio project needs the files to be listed by hand. We can
either generate the project or the user has to manually add the
files. This is a problem every time they change. Requirements:
</p>

<ul class="org-ul">
<li>we need to be able to support multiple VS versions as well (user
configurable)</li>
<li>user may want to import property sheets</li>
<li>need guids (as per C# projects)</li>
<li>need additional library/include directories</li>
<li>need to add pre-compiled headers support with /FI.</li>
<li>add a solution for good measure, using the C# code.</li>
<li>add filter files for headers and source files.</li>
</ul>

<p>
As per ODB, users may also want to build with different versions of
VS. We should allow generating more than one solution and postfix them
with the VS version.
</p>

<p>
We should also generate filters for the project:
</p>

<ul class="org-ul">
<li>header files</li>
<li>source files</li>
<li>ODB header files</li>
<li>ODB source files</li>
</ul>

<p>
The inclusion of ODB files must be done using regular expressions
because we do not want to have to do two passes for knit; so we don't
really know what files are available. However, if the ODB files have a
<code>cxx</code> extension, we can just <code>CLInclude</code> <code>*cxx</code>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://msdn.microsoft.com/en-us/library/2208a1f2.aspx">Project Files</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5c8dbd5" class="outline-4">
<h4 id="org5c8dbd5"><span class="section-number-4">5.6.84</span> Add support for exports on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-84">
<p>
We should add export macros for shared objects/DLLs for windows. We
should create a file <code>exports.hpp</code> probably at top-level with all the
exports.
</p>

<pre class="example" id="orgfcd2bd0">
#pragma once

#ifdef MODEL_DECL
    #undef MODEL _DECL
#endif

#ifdef MODEL _EXPORTS
    #define MODEL _DECL __declspec(dllexport)
#else
    #define MODEL _DECL __declspec(dllimport)
#endif
</pre>

<p>
It is used as follows:
</p>

<pre class="example">
class MODEL_DECL Tags xxx
</pre>


<p>
We should probably also add GCC support.
</p>

<ul class="org-ul">
<li><a href="https://gcc.gnu.org/wiki/Visibility">GCC Visibility</a></li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/16982144/cmake-and-generateexportheader">cmake and GenerateExportHeader</a>: maybe we should just use the CMake
support.</li>
</ul>
</div>
</div>

<div id="outline-container-org195993b" class="outline-4">
<h4 id="org195993b"><span class="section-number-4">5.6.85</span> Add export macros support for Linux&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-85">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to export types selectively so that I
can control what external users can depend on.
</p>

</blockquote></div>

<p>
We've already looked into adding exports for Windows. There is also a
GCC equivalent explained <a href="https://gcc.gnu.org/wiki/Visibility">here</a>.
</p>

<p>
We should have some dynamic extensions to control the outputting of
these.
</p>
</div>
</div>

<div id="outline-container-org8dd26cd" class="outline-4">
<h4 id="org8dd26cd"><span class="section-number-4">5.6.86</span> Add <code>targetver.h</code> support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-86">
<p>
On windows we should be generating the targetver header.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/RadialController/cpp/targetver.h">targetver.h</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcf7914a" class="outline-4">
<h4 id="orgcf7914a"><span class="section-number-4">5.6.87</span> Add support for DLL Main on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-87">
<p>
At present we are manually generating DLL Main by hand and then
excluding it on regexes. This is not ideal and will be more of a
problem when we generate project files. Ideally we should code
generate it. Requirements:
</p>

<ul class="org-ul">
<li>user must be able to disable it;</li>
<li>user must be able to handcraft it in case they want different
contents;</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://msdn.microsoft.com/en-us/library/aa370448(v%3Dvs.85).aspx">DLL Main</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdb2636f" class="outline-4">
<h4 id="orgdb2636f"><span class="section-number-4">5.6.88</span> Add support for pre-compiled headers on windows&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-88">
<p>
Most VS users have pre-compiled headers. We need to generate
<code>stdafx.h</code> etc. For now we can have it minimally populated until we
understand better the requirements.
</p>

<p>
Actually we could probably do a very simple computation in quilt to
figure out the most frequently used headers and add those to
<code>stdafx</code>. We just need to go through the entire model in the inclusion
expander to perform this calculation.
</p>

<p>
In addition we need to make sure <code>stdafx</code> is added as the first
include.
</p>

<p>
We should have a quilt setting for pre-compilation. We should also
check that visual studio support is enabled in order to generate
<code>stdafx</code>.
</p>
</div>
</div>

<div id="outline-container-org322332e" class="outline-4">
<h4 id="org322332e"><span class="section-number-4">5.6.89</span> Add case conversion support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-89">
<p>
When we map a LAM model into C#, it will have whatever case we used
originally. This is not ideal as in C++ we'd like to use underscores
instead. It would be nice if there was an "identifier converter" that
went through the model and updated all identifiers from underscores to
camel case. This includes classes, attributes, enumerators, etc. The
LAM model would remain with underscores.
</p>

<p>
For this to work correctly we'd need some kind of "casing" enumeration
associated with the model, and then another one associated with each
language. This means that if the model is already in camel case, we
would just generate camel case for both C++ and C#.
</p>
</div>
</div>

<div id="outline-container-org3054955" class="outline-4">
<h4 id="org3054955"><span class="section-number-4">5.6.90</span> Add support for generic container types to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-90">
<p>
We should add all major container types and tests for them.
</p>

<pre class="example">
IEnumerable&lt;T&gt;
ICollection&lt;T&gt;
IList&lt;T&gt;
IDictionary&lt;K, V&gt;
List&lt;T&gt;
ConcurrentQueue&lt;T&gt;, ConcurrentStack&lt;T&gt;, LinkedList&lt;T&gt;
Dictionary&lt;TKey,TValue&gt;
SortedList&lt;TKey,TValue&gt;
ConcurrentDictionary&lt;TKey,TValue&gt;
KeyedCollection&lt;TKey,TItem&gt;
</pre>


<p>
Notes:
</p>

<ul class="org-ul">
<li>we need a way to determine if we are using a helper, the assistant
or a sequence generator directly.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbae1664" class="outline-4">
<h4 id="orgbae1664"><span class="section-number-4">5.6.91</span> Add support for nullable built-ins and primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-91">
<p>
One useful feature in C# is the ability to add nullable types:
</p>

<pre class="example">
Nullable&lt;int&gt;
?
</pre>


<p>
This is particularly useful for built-in types, although its also
applicable to value types. For primitives this is slightly more
straightforward and we can make it a property of the meta-type (since
the whole point is that users define new primitives for each domain
type). For built-ins its slightly more tricky because its a property
of the attribute. We'd have to extend:
</p>

<ul class="org-ul">
<li>the name tree to add a "is nullable" to each name tree</li>
<li>the parser to read nullable and do the right thing</li>
<li>LAM, to suport some kind of <code>lam::nullable</code> which in C++ translates
to <code>boost::optional</code> and C# <code>Nullable</code>. Interestingly enough we can
create a "Nullable type" in the global namespace.</li>
</ul>
</div>
</div>

<div id="outline-container-org2ba80fd" class="outline-4">
<h4 id="org2ba80fd"><span class="section-number-4">5.6.92</span> Add auxiliary function properties to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-92">
<p>
We need to associate a function with an attribute and a
formatter. This could be the helper or the assistant (or nothing).
</p>

<p>
Actually this is not quite so straightforward. In <code>io</code> (c#) we have:
</p>

<pre class="example">
assistant.Add("ByteProperty", value.ByteProperty, true/*withSeparator*/);
</pre>


<p>
This is a bit of a problem because we now need to different
invocations, one for helper another for the assistant, which differ on
the function prototype. For the helper we need something like:
</p>

<pre class="example">
Add(assistant, "ByteProperty", value.ByteProperty, true/*withSeparator*/);
</pre>


<p>
So a string is no longer sufficient. Maybe we could have a struct with
auxiliary function properties:
</p>

<ul class="org-ul">
<li>auxiliary function types = enum with { assistant, helper }</li>
<li>auxiliary function name = string</li>
</ul>

<p>
So we can have a map of attribute id to map of formatter id to
auxiliary function properties.
</p>

<p>
Actually we should also create "attribute properties" as a top-level
container so that in the future we can latch on other attribute level
properties.
</p>
</div>
</div>

<div id="outline-container-org368b8df" class="outline-4">
<h4 id="org368b8df"><span class="section-number-4">5.6.93</span> Add internal object dumper resolution in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-93">
<p>
We should try to resolve an object to a local dumper, if one exists;
for all model types and primitives. Add a registrar for local dumpers.
</p>

<pre class="example">
using System;
using System.Collections.Generic;

namespace Dogen.TestModels.CSharpModel
{
    static public class DynamicDumperRegistrar
    {
        public interface IDynamicDumper
        {
            void Dump(AssistantDumper assistant, object value);
        }

        static private IDictionary&lt;Type, IDynamicDumper&gt; _dumpers = new Dictionary&lt;Type, IDynamicDumper&gt;();

        static void RegisterDumper(Type type, IDynamicDumper dumper)
        {
        }
    }
}
</pre>
</div>
</div>

<div id="outline-container-org558802c" class="outline-4">
<h4 id="org558802c"><span class="section-number-4">5.6.94</span> Add support for boxed types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-94">
<p>
At present we support built-in types such as <code>int</code> but not
<code>System.Integer</code>. In theory we should be able to add these types with:
</p>

<pre class="example">
"quilt.csharp.assistant.requires_assistance": true,
"quilt.csharp.assistant.method_postfix": "ShortByte"
</pre>


<p>
And they should behave just like built-ins.
</p>
</div>
</div>

<div id="outline-container-org390770a" class="outline-4">
<h4 id="org390770a"><span class="section-number-4">5.6.95</span> Add handcrafted class to C# test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-95">
<p>
We should make sure handcrafted code works in C#. All the components
including the profile is now present in the test model, but we do not
yet have a test type for it. We also need to check how enablement is
working to make sure it works for C#. This should all be done once we
finish with the archetypes model clean up.
</p>

<p>
<b>Previous Understanding</b>
</p>

<p>
Actually in order to get handcrafted types to work we need support for
enablement. This is a somewhat tricky feature so we should leave it
for after all the main ones are done.
</p>

<p>
In addition, we should also wait for the model level stereotypes. We
should have a system model that enables/disables formatters, sets the
overwrite flags, etc.
</p>
</div>
</div>

<div id="outline-container-orgb4fac9e" class="outline-4">
<h4 id="orgb4fac9e"><span class="section-number-4">5.6.96</span> Add support for native arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-96">
<p>
At present the legacy yarn parser does not support array notation:
<code>string[]</code>. We need to look into how arrays would work for C++ and
implement it in a compatible way. This has been implemented in the new
parser but we haven't yet moved it into production.
</p>

<p>
Actually we should not add support for native arrays directly, but via
a masd type. Perhaps: <code>masd::native_array</code>? Similar with pointers,
etc. However, we need to understand how this relates to LAM.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.dotnetperls.com/array">array</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgea00a21" class="outline-4">
<h4 id="orgea00a21"><span class="section-number-4">5.6.97</span> Add fluency support for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-97">
<p>
We need to add fluent support for C#.
</p>

<p>
C# properties are not compatible with the fluent pattern. Instead, one
needs to create builders, across the inheritance tree.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/13761666/how-to-use-fluent-style-syntactic-sugar-with-c-sharp-property-declaration">How to use Fluent style syntactic sugar with c# property declaration</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4361c0b" class="outline-4">
<h4 id="org4361c0b"><span class="section-number-4">5.6.98</span> Add visitor support to C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-98">
<p>
Implement the visitor formatters for C#.
</p>
</div>
</div>

<div id="outline-container-org0111544" class="outline-4">
<h4 id="org0111544"><span class="section-number-4">5.6.99</span> Generate benchmarking code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-99">
<p>
We should automatically add the benchmarking code in the generated
CMakeLists. This could be behind a feature switch in meta-data.
</p>

<p>
Alternatively, we should consider adding wrapper code around unit
tests which generates benchmarking code via existing libraries. This
can be done once we create a facet for manual tests. However, we would
have to declare each test in the model and hard-code both the unit
test framework as well as the benchmark framework.
</p>
</div>
</div>

<div id="outline-container-org1d7c208" class="outline-4">
<h4 id="org1d7c208"><span class="section-number-4">5.6.100</span> Remove existing benchmark infrastructure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-100">
<p>
We have not used it since it was implemented a long time ago. In
addition, it is not very practical because it requires us to manually
generate the benchmark numbers and we never remember to do it. We
should just remove it and create a new benchmark framework based on
existing libraries and integrated with nightlies. Ideally it should
also output results to relational so that we can plot the evolution
over time.
</p>
</div>
</div>

<div id="outline-container-org89538bf" class="outline-4">
<h4 id="org89538bf"><span class="section-number-4">5.6.101</span> Consider using a benchmarking framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-101">
<p>
It seems there is a C++ benchmarks framework which could be used for
dogen's benchmarks:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nickbruun/hayai">hayai</a></li>
<li><a href="https://bruun.co/2012/02/07/easy-cpp-benchmarking">Easy C++ benchmarking</a></li>
<li><a href="https://github.com/martinus/nanobench">nanobench GH</a>: ankerl::nanobench is a platform independent
microbenchmarking library for C++11/14/17/20.</li>
<li><a href="https://github.com/p-ranav/criterion">criterion GH</a>: Criterion is a micro-benchmarking library for modern
C++.</li>
</ul>
</div>
</div>

<div id="outline-container-org1e3e861" class="outline-4">
<h4 id="org1e3e861"><span class="section-number-4">5.6.102</span> Generate AssemblyInfo in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-102">
<p>
We need to inject a type for this in assets. For now we can leave it
mainly blank but in the future we need to have meta-data in yarn for
all of its properties:
</p>

<pre class="example">
[assembly: AssemblyTitle ("TestDogen")]
[assembly: AssemblyDescription ("")]
[assembly: AssemblyConfiguration ("")]
[assembly: AssemblyCompany ("")]
[assembly: AssemblyProduct ("")]
[assembly: AssemblyCopyright ("marco")]
[assembly: AssemblyTrademark ("")]
[assembly: AssemblyCulture ("")]
[assembly: AssemblyVersion ("1.0.*")]
</pre>


<p>
These appear to just be properties at the model level. We need to also
make it a bit more general and try to figure out what it maps to in
C++. For example, the version file could be generated from this file
</p>
<ul class="org-ul">
<li>or perhaps these should be distinct concepts? At present we are</li>
</ul>
<p>
using CMake templates to generate <code>version.hpp</code>.
</p>
</div>
</div>

<div id="outline-container-org35a5988" class="outline-4">
<h4 id="org35a5988"><span class="section-number-4">5.6.103</span> Consider adding a clone method for C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-103">
<p>
It would be nice to have a way to clone a object graph. We probably
have an equivalent story for this for C++ in the backlog.
</p>
</div>
</div>

<div id="outline-container-org185b02f" class="outline-4">
<h4 id="org185b02f"><span class="section-number-4">5.6.104</span> Consider making the output directory configurable in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-104">
<p>
At present we are outputting binaries into the <code>bin</code> directory,
locally on the project directory. However, it would make more sense to
output to <code>build/output</code> like C++ does. For this to work, we need to
be able to supply an output directory as meta-data.
</p>
</div>
</div>

<div id="outline-container-org445a2c0" class="outline-4">
<h4 id="org445a2c0"><span class="section-number-4">5.6.105</span> Add code generation support for importing nuget libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-105">
<p>
A proxy model may require obtaining a nuget package. Users should be
able to define a proxy model as requiring a nuget package and then
Dogen should generate <code>packages.config</code> and add all such models to it.
</p>

<pre class="example">
+  &lt;package id="NUnit" version="2.6.4" targetFramework="net45" /&gt;
</pre>


<p>
This can be done by defining meta-data at the model level that allows
it to specify the required packages; then, when importing models, we
need to copy across that meta-data and create the set of all dependent
packages and use that to create the <code>package.config</code> file.
</p>

<p>
Meta-data:
</p>

<ul class="org-ul">
<li><code>quilt.csharp.package_name</code></li>
<li><code>quilt.csharp.package_version</code></li>
<li><code>quilt.csharp.package_target_framework</code></li>
</ul>

<p>
Each proxy model can define only one set of these. When merging, we
need to read the meta-data of each referenced model and create a set
for all of them.
</p>

<p>
The only slight problem is for hand-crafted types. We may need to add
more entries due to hand-crafting, so that a user model may end up
with lots of these. It needs to be a collection.
</p>

<p>
Interestingly, a similar approach could be done for C++ with say conan.
</p>
</div>
</div>

<div id="outline-container-orga06e3da" class="outline-4">
<h4 id="orga06e3da"><span class="section-number-4">5.6.106</span> Add feature to disable regions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-106">
<p>
We need a way to stop outputting regions if the user does not want
them.
</p>
</div>
</div>

<div id="outline-container-org60743bf" class="outline-4">
<h4 id="org60743bf"><span class="section-number-4">5.6.107</span> Add parameters for using imported assemblies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-107">
<p>
Assemblies imported via proxy models need to have the ability to
supply two parameters:
</p>

<ul class="org-ul">
<li>assembly name: this is not always the same as the proxy model name;</li>
<li>root namespace: similarly this may differ from the proxy model name.</li>
</ul>

<p>
These should be supplied as meta data and used when constructing
elements.
</p>
</div>
</div>

<div id="outline-container-org90d9ff5" class="outline-4">
<h4 id="org90d9ff5"><span class="section-number-4">5.6.108</span> Add msbuild target for C# test model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-108">
<p>
Once we are generating solutions, we should detect msbuild (or xbuild)
and build the solution. This should be a CMake target that runs on
Travis.
</p>
</div>
</div>

<div id="outline-container-orgffba6f7" class="outline-4">
<h4 id="orgffba6f7"><span class="section-number-4">5.6.109</span> Add visibility to coding elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-109">
<p>
We need to be able to mark types as:
</p>

<ul class="org-ul">
<li>public</li>
<li>internal</li>
</ul>

<p>
This can then be used by C++ (public headers) as well for visibility
in c# (internal).
</p>
</div>
</div>

<div id="outline-container-org0143834" class="outline-4">
<h4 id="org0143834"><span class="section-number-4">5.6.110</span> Add partial element support to coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-110">
<p>
We need to be able to mark logical elements as "partial". It is then
up to programming languages to map this to a language feature. At
present only <a href="https://msdn.microsoft.com/en-us/library/wa80x488.aspx">C# would do so</a>.
</p>

<p>
It would be nice to have a more meaningful name at the logical model
level. However, seems like this is a fairly general programming
concept now: <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Partial">wikipedia</a>.
</p>
</div>
</div>

<div id="outline-container-org24f2045" class="outline-4">
<h4 id="org24f2045"><span class="section-number-4">5.6.111</span> Add final support in C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-111">
<p>
We now have final in the meta-model. We need to check the status of C#
support.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://msdn.microsoft.com/en-us/library/88c54tsw.aspx">sealed (C# Reference)</a></li>
</ul>
</div>
</div>

<div id="outline-container-org35c442f" class="outline-4">
<h4 id="org35c442f"><span class="section-number-4">5.6.112</span> Add aspects for C# serialisation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-112">
<p>
We need to add serialisation support:
</p>

<ul class="org-ul">
<li>C# serialisation</li>
<li>Data Contract serialisation</li>
<li>Json serialisation</li>
</ul>

<p>
In C# these are done via attributes so we do not need additional
facets. We will need a lot of configuration knobs though:
</p>

<ul class="org-ul">
<li>ability to switch a serialisation method on at model level or
element level.</li>
<li>support for serialisation specific arguments such as parameters for
Json.Net.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://msdn.microsoft.com/en-us/library/ms731923(v%3Dvs.110).aspx">Types Supported by the Data Contract Serializer</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms731073(v%3Dvs.110).aspx">Serialization and Deserialization</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms733127(v%3Dvs.110).aspx">Using Data Contracts</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms731923(v%3Dvs.110).aspx">Types Supported by the Data Contract Serializer</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6119932" class="outline-4">
<h4 id="org6119932"><span class="section-number-4">5.6.113</span> Add support for cross-language LAM serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-113">
<p>
Now we have the basic support for LAM in place, it would be nice to be
able to serialise across languages. This could be done as follows:
</p>

<ul class="org-ul">
<li>XML: create a "LAM" XML schema, and a set of formatters that read
and write from it. This is kind of like reverse mapping the types
back to LAM types when writing the XML.</li>
<li>JSON: similar approach to XML, minus the schema.</li>
<li>POF: use the coherence libraries to dump the models into POF.</li>
</ul>
</div>
</div>

<div id="outline-container-org5a3bee5" class="outline-4">
<h4 id="org5a3bee5"><span class="section-number-4">5.6.114</span> Consider adding stereotype of noncopyable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-114">
<p>
This is a common pattern is C++. However, its not yet clear how this
would work with regular domain types.
</p>
</div>
</div>

<div id="outline-container-orgbfcd3dd" class="outline-4">
<h4 id="orgbfcd3dd"><span class="section-number-4">5.6.115</span> Add support for thrift and protocol buffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-115">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to expose dogen models to other
languages so that I can make use of them on these languages.
</p>

</blockquote></div>

<p>
Amongst other things, these technologies provide cross-language
support, allowing one to create c++ services and consume them from say
ruby, python, etc. At their heart they are simplified versions of
CORBA/DCOM, with IDL equivalents, IDL compilers, specification for
wire formats, etc. As they all share a number of commonalities, we
shall refer to these technologies in general as Distributed Services
Technologies (DST). We could integrate DST's with Dogen in two
ways. First approach A:
</p>

<ul class="org-ul">
<li>generate the IDL for a model; we have enough information to produce
something that is very close to it's Dogen representation,
translated to the type system of the IDL; e.g. map <code>std::string</code>,
<code>std::vector</code>, etc to their types. This IDL is then compiled by the
DST's IDL to C++ compiler. Note: we could use LAM for this, but the
problem is if one starts with a C++ model, one would have to convert
it into LAM just to be able to do the mappings. A solution for this
problem would be to "reverse map" LAM from C++ and get to the
generic type this way.</li>
<li>possibly generate the transformation code that takes a C++ object
generated by Dogen and converts it into the C++ object generated by
the DST's C++ compiler and vice-versa. We probably have enough
information to generate these transformers automatically, after some
analysis of the code generated by the DST's C++ compiler.</li>
</ul>

<p>
In order for this to work we need to have the ability to understand
function signatures for services so that we can generate the correct
service IDL for the DST. In fact, we should be able to mark certain
services as DST-only so that we do not generate a Dogen representation
for them. The DST service then internally uses the transformer to take
the DST's domain types and convert them into Dogen domain types, and
then uses the Dogen object model to implement the guts of the
service. When shipping data out, the reverse process takes place.
</p>

<p>
Approach A works really well when a service has a very narrow
interface, and performs most of it's work internally without exposing
it via the interface. Once the service requires the input (and/or
output) of a large number of domain types, we hit a cost limitation;
we may end up defining as many types in Dogen as there are in the IDL,
thus resulting in a large amount of transformations between the two
object models.
</p>

<p>
In these cases one may be tempted to ignore Dogen and implement the
service directly in terms of the DST's object model. This is not very
convenient as the type system is not as expressive as regular C++ -
there are a number of conventions that must be adopted, and
limitations imposed too due to the expressiveness of the IDL. We'd
also loose all the services provided by Dogen, which was the main
reason why we created it in the first place.
</p>

<p>
Approach B is more difficult. We could look into the wire format of
each DST and implement it as serialisation mechanism. For this to
work, the DST must:
</p>

<ul class="org-ul">
<li>provide some kind of raw interface that allows one to plug in types
serialisation manually. Ideally we wouldn't have to do this for
services, just for domain types, but it depends on the low-level
facilities available. A cursory look at both thrift and protocol
buffers does not reveal easy access to such an interface.</li>
<li>provide either a low-level wire format library (e.g. <code>std::string</code>
to <code>string</code>, etc) or a well specified wire format that we could
easily implement from scratch.</li>
</ul>

<p>
This approach is the cleaner technically, but its a lot of work, and
very hard to get right. We would have to have a lot of round-trip
tests. In addition, DST's such as thrift provide a wealth of wire
formats, so if there is no easy-access low-level wire format library,
it would be very difficult to get this right.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/protobuf-c/protobuf-c">protobuf-c</a>: protobuf stand alone library in C.</li>
<li><a href="https://github.com/mapbox/protozero">protozero</a>: Minimalist protocol buffer decoder and encoder in C++</li>
<li><a href="https://github.com/protocolbuffers/upb">GH upb</a>: a small protobuf implementation in C.</li>
<li><a href="https://richardstartin.github.io/posts/dont-use-protobuf-for-telemetry">Don't use Protobuf for Telemetry</a></li>
<li><a href="https://codeburst.io/json-vs-protocol-buffers-vs-flatbuffers-a4247f8bda6f">JSON vs Protocol Buffers vs FlatBuffers</a></li>
<li><a href="https://github.com/nanopb/nanopb">nanopb GH</a>: Nanopb is a small code-size Protocol Buffers
implementation in ansi C.</li>
<li><a href="https://github.com/StandardCyborg/protobag">protobag GH</a>: Protobag: A bag of Serialized Protobuf Messages</li>
</ul>
</div>
</div>

<div id="outline-container-org0bf43d4" class="outline-4">
<h4 id="org0bf43d4"><span class="section-number-4">5.6.116</span> Add support for flatbuffers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-116">
<p>
Flatbuffers is a technology similar to protocol buffers but with a
simpler implementation. The generated code is not brilliant. We can
add support at several levels:
</p>

<ul class="org-ul">
<li>add stereotypes and other meta-model constructs to allow users to
express flatbuffer concepts: interop::table? ideally something which
is not hard-coded to flatbuffers but can be extended to other IDL
constructs such as Corba, etc. We will need a mapping layer for both
types and meta-model concepts from a set of generic yarn terms to
the concrete terms of the implementation technology. This needs to
be hooked in to the mapping layer somehow.</li>
<li>on a first stage we can just generate the IDL and then use their
compiler to generate code. This is already useful because we can
have a single model that covers the entire system.</li>
<li>a second stage would be to generate the flatbuffers code
directly. This is easier to achieve that with other technologies
such as protobuf because the flatbuffers code is simpler. We could
tidy-up a lot of their generated code: use string views, array
views, do not inline helper methods, create better builders, add
comments, use enum classes and make enums more readable, etc. We
should generate this code into types, rather than into a flatbuffers
facet directory. This directory is reserved for the code generated
using their compiler (as we did for ODB). Once we generate the code
in types we can also do other things such as generate test data, io
etc for these types.</li>
<li>inner classes support is required if we want to allow the user to
generate more than one type in a file. However, since flatbuffers
supports includes this is not a mandatory requirement.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf3b8a2a" class="outline-4">
<h4 id="orgf3b8a2a"><span class="section-number-4">5.6.117</span> Add support for BSON serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-117">
<p>
It would be useful to support Mongo DB's BSON. There is a C++ stand
alone library for this:
</p>

<p>
<a href="https://github.com/jbenet/bson-cpp">https://github.com/jbenet/bson-cpp</a>
</p>

<p>
For examples on how to use the C++ API see the tutorial:
</p>

<p>
<a href="https://github.com/mongodb/mongo-cxx-driver/wiki/Tutorial">https://github.com/mongodb/mongo-cxx-driver/wiki/Tutorial</a>
</p>
</div>
</div>

<div id="outline-container-org62802f9" class="outline-4">
<h4 id="org62802f9"><span class="section-number-4">5.6.118</span> Add support for Decimal numbers in C++ and C#&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-118">
<p>
For C++:
</p>

<ul class="org-ul">
<li>try using ICU DecNumber library.</li>
<li>check compiler support (MSVC may have decimals; if so, use that
instead)</li>
<li>There is a cross-platform implementation of <code>std::decimal</code> available
<a href="https://sourceforge.net/p/stddecimal/code/HEAD/tree/trunk/">here</a>.</li>
<li>we should probably consider just supporting <a href="https://www.boost.org/doc/libs/1_72_0/libs/math/doc/html/math_toolkit/high_precision/use_multiprecision.html">boost multiprecision</a>
instead.</li>
</ul>

<p>
For C#:
</p>

<ul class="org-ul">
<li>use System.Decimal.</li>
</ul>

<p>
LAM:
</p>

<ul class="org-ul">
<li>update decimal mappings. We had:</li>
</ul>

<pre class="example">
{
    "lam_id" : "lam.decimal",
    "names_by_technical_space" : [
        {
            "technical_space" : "cpp",
            "default_name" : {
                "simple": "decimal",
                "model_modules": "std"
            }
        },
        {
            "technical_space" : "csharp",
            "default_name" : {
                "simple": "Decimal",
                "model_modules": "System"
            }
        }
    ]
},
</pre>
</div>
</div>

<div id="outline-container-org5e35bf8" class="outline-4">
<h4 id="org5e35bf8"><span class="section-number-4">5.6.119</span> Add depth detection to io in C++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-119">
<p>
In C# we added support for detecting the depth of the graph and
exiting after we've gone too deep. This is an effective way of
handling cycles in the graph until we have better solutions. We need
to adopt something similar for C++.
</p>
</div>
</div>

<div id="outline-container-org33dec21" class="outline-4">
<h4 id="org33dec21"><span class="section-number-4">5.6.120</span> Use clang format in physical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-120">
<p>
We need to indent the output coming out of the physical model. At
present our stitch templates are super-complex purely because we are
trying to get the indentation right. In most cases we don't. We need
to:
</p>

<ul class="org-ul">
<li>remove indent filter and any other indentation "helpers"</li>
<li>update all templates to output everything as simply as possible, in
one long line if need be. We may still need to use sequence helper
but hopefully for very trivial cases.</li>
<li>plug in clang format at the end of the knit pipeline, using either a
default set of options or a user supplied set of options (via a
command line parameter).</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>integrating with clang-format in an efficient way is a bit
tricky. We don't want to have to write each file and then reformat
it just to find out if there have been any changes. The alternative
is to apply clang format to the files in memory inside of
extraction. This is more efficient but will require a dependency on
<a href="https://clang.llvm.org/docs/LibFormat.html">libFormat</a>. We can use <a href="https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/ClangFormat.cpp">clang format's code</a> to see how to use
libformat.</li>
<li><a href="https://github.com/TheLartians/Format.cmake">Format.cmake</a>: clang-format for CMake</li>
<li><a href="https://github.com/cheshirekow/cmake_format">cmake<sub>format</sub></a>: "The cmake-format project provides Quality Assurance
(QA) tools for cmake".</li>
<li><a href="https://github.com/BlankSpruce/gersemi">gersemi</a>: "A formatter to make your CMake code the real treasure."</li>
<li>when we integrate clang format, we will have to change how we
process overwrite. At present we are just not writing if overwrite
is on; in the future, we need to physically load the contents from
the filesystem and override the generated contents, so that we can
clang-format the existing files. We then write the file down if the
formatting changes its content. If we don't do this we still need to
run clang-format manually again for the handcrafted code.</li>
<li>clang-format <a href="http://releases.llvm.org/9.0.0/tools/clang/docs/ReleaseNotes.html">now supports C#</a>.</li>
<li>when we support the generation of clang format styles, we will have
to write the style file first before we use it for formatting. See
the story on this.</li>
</ul>

<p>
Merged Stories:
</p>

<p>
We should generate un-indented c++ code and then rely on clang-format
to do the indentation. We can allow users to supply their own
configurations and supply those to clang. This can be done via the
meta-data, or if there is a well defined file for clang, we could use
it instead.
</p>

<p>
Note that using clang to manage indentation will make things a lot
slower. Note also that clang supports Java and may in future support
C#. See <a href="http://clang.llvm.org/docs/LibFormat.html">LibFormat</a>.
</p>

<p>
Another option is to create fallback modes. The preferred indenter for
a given language (say c++) may not exist for another language (say
c#); for these we use a dogen created indenter that is very basic. It
may support some of the configuration parameters supplied for the
clang indenter. The key thing is that we take away indenting from the
formaters - they become flat - and then we always apply the indenter;
either a clang based one or a simplified one. Either way, the code
should live in formatters and make use of the language-specific
folders as required.
</p>

<p>
<b>Indent stitch output using clang format</b>
</p>

<p>
<b>Rationale</b>: we should just merge the final output, not each tool's.
</p>

<p>
We need to indent the output coming out of stitch as it is not
suitable for reading as-is.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://bbannier.github.io/blog/2015/05/02/Writing-a-basic-clang-static-analysis-check.html">Writing a basic clang static analysis check</a></li>
<li><a href="http://zed0.co.uk/clang-format-configurator/">clang-format configurator</a></li>
<li><a href="http://clangformat.com/">online clang format</a> - older site</li>
<li><a href="https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/ClangFormat.cpp">ClangFormat.cpp</a>: clang format tool. We can use this as an example of
how to use LibFormat.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd2a8053" class="outline-4">
<h4 id="orgd2a8053"><span class="section-number-4">5.6.121</span> Add an injector for visual studio models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-121">
<p>
It should be "fairly straightforward" to add a frontend for visual
studio. A sample project has been added to test data:
</p>

<pre class="example">
test_data/visual_studio_modeling
</pre>


<p>
We should also extend tailor to output these projects so we can test
it with existing models.
</p>

<p>
Note that the XMI support approach may make this unnecessary. Where
possible, we should just use XMI instead of having lots of different
exogenous models.
</p>
</div>
</div>

<div id="outline-container-org79d799f" class="outline-4">
<h4 id="org79d799f"><span class="section-number-4">5.6.122</span> Add an injector for ArgoUML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-122">
<p>
Seems like a popular UML tool. Not sure if it supports XMI.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://argouml.tigris.org/">http://argouml.tigris.org/</a></li>
<li><a href="https://github.com/cscorley/argouml-mirror">https://github.com/cscorley/argouml-mirror</a></li>
</ul>
</div>
</div>

<div id="outline-container-org819ff32" class="outline-4">
<h4 id="org819ff32"><span class="section-number-4">5.6.123</span> Add support for "capitalisation theming"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-123">
<p>
It would be nice if facets, classes etc which are at present in lower
case could be camel cased if the user chooses.
</p>

<p>
At present we need to override all facet directories, include
directories, etc.
</p>

<p>
In fact, we could copy the clang format approach and create the notion
of a "style". The style would then be applied to "targets", e.g.:
</p>

<ul class="org-ul">
<li>classes, interfaces</li>
<li>methods</li>
<li>variables, member variables, constants</li>
<li>enumerations</li>
</ul>

<p>
Each of these can then have a case style. We could create a meta-model
element to capture all of the aspects of the theme. A technical space
can have a default theme associated with it; we need to find out what
are considered the "standard" cases.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>apparently there is <code>lowerCamelCase</code> and <code>UpperCamelCase</code>.</li>
<li>according to wikipedia, 'The combination of "upper camel case" and
"snake case" is known as "Darwin case"'</li>
<li>we need to support both the "apply a theme" (in which case all model
elements must be in snake case, else there is an error) and the "use
the names as-is", in which case we will not touch the supplied
elements.</li>
<li>note that we do not care about the indent style. Or better, we do,
but this is just an argument supplied to clang format. We will
handle this separately. The clang format configuration should just
be a parameter in the theme. We should allow for the out-of-the box
styles: LLVM, Google, Chromium, Mozilla, WebKit, Microsoft.</li>
<li>we need to merge the capitalisation theming with decoration. We
don't want to have several dimensions across which we have separate
themes. We need to ensure related concepts are modeled only once.</li>
<li>we need to take into account artefact concepts such as file and
directory names. See story on directory themes.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://medium.com/better-programming/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841">Case Styles: Camel, Pascal, Snake, and Kebab Case</a></li>
<li><a href="https://en.wikipedia.org/wiki/Naming_convention_(programming)">Naming convention (programming)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Camel_case">Camel Case</a></li>
<li><a href="https://en.wikipedia.org/wiki/Indentation_style">Indentation style</a></li>
<li><a href="https://llvm.org/docs/Proposals/VariableNames.html">LLVM: Variable Names Plan</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Add camel case option</b>
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want my models to use camel case so that I
can integrate dogen code with my code base.
</p>

</blockquote></div>

<p>
It would be nice to have a command line option that switches names
from underscores into camel case. The default convention would be that
diagrams are always with underscores and then you can convert them at
generation time. There should be a regex for this conversion.
</p>
</div>
</div>

<div id="outline-container-org3932a2f" class="outline-4">
<h4 id="org3932a2f"><span class="section-number-4">5.6.124</span> Add support for clang format configurations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-124">
<p>
It would be nice if we could generate a clang format configuration. We
could have a meta-model element that represents a style and then use
it to generate the style file. We can generate multiple languages on a
given style file:
</p>

<pre class="example">
---
# We'll use defaults from the LLVM style, but with 4 columns indentation.
BasedOnStyle: LLVM
IndentWidth: 4
---
Language: Cpp
# Force pointers to the type for C++.
DerivePointerAlignment: false
PointerAlignment: Left
---
Language: JavaScript
# Use 100 columns for JS.
ColumnLimit: 100
---
Language: Proto
# Don't format .proto files.
DisableFormat: true
---
Language: CSharp
# Use 100 columns for C#.
ColumnLimit: 100
...
</pre>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://zed0.co.uk/clang-format-configurator/">Clang format configurator</a></li>
<li><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">Clang-Format Style Options</a></li>
<li><a href="https://gist.github.com/andrewseidl/8066c18e97c40086c183">Clang-format style comparison</a></li>
<li><a href="https://leimao.github.io/blog/Clang-Format-Quick-Tutorial/">Format C/C++ Code Using Clang-Format</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf17462f" class="outline-4">
<h4 id="orgf17462f"><span class="section-number-4">5.6.125</span> Add support for object caches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-125">
<p>
It would be good to have meta-model knowledge of "cacheability". This
is done by marking objects with a stereotype of <code>Cacheable</code>. It then
could translate to:
</p>

<ul class="org-ul">
<li>adding a serialisation like interface with gets, puts, etc. We need
to bind this to a specific cache such as memcache, coherence, etc.</li>
<li>create a type to string which converts a key made up of built-ins or
built-in into a underscore delimited string, used as a key in the
cache.</li>
<li>we should also consider external libraries like <a href="https://github.com/cripplet/cachepp">cachepp</a>.</li>
<li>we could consider code-generating code to link the far cache with
the near cache but it seems this is the job of a caching library.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://pocoproject.org/docs/package-Foundation.Cache.html">POCO: Cache namespace</a></li>
<li><a href="https://pocoproject.org/slides/140-Cache.pdf">POCO: Cache namespace docs</a></li>
<li><a href="https://github.com/cachelot/cachelot">cachelot</a>: LRU cache</li>
</ul>
</div>
</div>

<div id="outline-container-org406d8aa" class="outline-4">
<h4 id="org406d8aa"><span class="section-number-4">5.6.126</span> Generate Redis get/set code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-126">
<p>
In theory, there is nothing stopping us from having a Redis facet that
takes in as an input the serialisation method. For now we just need to
support boost serialisation. The interface could be configurable so
that users can choose the archive type. Types could be marked as
<code>cacheable</code> and then suitable parameters supplied such as the
serialisation mechanism.
</p>

<p>
As with hashing, we do not want to generate code for all objects; only
for those the user marks as cacheable.
</p>

<p>
The interface should support two main methods:
</p>

<ul class="org-ul">
<li>get</li>
<li>set</li>
</ul>

<p>
Both receive an instance of Redis. We could implement it in C to avoid
additional dependencies.
</p>

<p>
However, it should also be possible to use say <code>memcached</code> as the
cache rather than redis. We need to create a layer of indirection
between the generic caching (meta-model concept) and the actual
caching (platform, implementation layer). In fact we can leave this
for later and for now only worry about redis. <code>cacheable</code> will then be
built on top of the existing facets.
</p>

<p>
What we do need though is the ability to configure the meta-model to
link the serialisation type to the cache type. Say for example we
support BSON and JSON and boost serialisation. We may want the cache
facet to support one or more or all of these. We can think of these as
aspects that are enabled by the user at the model level (but possibly
overridable at the element level).
</p>

<p>
Other KVP stores:
</p>

<ul class="org-ul">
<li><a href="https://github.com/microsoft/FASTER/tree/master/cc">FASTER GH</a>: see also the <a href="https://microsoft.github.io/FASTER/docs/fasterkv-cpp/">home page</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orgae53565" class="outline-4">
<h4 id="orgae53565"><span class="section-number-4">5.6.127</span> Add support for libnop&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-127">
<p>
Interesting serialisation format.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/google/libnop">https://github.com/google/libnop</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb298589" class="outline-4">
<h4 id="orgb298589"><span class="section-number-4">5.6.128</span> Add boost variant visitors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-128">
<p>
It would be nice if we could automatically generate boost variant
visitors with lambda support. See:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/7867555/best-way-to-do-variant-visitation-with-lambdas">Best way to do variant visitation with lambdas</a></li>
<li><a href="https://www.meetingcpp.com/blog/items/boostvariant-and-a-general-generic-visitor-class.html">boost::variant and a general, generic visitor class</a></li>
<li><a href="https://www.boost.org/doc/libs/1_72_0/doc/html/variant.html">Boost variant</a></li>
<li><a href="https://theboostcpplibraries.com/boost.variant">Boost variant - boost book</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2f45ff3" class="outline-4">
<h4 id="org2f45ff3"><span class="section-number-4">5.6.129</span> Add support for disabling unique filenames&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-129">
<p>
At present dogen uses formatter and facet prefixes for each file it
generates, ensuring the files are unique across all projects in a
model. This was done originally due to some issue with code coverage,
whereby the same filename was causing the gcov tool to get confused.
</p>

<p>
Originally we had a feature that allowed switching off the unique
filenames, but this bit-rotted and was eventually removed. It may make
sense to add it again, but it is really a shorthand for setting facet
and formatter prefix to empty string. We should at least have a model
that tests that this works.
</p>
</div>
</div>

<div id="outline-container-orga87723a" class="outline-4">
<h4 id="orga87723a"><span class="section-number-4">5.6.130</span> Create a map between UML/MOF terminology and yarn&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-130">
<p>
It would be helpful to know what a yarn type means in terms of
UML/MOF, and perhaps even explain why we have chosen certain names
instead of the UML ones. We should also cover the modeling of
relationships and the relation between yarn concepts and UML/MOF
classes. This will form a chapter in the manual.
</p>

<p>
The UML specification is available <a href="http://www.omg.org/spec/UML/2.5/">here</a> and MOF specification is
available <a href="http://www.omg.org/spec/MOF/2.5">here</a>.
</p>

<p>
We need a way to uniquely identify a property. This could be done by
appending the containing type's qualified name to the property name.
</p>

<p>
See also <a href="http://www.uml-diagrams.org/">The Unified Modeling Language</a> for a more accessible
treatment.
</p>

<p>
See <a href="http://www-01.ibm.com/support/knowledgecenter/SS5JSH_9.1.2/com.ibm.xtools.transform.uml2.cpp.doc/topics/rucppprofile.html">Stereotypes of the UML-to-C++ transformation profile</a> for ideas.
</p>
</div>
</div>

<div id="outline-container-orga8754a8" class="outline-4">
<h4 id="orga8754a8"><span class="section-number-4">5.6.131</span> Investigate boost log config files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-131">
<p>
Our log files are growing quite a bit. We don't really want to log any
less since the logging is very useful for troubleshooting. However, at
any one time we just need to look at one or a couple of
components. What we really need is something like log4j, where we can
change log levels for a component or all components in a hierarchy. We
need to investigate boost log solutions for this.
</p>

<p>
It seems we cannot change severity per component ("channel") with our
current setup. We need something akin to this:
</p>

<ul class="org-ul">
<li><a href="http://www.boost.org/doc/libs/1_57_0/libs/log/doc/html/log/detailed/expressions.html#log.detailed.expressions.predicates.channel_severity_filter">Severity threshold per channel filter</a></li>
</ul>

<p>
This could be implemented as follows:
</p>

<p>
Create a log config file (say <code>logging.ini</code>) that contains a list of
strings and valid severities:
</p>

<pre class="example">
root = trace
cpp = debug
cpp.settings = info
</pre>


<p>
and so on. When the log is being initialised, a sorted list with these
is loaded into memory. It is sorted by channel name. Note that <code>root</code>
is a special value and is always at the bottom of the list (or even
removed from the list altogether and handled specially). If root was
not defined in the config file, we set it to a default. Note also that
we convert the severity strings into enums, with adequate validation.
</p>

<p>
Once the list is setup, we then loop through all the channels that
have been defined. There is an assumption that all channels were
defined statically and thus have already been defined by the time we
initialise the log. This needs to be verified.
</p>

<p>
For each channel, we loop through all values from the file - other
than root - applying them as a regex against the channel name. Note
that we sorted them so the closest match should be last. For each
value that matches, we set the severity accordingly. If no matches are
found, we apply the root setting.
</p>

<p>
Some other tidbits:
</p>

<ul class="org-ul">
<li>we can now remove the <code>verbose</code> option, or perhaps it should be used
as a short-hand for the log configuration? if so we need a rule that
determines which one to use when both are present.</li>
<li>we could monitor the config file for changes, although for dogen
this is overkill.</li>
<li>if sorting proves too hard we could just say that the regexes are
applied in the order provided by the user, with the exception of
root.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd43fb48" class="outline-4">
<h4 id="orgd43fb48"><span class="section-number-4">5.6.132</span> Create a PDM for the utility model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-132">
<p>
We need to create a PDM for the utility model that only includes
utilities. To call it PDM may not be strictly correct as it is not
doing any mapping. Perhaps it is just a simple, stand-alone
product. We need to remove any "helper" code for other models - it
should be placed on the corresponding PDM (e.g. <code>boot</code>, <code>std</code>, etc).
</p>

<p>
<b>Previous Understanding</b>
</p>

<p>
We need to create a library with support code that is used by the
models. At present it is needed for <code>io</code> and <code>test_data</code>. However, we
ran into <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_67.org#update-legacy-formatters-to-use-needle-for-io">a lot of difficulties</a> when we tried to implement it for <code>io</code>
using templates.
</p>

<p>
For the previous attempt to create the needle library see this commit:
</p>

<p>
feb4750 * integration needle: remove project and includes
</p>

<p>
We have analysed this idea from many angles. The key trade-offs we
have are as follows:
</p>

<ul class="org-ul">
<li>original idea was to create models with zero dependencies; users
should be able to code generate and compile. This would make the
barrier to entry very low.</li>
<li>however, there are downsides to this approach:
<ul class="org-ul">
<li>utility is needed on pretty much every product (logging, IO,
etc). This means we still need some kind of hack to get things to
work. The present solution was to somehow code generate utility
itself. Whilst this could work, it is non-trivial because we now
have "moving references" to utility types. This means a) we cannot
add logging to tests because of it b) in order to solve this
problem, we will have to add a lot of complexity to dogen.</li>
<li>helpers: we need to generate helpers for types that are sourced
from PDMs. This means that every time you add a new type to Dogen
which is not directly supported, you need to extend the code
generator. It is very hard to add new types this way. In addition,
the logic for assistants (families, etc) is very complex and
complicates the code base quite a lot. In addition, there is a lot
of duplication because we generate code specific to each use of a
container in a model; if you have a list of strings and a list of
ints in two types you end up with two helper methods per type. In
reality this could all be compressed to one helper method across
the two types.</li>
<li>the problem is only going to get worse going forward as we add
more functionality that needs this kind of support. For example,
data fountains would require lots of helpers per type.</li>
</ul></li>
</ul>

<p>
In summary, it seems that the engineering trade-offs are clearly
tipping towards having a shared model for this functionality. This
being the case we could look at it as a product: <code>masd::core</code>. We
could then add types for the PDMs in a sensible way: in types we'd
create namespaces for each model, e.g. <code>std</code>, <code>boost</code>, etc. We'd then
disable types facet for these types and set all other (required)
facets to override. For example:
</p>

<ul class="org-ul">
<li><code>masd/core/io/std/list_io.hpp</code>: std::list IO support.</li>
<li><code>masd/core/test_data/std/list_td.hpp</code>: std::list test data support.</li>
</ul>

<p>
And so forth. It would still be a peculiar product in that we'd only
have a single dogen model. In addition, it is a "strange" model in
that users are not expected to reference it; if you did, you'd end up
being able to create a type like <code>masd::core::std::list</code>, which is
just a mapping type. Perhaps we should have a way of identifying these
types as "mapping only types"? This is important because we may want
to reference other types.
</p>

<p>
The core model would also contain the data fountains. It seems like
<code>core</code> is a product, made up of models:
</p>

<ul class="org-ul">
<li>PDM extensions: IO, test data, serialisation, hash. Name: ext,
extensions, etc.</li>
<li>fountain: all data fountains.</li>
<li>utility: logging, file, string, XML, environment, testing.</li>
</ul>

<p>
This would also mean that we can now have "model types" such as PDM
extensions, which are not "referrable" - e.g. we can throw if the user
attempts to reference it. Or, better yet, why have two PDM models?
Applying this approach naively would mean we'd need the <code>std</code> model to
define the types, and then the core model to provide the mappings. But
why have two models? Why not define a model in the namespace of the
original model? For example, if we had a <code>std</code> model defined in core
(and violating the principles around product and model naming), we
could place all the <code>std</code> types in it, set types to disabled and other
facets to enabled as required (e.g. IO). Then it would generate say
<code>std/io/list_io.hpp</code>. We would still keep all of the dependency
machinery we have at present so that we can point to say <code>&lt;list&gt;</code>
instead of <code>std/types/list.hpp</code>. We may also need some kind of hackery
around enablement because we do not want to generate a types file but
we do want users to be able to reference the overriden type. This
approach is <b>very</b> regular:
</p>

<ul class="org-ul">
<li>PDMs now become very similar to dogen models. Interestingly, this
also means we do not need the <code>library</code> folder any longer. This is
because dogen will not work without the code that comes with the
PDMs so you will need to git clone it anyway. In effect, the PDMs
become just like any other Dogen model, so you'll have to install
them and then point to them in order to code generate.</li>
<li>we need PDMs per technical space: C++, C#, etc. Each would have its
own product, etc.</li>
<li>PDMs can contain all the required linking information. However, we
probably should have a PDM per linking library (e.g. one for each
linkable boost library). Else it will be hard to know what libraries
to link against depending on usage.</li>
<li>users can add a new PDM with very little knownledge of Dogen: add a
new model following the existing pattern (copy and paste).</li>
<li>no changes are required to dogen itself: it would automatically pick
up the new PDMs (just need to git update core).</li>
<li>all PDM code could have tests in the core model to ensure it all
works in isolation (test data, IO, etc). We may even be able to
reuse the generated tests for these types.</li>
</ul>

<p>
This approach is very elegant, but its not very nice to start creating
types in the <code>std</code> namespace. Perhaps we should instead to have "name
mapping" or alisaing? A way to associate a name with a type. Then the
PDM would follow the usual dogen naming rules, but when you load up
the model for referencing, it would export the aliases. The crux
though is that we just want a single model for both exporting the PDM
types and implementing the glue code.
</p>
</div>
</div>

<div id="outline-container-org86e2c84" class="outline-4">
<h4 id="org86e2c84"><span class="section-number-4">5.6.133</span> Concepts, immutability and fluency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-133">
<p>
At present we allow the object to determine if any attributes obtained
from modeling a concept are immutable and/or fluent. This seemed
logical at the time, but its actually not a good idea: this means that
two objects modeling a concept may not actually implement the same
interface, thus meaning that they are not really modeling the
concept.
</p>

<p>
Instead if this cleverness, users should be allowed to mark the
concept itself as immutable/fluent and we should simply throw if there
is an incompatibility between concept and object.
</p>
</div>
</div>

<div id="outline-container-org48d91d7" class="outline-4">
<h4 id="org48d91d7"><span class="section-number-4">5.6.134</span> Create an interface for the text reader&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-134">
<p>
In order to do performance testing of the dia model we should create
an interface for text reader and implement it as a mock. This will
avoid the overhead of reading stuff from the hard drive.
</p>
</div>
</div>

<div id="outline-container-orgbbb0bda" class="outline-4">
<h4 id="orgbbb0bda"><span class="section-number-4">5.6.135</span> Adding types to package namespace&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-135">
<p>
Whilst it is possible to document a namespace, it is not possible to
add any classes etc to that namespace. For example, it may make sense
to add some constants at the namespace level. This is not possible
with the current setup.
</p>

<p>
This could be easily implemented by adding a flag that determines if a
type is at the namespace level.
</p>

<p>
This is also related to merging multiple types in a single formatter.
</p>
</div>
</div>

<div id="outline-container-org9a55d5f" class="outline-4">
<h4 id="org9a55d5f"><span class="section-number-4">5.6.136</span> Add support for inner classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-136">
<p>
Inner classes could be expressed in the same way as the short-hand for
namespaces. For example, given a class <code>a</code>, an inner class <code>b</code> could
be declared as <code>a::b</code>. The system would have to recognise that <code>a</code> is
a class and then treat it accordingly in yarn. The formatters would
have to be taught to express inner classes when formatting the main
class. This probably requires merging two yarn entities into a single
cpp entity. Finally some dynamic extension support would be required
to determine if the inner class is public or private.
</p>

<p>
We just need a use case for where inner classes would be useful.
</p>
</div>
</div>

<div id="outline-container-org0b39695" class="outline-4">
<h4 id="org0b39695"><span class="section-number-4">5.6.137</span> Consider adding support for inline hashing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-137">
<p>
At present we have an entire facet for hashing. However, it is
conceivable that some users may find it a bit of an overkill and would
rather have it added to the types facet instead. We already do
something similar for the <code>operator&lt;&lt;</code>. We need to consider a more
generic mechanism for allowing the inlining of certain features when
they are more core.
</p>

<p>
In fact, one wonders if we are not getting towards a multi-option
implementation for certain things:
</p>

<ul class="org-ul">
<li>as a facet;</li>
<li>as a formatter;</li>
<li>as a toggleable aspect of an existing formatter.</li>
</ul>

<p>
Where the user gets to choose one of the three possible
implementations. In some cases we may not support all of these
options; for example, for operators we could support the second and
the third option and so on.
</p>

<p>
See also Support "cross-facet interference".
</p>
</div>
</div>

<div id="outline-container-org2b41019" class="outline-4">
<h4 id="org2b41019"><span class="section-number-4">5.6.138</span> Consider making header guards configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-138">
<p>
It may be nice to be able to switch parts of the header guards off (do
not use namespaces, etc) or even to have a completely different policy
to generate header guards. We do not have a use case for this yet, but
this story is a place-holder for it.
</p>

<p>
The end-game for this is to have a set of "variables" that can be used
to express the header guards:
</p>

<pre class="example">
$(namespaces)_$(class_name)_$(extension)
</pre>


<p>
And so forth. One use case is when we somehow generate the same header
guard for two different model types (for example when one has a prefix
that is the same as the namespace of another). In this case it would
be nice to be able to override the header guard.
</p>

<p>
In addition, we could also make the namespace separators for modules
configurable; if we didn't use underscores for modules we would not
have a clash. However, its not clear what the separator would then be
(double underscore?).
</p>
</div>
</div>

<div id="outline-container-org719b978" class="outline-4">
<h4 id="org719b978"><span class="section-number-4">5.6.139</span> Consider adding facet specific types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-139">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code-generate simple types for
facets other than <code>types</code> so that I don't have to create them manually.
</p>

</blockquote></div>

<p>
Types in dogen are somewhat "uni-dimensional"; that is, the main focus
of all work is types and the other facets are thought to either be
code generated in total (serialisation, hashing, etc) or manually
generated in total (test for mock factories). However, in some cases
it may make sense to add a type directly to a facet. For example, we
may want to add simple value objects to the mock factory. We don't
want to pollute <code>types</code> with these classes, but at the same time we'd
rather not have to manually generate them. It would be nice to be able
to associate a type with just a facet via dynamic extensions. Of
course, this does mean we would not be able to rely on all other
facets such as serialisation and even streaming or else things would
get a bit confusing. But it would still be useful.
</p>

<p>
Another possible (less clean) approach is this:
</p>

<div class="epigraph"><blockquote>
<p>
It would be great if we could use dynamic extensions to enable and
disable facets (there probably already is a story for this). But in
addition to this, it would also be great if one could override the
default name for an object in a facet; for instance: one could add an
object called <code>serialization_manager</code>, disable all facets bar
serialisation, disable the serialisation postfix of this file and
disable code generation. This way one could add manual code to any of
the facets, independently.
</p>

<p>
At present we support this, but only for types as it is hard-coded.
</p>

</blockquote></div>

<p>
A better understanding for this problem is to think that we have
meta-model elements which have a default behaviour of being projected
into all facets: <code>Projectable</code>. We define projectable elemets in the
modeling space, and then automatically projections happen into
facets. However, it should be possible to also define
"non-projectable" elements, which need a facet to house them. We can
either create a namespace with a stereotype of say <code>&lt;&lt;facet_name&gt;&gt;</code> or
set the meta-data in the element. This has the same effect as
disabling all facets except for the one we're interested in. However,
not-projectable elements lose access to IO, etc (by definition).
</p>
</div>
</div>

<div id="outline-container-orgb08656b" class="outline-4">
<h4 id="orgb08656b"><span class="section-number-4">5.6.140</span> Control JSON output via traits&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-140">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to configure the output JSON so that
I get exactly what the external users are looking for.
</p>

</blockquote></div>

<p>
Once we add support for JSON we will face the same sort of problems
that Json.net has already solved: we may want to have keys that do not
match the property names (for instance we may want to use human
readable names in the json), we may want to translate enumerations to
numbers or to human readable descriptions, we may want to collapse a
class into some less verbose JSON, etc. Some of these are describable
via traits, very much like Json.Net uses C# attributes. We should look
into the available attributes and see if they make sense as dogen
traits to control JSON. Some of these may have wider application and
be used to control other serialisation formats.
</p>
</div>
</div>

<div id="outline-container-org8ad1290" class="outline-4">
<h4 id="org8ad1290"><span class="section-number-4">5.6.141</span> Add support for user defined literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-141">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of literals so that I can
make my code more type safe.
</p>

</blockquote></div>

<p>
With user defined literals in C++11, defining one's own numeric types
became more convenient. We should look into adding support for this in
dogen.
</p>

<p>
See <a href="http://www.codeproject.com/Articles/447922/Application-of-Cplusplus11-User-Defined-Literals-t">Application of C++11 User-Defined Literals to Handling Scientific
Quantities, Number Representation and String Manipulation</a>
</p>

<p>
One interesting way of doing this is as per <a href="http://researcher.ibm.com/researcher/files/zurich-jku/mdse-08.pdf">MDSD</a> book (p111): to
create meta-entities for the quantities. This needs a bit more
analysis but the gist of it is that we could then map quantities to
the most appropriate platform specific technology - in Java/C# create
a type or use a int, in c++ use literals, etc.
</p>
</div>
</div>

<div id="outline-container-org211f009" class="outline-4">
<h4 id="org211f009"><span class="section-number-4">5.6.142</span> Modeling of visitors in <code>cpp</code> can be improved&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-142">
<p>
In the <code>cpp</code> model we are assuming that if the original parent was
visitable, then the visitor was named after it:
</p>

<pre class="example">
            } else if (c.is_original_parent_visitable() &amp;&amp; !c.is_parent()) {
#&gt;
public:
   virtual void accept(const &lt;#= c.original_parent_name() #&gt;_visitor&amp; v) const override {
</pre>


<p>
The right thing to do here is to have a <code>visitor_info</code> attached to the
<code>class_info</code> that is generated during transformation and deals with
all such rules. The template should just loop through the visitor
infos. In addition, the visitor infos should tell the template if they
are abstract or implemented. We may be able to reuse the existing
<code>visitor_info</code> class for this.
</p>
</div>
</div>

<div id="outline-container-org262342b" class="outline-4">
<h4 id="org262342b"><span class="section-number-4">5.6.143</span> Move <code>invalid</code> value to a different value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-143">
<p>
Value zero should always be assigned to the most used enumeration
value because it is very efficient to compare against zero. We should
use a different value for invalid such as <code>0xFF...</code> etc.
</p>
</div>
</div>

<div id="outline-container-org6744398" class="outline-4">
<h4 id="org6744398"><span class="section-number-4">5.6.144</span> Allow renaming <code>invalid</code> enumerator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-144">
<p>
At present we issue the <code>invalid</code> enumerator to signal no
choice. However, in certain cases there are domain specific options
that are better suited (such as <code>none</code>, etc). Users should be able to
change the name of the enumerator.
</p>
</div>
</div>

<div id="outline-container-org472a84f" class="outline-4">
<h4 id="org472a84f"><span class="section-number-4">5.6.145</span> Allow non-throwing casts for enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-145">
<p>
In some cases we want to do a lexical cast of an enum but not actually
throw if the enum is invalid; instead, we just want the enum mapped to
invalid (if that is enabled). This should just be a case of adding a
boolean to the cast templates.
</p>

<p>
It seems boost now supports this via <code>try_lexical_convert</code>. However,
it seems its non-trivial to convert our use of lexical cast into this
new approach. The problem is that we did not simply provide an
<code>operator&lt;&lt;</code> for each enum, we overloaded <code>lexical_cast</code>. We did this
because we are already using <code>operator&lt;&lt;</code> for the purposes of <code>io</code>,
and that requires a JSON based output which is not suitable for
casting. Its not clear what the right approach is here.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we could make use of manipulators; perhaps a <code>masd::json</code>
manipulator could be used to coerce <code>operator&lt;&lt;</code> to format into
JSON, otherwise we'd get a default string representation.</li>

<li><a href="https://www.boost.org/doc/libs/1_71_0/boost/lexical_cast/try_lexical_convert.hpp">try<sub>lexical</sub><sub>convert.hpp</sub></a></li>
<li><a href="https://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast/synopsis.html#boost_lexical_cast.synopsis.try_lexical_convert">try<sub>lexical</sub><sub>convert</sub> docs</a></li>
<li><a href="https://stackoverflow.com/questions/2249711/how-to-use-the-boost-lexical-cast-library-for-just-for-checking-input">How to use the boost lexical<sub>cast</sub> library for just for checking
input</a></li>
<li><a href="http://boost.2283326.n4.nabble.com/lexical-cast-A-non-throwing-lexical-cast-Was-5-Observations-My-experience-with-the-boost-libraries-td2671153.html">A non-throwing lexical cast?</a></li>
<li><a href="https://stackoverflow.com/questions/3157098/whats-the-right-approach-to-return-error-codes-in-c">Whats the right approach to return error codes in C++</a></li>
</ul>
</div>
</div>

<div id="outline-container-org92493e2" class="outline-4">
<h4 id="org92493e2"><span class="section-number-4">5.6.146</span> Consider adding a better enum representation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-146">
<p>
Useful functionality:
</p>

<ul class="org-ul">
<li>from string, no throw. Only available if enumeration has invalid.</li>
<li>from string, throw. Requires stdexcept, throws std::invalid<sub>argument</sub>.</li>
<li>to string, no throw.</li>
<li>to string, throw.</li>
<li>parameterisation of strings: qualified or non-qualified.</li>
<li>container. Using container conventions, <code>value_type</code> is the
enumeration, <code>underlying_type</code> is the built-in type.</li>
</ul>

<p>
When creating the class, it would be nice to maintain the strong
semantics of C++ 11 enums whilst at the same time having a nice
namespace for the enumeration.
</p>

<p>
We probably need to have multiple enum providers - or better:
styles. This is c++ specific
(e.g. <code>masd.enumeration.cpp.style</code>). Styles:
</p>

<ul class="org-ul">
<li>plain:
<ul class="org-ul">
<li>C++ 98: plain enum, no enum class.</li>
<li>C++ 11 and above: plain enum, no enum class.</li>
</ul></li>
<li>strong:
<ul class="org-ul">
<li>C++ 98: inside class</li>
<li>C++ 11 and above: plain enum with enum class.</li>
</ul></li>
<li>encapsulated: (improved, featureful, ?)
<ul class="org-ul">
<li>Enum as a class with iteration, string support, etc. This is the
"masd" provider/style. With conversion methods.</li>
</ul></li>
<li>external library: <a href="https://github.com/therocode/meta_enum">meta-enum</a>, <a href="https://github.com/aantron/better-enums">better-enums</a>, <a href="https://github.com/nadult/fwk_enum">fwk<sub>enum</sub></a>, etc. The style
is the name of the library.</li>
</ul>

<p>
We should also take into consideration the "boolean enum" scenario,
whereby we want a wrapper around a boolean. See <a href="https://codereview.stackexchange.com/questions/11300/boolean-enums-improved-clarity-or-just-overkill">Boolean enums:
improved clarity or just overkill?</a> Ideally the metamodel should make
this clear rather than having to set meta-data type to bool and then
making sure there are only two values. In effect, we have three
different types of enumerations:
</p>

<ul class="org-ul">
<li>regular enumerations;</li>
<li>boolean enumerations;</li>
<li>flags.</li>
</ul>

<p>
The metamodel must reflect this.
</p>
</div>

<ol class="org-ol">
<li><a id="orgb7dc736"></a>Scenarios:<br />
<div class="outline-text-5" id="text-5-6-146-1">
<ul class="org-ul">
<li>create from value:</li>
</ul>

<pre class="example">
const my_enum a(my_enum::my_value);
</pre>


<p>
Type is named after the enum, values are accessible by scope, e.g.:
<code>my_enum::</code>.
</p>

<ul class="org-ul">
<li>initialise from string:</li>
</ul>

<pre class="example">
const auto a(my_enum::from_string("my_value"));
const auto a(my_enum::from_string("my_enum::my_value"));
</pre>


<ul class="org-ul">
<li>initialise from string with exceptions:</li>
</ul>

<pre class="example">
const auto a(my_enum::from_string_throw("my_value"));
const auto a(my_enum::from_string_throw("my_enum::my_value"));
</pre>


<p>
Problems: users cannot disable qualified/non-qualified conversions.
</p>

<ul class="org-ul">
<li>dump to string, non-qualified:</li>
</ul>

<pre class="example">
std::cout &lt;&lt; a.to_string(); // my_value
</pre>


<ul class="org-ul">
<li>dump to string, qualified:</li>
</ul>

<pre class="example">
std::cout &lt;&lt; a.to_string_qualified(); // my_enum::my_value
</pre>


<ul class="org-ul">
<li>pretty print:</li>
</ul>

<pre class="example">
std::cout &lt;&lt; a; // my_enum::my_value
</pre>


<p>
Problems: we need to distinguish between dumping to string in the
sense of pretty printing from a string conversion.
</p>

<ul class="org-ul">
<li>iterate:</li>
</ul>

<pre class="example">
for (const auto e : my_enum::values())
   std::cout &lt;&lt; e.to_string();
</pre>


<ul class="org-ul">
<li>similarly named enums cannot be confused.</li>
</ul>

<pre class="example">
a::colour c = b::colour::red; // does not compile.
a::colour c = c::colour::red; // compiles.
</pre>
</div>
</li>

<li><a id="org3af8493"></a>Notes<br />
<div class="outline-text-5" id="text-5-6-146-2">
<ul class="org-ul">
<li>a good compromise from the ideal scenario is to create a
<code>my_enum_traits</code> class. Sadly, it cannot be <code>my_enum::traits</code>. The
API then becomes:</li>
</ul>

<pre class="example">
my_enum_traits::from_name("X"); // accepts both simple and qualified
my_enum_traits::from_simple_name("X");
my_enum_traits::from_qualified_name("X:X");
my_enum_traits::to_simple_name(e);
my_enum_traits::to_qualified_name(e);
</pre>


<pre class="example">
my_enum_traits::from_name_throw("X"); // accepts both simple and qualified
my_enum_traits::from_simple_name_throw("X"); // rather than string
my_enum_traits::from_qualified_name_throw("X:X");
my_enum_traits::from_underlying_type(123); // validates cast
my_enum_traits::from_underlying_type_throw(123); // validates cast
my_enum_traits::to_simple_name_throw(e);
my_enum_traits::to_qualified_name_throw(e);
</pre>


<pre class="example">
my_enum_traits::values(); // static array of enum.
my_enum_traits::names(); // static array of names.
</pre>


<pre class="example">
my_enum_traits::to_index(e); // position of enum in names, values.
my_enum_traits::to_index_throw(e); // position of enum in names, values.
</pre>


<ul class="org-ul">
<li>the non-throwable functions are only defined if invalid is
available.</li>
<li>use <code>noexcept</code> on the non-throwable functions.</li>
<li>use <code>string_view</code> on C++ 17, <code>string</code> elsewhere.</li>
<li>use <code>array</code> on c++ 11 and above, else <code>vector</code>.</li>
<li>enum should be defined as a class on c++ 98. In this case we
probably do not need a separate traits class.</li>
<li>define a boost lexical cast from string and to string in terms of
the above functions. This can be enabled by the user via meta-data.</li>
<li>crazy idea: we could also create a map of enum to T where T is a
<code>std::function</code>. Something like a "dispatchable" class. Users can
set functions and then call <code>dispatch(x)</code> which will execute the
method at <code>to_index(x)</code>. No use case for it yet though.</li>
<li>stroustrup proposes using operators with enums. However, its not
clear there are good operators for all of the use cases above.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.ibm.com/developerworks/rational/library/scoped-enums/index.html">C++0x, scoped enums</a></li>
<li><a href="https://stackoverflow.com/questions/36937912/specializing-boostlexical-cast-for-enums-in-boostproperty-maps">specializing boost::lexical<sub>cast</sub> for enums in boost::property<sub>maps</sub></a></li>
<li><a href="https://stackoverflow.com/questions/28828957/enum-to-string-in-modern-c11-c14-c17-and-future-c20">enum to string in modern C++11 / C++14 / C++17 and future C++20</a></li>
<li><a href="https://stackoverflow.com/questions/21295935/can-a-c-enum-class-have-methods">Can a C++ enum class have methods?</a></li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgbb34528" class="outline-4">
<h4 id="orgbb34528"><span class="section-number-4">5.6.147</span> Bitmask enumeration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-147">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to define a bitmask enumeration in
dogen so that I don't have to create it manually.
</p>

</blockquote></div>

<p>
We should have a dynamic extension flag that generates enumerators
with values that are powers of two. These can then be used for flags,
as per the bitset story.
</p>

<p>
The metamodel element should reflect the enumeration type (flag or
not). The computation of the flags should take place as part of the
metamodel tranforms. If the user supplies values, validation must
ensure they are valid as flags (powers of 2). Values should be written
as hex values (unless users specify decimal). Actually we should
create a separate metamodel element for flags called <code>flags</code> or
<code>bitmasks</code> so that it is obvious at the metamodel element level that
these are distinct concepts.
</p>

<p>
Framework guidelines state that enumerators for flags should use
plural nouns or noun phrases and simple enums should use singular
nouns or noun phrases.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>interesting methods for flags: is exactly one bit set, count on
bits, are all bits on, are any bits on, turn all bits on/off. A flag
builder would be nice as well: turn<sub>on</sub> / turn<sub>off</sub>(flag) which
returns the updated flag:</li>
</ul>

<pre class="example">
my_flags_builder b;
const auto f(b.turn_on(my_flags::flag_a).
  turn_on(my_flags::flag_b));
</pre>


<ul class="org-ul">
<li>it should be possible to have flags which represent commonly used
flags, for example: read, write, read<sub>write</sub>. In this case, the value
of the flag must be a set of existing flags on the enumeration.</li>
<li>validation should not allow setting flags value to zero. Issue a
warning violating the framework design guidelines. However, there
should be a flag to force this if users really need it.</li>
<li>for flags, 0 must always mean "none", as in "all flags are
cleared".</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://dreamdota.com/explore-c-20-bitmask-design/">Explore C++20 Bit Flag with Designated Initializer and Concepts</a></li>
<li><a href="https://m-peko.github.io/craft-cpp/posts/different-ways-to-define-binary-flags/">Different Ways To Define Binary Flags</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf524463" class="outline-4">
<h4 id="orgf524463"><span class="section-number-4">5.6.148</span> Support for file level comments via annotations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-148">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I may want to add comments at the file level
so that I can provide documentation to the model users.
</p>

</blockquote></div>

<p>
We could easily have a tag for file level comments and transport that
all the way to the output. The only problem is that it would be a one
liner only so it may not be that useful.
</p>

<p>
Multi-line support could be simulated by concatenating multiple
entries - cumbersome but workable&#x2026;
</p>
</div>
</div>

<div id="outline-container-org52cbf93" class="outline-4">
<h4 id="org52cbf93"><span class="section-number-4">5.6.149</span> Add getter and setter prefixes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-149">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to change the default getter and
setter conventions so that I can integrate my code with
dogen-generated code.
</p>

</blockquote></div>

<p>
External users may have getter and setter prefix conventions such as
<code>set_prop</code> or <code>SetProp</code>. It would be nice if we could pass in a
getter/setting prefix and then dogen would append them when converting
the diagram, e.g. <code>--getter-prefix=set_</code>.
</p>

<p>
We should check what ODB has done for this and implement the same
pattern.
</p>

<p>
We should also look for some support in clang format, although it
seems very unlikely.
</p>

<p>
In fact this is related to the notion of "themes" we need in dogen. We
need to do some work around the possible "styles" that exist for
member variable naming, and then allow users to choose their
style. See <a href="#org819ff32">Add support for "capitalisation theming"</a>
</p>
</div>
</div>

<div id="outline-container-org25ba0f0" class="outline-4">
<h4 id="org25ba0f0"><span class="section-number-4">5.6.150</span> Add support for boost concept&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-150">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code-generate boost concepts so
that I don't have to manually create them.
</p>

</blockquote></div>

<p>
Now dogen supports concepts, the natural thing to do is to express
them in C++ code. This could easily be done using boost concept, or
the C++-14 concepts light.
</p>

<p>
See <a href="http://www.boost.org/doc/libs/1_53_0/libs/concept_check/creating_concepts.htm">Creating Concepts</a>.
</p>

<p>
It is important to be able to switch the concept generation off
too. We may want to create concepts for internal purposes but have no
need to actually express it in code. This could be suppressed via
meta-data.
</p>
</div>
</div>

<div id="outline-container-org978da85" class="outline-4">
<h4 id="org978da85"><span class="section-number-4">5.6.151</span> Add documentation for concepts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-151">
<p>
It seems it is possible to document a concept in doxygen:
</p>

<p>
<a href="http://stackoverflow.com/questions/10087171/documenting-a-c-concept-using-doxygen">Documenting a C++ concept using doxygen?</a>
</p>
</div>
</div>

<div id="outline-container-org2e6253b" class="outline-4">
<h4 id="org2e6253b"><span class="section-number-4">5.6.152</span> Consider adding support for keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-152">
<p>
We had originally added some half-baked support for key
generation. The basic idea is that users could mark certain properties
in a class as being part of a key and dogen would automatically create
a key. The key could be versioned or unversioned. However, we never
had a use case for it and the feature was not implemented in a
convincing way. Having said that, it seems like a useful feature for
things such as caches etc so we may want to resurrect it as some point
in the future.
</p>

<p>
This was removed in 4ed3fbd.
</p>

<p>
Validation rules:
</p>

<ul class="org-ul">
<li>ensure that we can only define identity once across concepts and
parents</li>
<li>the name of all keys in objects, etc must be part of the current
model.</li>
<li>the qnames of all types as keys are consistent with the values.</li>
<li>entity must have at least one key attribute.</li>
<li>non entity must not have key attributes (value, service)</li>
<li>keyed must be entity.</li>
<li>aggregate root must be entity.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Definition of Identity Attribute</b>
</p>

<pre class="example">
{
    "name" : {
        "simple" : "identity_attribute",
        "qualified" : "yarn.dia.identity_attribute"
    },
    "ownership_hierarchy" : {
        "model_name" : "yarn.dia"
    },
    "value_type" : "boolean",
    "definition_type" : "instance",
    "scope" : "property"
}
</pre>


<p>
This was removed in commit <code>5e80256</code>:
</p>

<p>
yarn.dia: remove support for identity attribute
</p>

<p>
<b>Create a <code>key_extractor</code> service</b>
</p>

<p>
We need a way to automatically extract a key for a <code>keyed_entity</code>.
The right solution is to create a service to represent this
concept.
</p>

<p>
Injector creates objects for these just like it does with keys; the
C++ transformer intercepts them and generates the correct view models.
</p>

<p>
<b>Use explicit casting for versioned to unversioned conversions</b>
</p>

<p>
At present we have to<sub>versioned</sub>; in reality this would be dealt much
better using explicit casts:
</p>

<pre class="example">
explicit operator std::string() { return "explicit"; }
</pre>


<p>
Actually the real solution for this is to make the versioned key
contain the unversioned key; then dogen will generate all the
required code.
</p>

<p>
At this point in time we do not have enough use cases to make the
correct design decisions in this area. We need to wait until we start
using keys in anger in Creris and then design the API around the use
cases.
</p>

<p>
It is not possible to use global cast operators so we need to
introduce a dependency between versioned and unversioned keys in order
for this to work.
</p>

<p>
<b>Consider not creating unversioned keys for single property</b>
</p>

<p>
If a key is made up of a single property, its a bit nonsensical to
create an unversioned key. We should only generate the versioned
key. However, it does make life easier. Wait for real world use cases
to decide.
</p>

<p>
<b>Add new equivalence operator to domain types that ignores version</b>
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like to know if two objects are
equal ignoring the version properties so that I can model my domain
more accurately.
</p>

</blockquote></div>

<p>
We should have an operator that compares the state of two objects
ignoring the version (for versioned objects).
</p>
</div>
</div>

<div id="outline-container-org02d6eb5" class="outline-4">
<h4 id="org02d6eb5"><span class="section-number-4">5.6.153</span> Add versioning support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-153">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make changes to diagrams in a
backwards compatible way so that I can upgrade the users of my code
incrementally.
</p>

</blockquote></div>

<p>
We had some basic support for versioning but it was half-baked. It was
removed in 4ed3fbd.
</p>

<p>
Validation rules:
</p>

<ul class="org-ul">
<li>is versioned objects must have a property called version.</li>
</ul>

<p>
<b>New understanding</b>:
</p>

<ul class="org-ul">
<li>Add versioning support by adding versions at the object level and at
the property level. Properties with 0 version will have no special
handling. Properties with non-zero version (V) will have the
following code added in serialisation:</li>
</ul>

<pre class="example">
if (version &gt; V)
   // read or write property
</pre>


<ul class="org-ul">
<li>If a number of consecutive properties all share the same version,
dogen will group them under the same version if. There will be no
other special grouping or otherwise changing of order of properties.</li>
<li>The object version will be max(version) of all properties for that
class, excluding inherited properties.</li>
<li>The object version will be stamped using boost serialisation class
version macro, unless the object version is zero.</li>
<li>Dogen will make no validation or otherwise dictate the management of
version numbers; its up to the users to ensure they make sensible
backwards compatibility decisions such as adding only new properties
and always adding to the end.</li>
<li>The model version is a human level concept and has no direct
relation to class versioning. It will be implemented as an
implementation specific parameter in the Dia model and as a string
in the yarn model class. See "improve code generation marker story".</li>
<li>Model version will be used for the following:
<ul class="org-ul">
<li>stamped on doxygen documentation for the model namespace;</li>
<li>stamped on DLLs, etc.</li>
<li>used by humans to convey the "type" of changes made to the
diagram/model (e.g. a minor version bump is a small change, etc).</li>
</ul></li>
</ul>

<p>
Previous understanding:
</p>

<p>
Versioning support is now available in yarn, so we need to apply it to
yarn itself. That is, we need a way of having two versions of an yarn
model coexist, and allow Dogen to diff those two versions to make code
generation decisions so that we can add basic backwards compatibility
support.
</p>

<p>
Before we can do this, we need a way of stamping a model version into
models. This can easily be done via implementation specific
parameters. See "improve code generation marker story".
</p>

<p>
We then need to create some kind of strategy for version number
management:
</p>

<ul class="org-ul">
<li>minor bumps are backwards compatible; e.g. only adding new fields.</li>
<li>major bumps are not backwards compatible: e.g. deleting fields,
classes, etc.</li>
</ul>

<p>
However, at present we only support a single version number. Perhaps
we should just declare which versions are backwards compatible and
which ones are not.
</p>

<p>
Once all of these are in place we should add versioning support to
dogen:
</p>

<ul class="org-ul">
<li>add a new command line argument: <code>--previous-version</code> or something
of the kind.</li>
<li>the model supplied by this argument must have the same name as the
model supplied by <code>--target</code>.</li>
<li>change all yarn types to be versioned.</li>
<li>dogen will load up both models, and stamp the versions in each
type. Merger will then be responsible for stamping the versions on
each property, taking previous and new as input.</li>
<li>for every field which is in new model but not in previous, add boost
serialisation code to handle that.</li>
<li>add unit tests with v1, v2 models.</li>
<li>in order for dia diagrams with multiple versions to coexist in the
same directory we will probably need to add the version to the
diagram name, e.g. <code>sml_1.dia</code> or <code>sml_v1.dia</code>. We probably need
some parsing code that looks for the last few characters of the file
name and if it obeys a simple convention such as <code>_v</code> followed by a
number, it ignores these for the model name and uses it for the
version.</li>
</ul>

<p>
With this in place, when rebasing we can now do a proper comparison
between expected and actual.
</p>

<p>
Potential future feature: to put the files of different versions in
separate folders. This would allow the creation of "conversion" apps
which take types for one version and transform them into the next
version.
</p>
</div>
</div>

<div id="outline-container-orgc404877" class="outline-4">
<h4 id="orgc404877"><span class="section-number-4">5.6.154</span> Add support for boost parameter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-154">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of boost parameter so
that I can generate classes with named parameters without having to
manually create this code.
</p>

</blockquote></div>

<p>
It would be nice to have boost parameter support. <a href="http://www.boost.org/doc/libs/1_53_0/libs/parameter/doc/html/index.html#named-function-parameters">Documentation here</a>.
</p>

<p>
Ideally one would mark a type with a stereotype such as <code>named
parameter</code> and this would result in a full constructor with named
parameters. However since it seems one has to add a lot of boiler
plate code, perhaps its better to have a create function on a separate
header which internally calls the appropriate setters.
</p>
</div>
</div>

<div id="outline-container-org3f3aa94" class="outline-4">
<h4 id="org3f3aa94"><span class="section-number-4">5.6.155</span> Add composite stereotype&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-155">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code generate composite objects so
that I don't have to do it manually.
</p>

</blockquote></div>

<p>
It would be nice if one could just mark a object as <code>composite</code> and dogen
automatically created the composite structure. As we only support
boost shared pointer that's what we'd use. We have a few use cases for
this (node, nested qname, etc).
</p>

<p>
This would be part of the injection framework.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a></li>
</ul>
</div>
</div>

<div id="outline-container-org922bb19" class="outline-4">
<h4 id="org922bb19"><span class="section-number-4">5.6.156</span> Add support for bitsets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-156">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of bitsets in dogen so
that I don't have to manually generate code for types that use it.
</p>

</blockquote></div>

<p>
We are using a lot of boolean variables in yarn. In reality, these all
could be implemented with <code>std::bitset</code>, plus an enumeration. One
possible implementation is:
</p>

<ul class="org-ul">
<li>add <code>std::bitset</code> to std model.</li>
<li>create a new stereotype of bitset.</li>
<li>classes with stereotype bitset are like enumerations, e.g. users are
expected to add a list of names to the class.</li>
<li>dogen will then implement the properties of type bitset as a
<code>std::bitset</code> of the appropriate size, and also generate an
enumeration which can be used for indexing the bitset. This may need
to be a C++-03 enumeration, due to type safety in C++-11
enumerations.</li>
<li>we should also implement default bitsets with values corresponding
to the flags.</li>
</ul>

<p>
Example usage:
</p>

<pre class="code"><code><span style="color: #339CDB; font-weight: bold;">const</span> <span style="color: #35CDAF;">unsigned</span> <span style="color: #35CDAF;">int</span> <span style="color: #85DDFF;">my_bitset_size</span><span style="color: #C586C0;">(</span>10<span style="color: #C586C0;">)</span>;
<span style="color: #339CDB;">std</span>::<span style="color: #35CDAF;">bitset</span><span style="color: #C586C0;">&lt;</span>my_bitset_size<span style="color: #C586C0;">&gt;</span> <span style="color: #85DDFF;">bs</span>;

bs<span style="color: #C586C0;">[</span>first_flag_index<span style="color: #C586C0;">]</span> = 1;
bs = first_flag_value;
</code></pre>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.java2s.com/Tutorial/Cpp/0360__bitset/Usebitsetwithenumtogether.htm">Use bitset with enum together</a></li>
<li><a href="http://stackoverflow.com/questions/9857239/c11-and-17-5-2-1-3-bitmask-types">C++11 and {17.5.2.1.3} Bitmask Types</a></li>
<li><a href="https://www.justsoftwaresolutions.co.uk/cplusplus/using-enum-classes-as-bitfields.html">Using Enum Classes as Bitfields</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2679774" class="outline-4">
<h4 id="org2679774"><span class="section-number-4">5.6.157</span> Add string table support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-157">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code-generate "enumerations" of
strings so that I don't have to create them manually.
</p>

</blockquote></div>

<p>
We need a way of creating "tables" of strings such as for example for
listing all the valid values for dia field names, etc. We could
implement this by creating a new stereotype where the name is the
string name and the default value is the string value. All strings
would be static public members of a class.
</p>

<p>
We should also add a validate method which checks to see if a string
is a valid value according to the string table. We could have a "case
insensitive" validate too.
</p>

<p>
Actually, we don't even need a new stereotype for this; we could just
use <code>enumeration</code> and detect when the underlying type is
string. However, as we can have many types of strings, this needs to
be configurable at the meta-model level:
</p>

<ul class="org-ul">
<li>char*</li>
<li>char[]</li>
<li>string view</li>
<li>std::string</li>
<li>QString and other toolkit specific strings</li>
<li>etc.</li>
</ul>

<p>
Presumably the families we have already set up could be useful for
this:
</p>

<pre class="example">
"quilt.cpp.helper.family": "String",
</pre>


<p>
We just need to promote these from backend helper families to
something at the meta-model level (type families?). However, the user
should still be able to configure how the "enumeration" comes out
(e.g. string, string view etc), but the defaults should be best we can
given the user options (version of C++ standard, etc).
</p>

<p>
The other interesting aspect is whether there should be an enumeration
connected to the string table (perhaps optionally) such that users
could <code>switch</code> and so forth. These could all be options whenever you
choose a type of the string family (create enumeration, create
converter for container of string, etc).
</p>

<p>
Validation rules:
</p>

<ul class="org-ul">
<li>string table cannot have duplicate entries.</li>
</ul>
</div>
</div>

<div id="outline-container-org84b6eda" class="outline-4">
<h4 id="org84b6eda"><span class="section-number-4">5.6.158</span> Enumeration string conversion could be configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-158">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to configure the input strings that
get converted into enumerations so that I can adapt it to my
requirements.
</p>

</blockquote></div>

<p>
It should be possible to pass in one or more string values as model
specific parameters that tell Dogen what valid values a user defined
enumerator can have. We can then generate a "from string" a method
that does the appropriate conversions.
</p>

<p>
These values should be passed in as dynamic extensions. At present
enumerators do not have dynamic extensions support so we need to add
it too. We could add a property to the meta-model: alias. Users can
associate one or more alises with an enumerator. These are added to
the element via meta-data. The from string method goes through the
list of aliases and uses them for the conversion.
</p>

<p>
Note that the inverse use case is also valid: one may want to map an
enumerator to one or more strings (e.g. "to string"). As with "from
string", a set of dynamic extensions could be use to supply the
mapping. Ideally, one enumerator should map to a single string but it
is conceivable there are other use cases (context sensitive
mappings). Note that it is not necessarily the case that the mapping
is bidirectional - i.e. "to string" is not required to be the inverse
function of "from string" and vice-versa. For the simple case where we
just want one mapping we could have something like "string value".
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>Use <code>string_view</code> on c++ 17.</li>
</ul>
</div>
</div>

<div id="outline-container-org70e8c9a" class="outline-4">
<h4 id="org70e8c9a"><span class="section-number-4">5.6.159</span> Enumeration string dumps could be configurable&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-159">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to output user defined strings from
enumerations so that I can adapt it to my requirements.
</p>

</blockquote></div>

<p>
It should be possible to pass in a string value as a dynamic extension
that tells dogen what string to use for debug dumping. At present
enumerators do not have dynamic extensions support so we need to add
it too (e.g. add the concept to them).
</p>
</div>
</div>

<div id="outline-container-org13aa0f6" class="outline-4">
<h4 id="org13aa0f6"><span class="section-number-4">5.6.160</span> Add is comparable to coding&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-160">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to define types as comparable so that
I can use them in ordered containers.
</p>

</blockquote></div>

<p>
A object can have a stereotype of comparable. If so, then at least one
property must be marked as comparable. Properties are marked as
comparable if they have an implementation specific parameter called
<code>comparison_order</code>. <code>comparison_order</code> is a sequence starting at 0 and
incrementing by 1; it determines the order in which properties are
compared between two objects of the same type.
</p>

<p>
In order for a property to qualify as a comparison candidate its type
must be:
</p>

<ul class="org-ul">
<li>built-in;</li>
<li><code>std::string</code>;</li>
<li>a object marked as comparable.</li>
</ul>

<p>
Some facts about comparable objects:
</p>

<ul class="org-ul">
<li>they generate <code>operator&lt;</code> as a global operator in the type
header file.</li>
<li>they can be keys in <code>std::map</code> and <code>std::set</code>.</li>
</ul>

<p>
Relation to keys:
</p>

<ul class="org-ul">
<li>If all properties that are part of a key are also comparable then
the key will be comparable.</li>
<li>comparable versioned keys always compare the version after all other
comparable properties.</li>
</ul>

<p>
If an object itself is marked as comparable, then it is equivalent to mark
all properties as comparable using their relative position as the
comparison order.
</p>

<p>
Validation:
</p>

<ul class="org-ul">
<li>objects marked as is comparable must follow the <a href="#org13aa0f6">comparison rules</a>.</li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>maybe we need to have multiple strategies for <code>operator&lt;</code>. The
simplest case is the user marks the properties in the class and we
call <code>operator&lt;</code> on those in the defined order. The second case is
where the user wants to create a key from those properties, as an
external class. Another case is where the user wants to hand-craft
the operator using merging support (any of the several possible
merging strategies).</li>
</ul>

<p>
<b>Merged with ordered containers story:</b>
</p>

<p>
In order to provide support for ordered containers such as maps and
sets we need to define <code>operator&lt;</code>. However, it makes no sense to code
generate this operator as its unlikely we'll get it right. We could
assume the user wants to always sort by key, but that seems like a bad
assumption. The alternatives are:
</p>

<ul class="org-ul">
<li>to expect a user-defined <code>entity_name_less_than.hpp</code> in domain. we'd
automatically ignore any files matching this patter so the user can
create them and not lose it. The problem with this approach is that
we may have different sort criteria. This is a good YAGNI start.</li>
<li>to provide the <code>Compare</code> parameter in the template and then expect a
user-defined <code>entity_name_Compare.hpp</code>. The same ignore
applies. This would allow users to provide any number of comparison
operations.</li>
</ul>

<p>
Either approach requires support for ignoring files and folders based
on regex.
</p>

<p>
Another way of generating comparators is explained here:
</p>

<p>
<a href="http://playfulprogramming.blogspot.se/2016/01/a-flexible-lexicographical-comparator.html">A flexible lexicographical comparator for C++ structs</a>
</p>
</div>
</div>

<div id="outline-container-org6162ac7" class="outline-4">
<h4 id="org6162ac7"><span class="section-number-4">5.6.161</span> Add support for type framing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-161">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to send model types over the wire so
that I can build networked applications.
</p>

</blockquote></div>

<p>
In places such as a cache or a socket, it may be useful to create a
basic "frame" around serialised types. The minimum requirements for a
frame would be a model ID, a type ID, a "format" (i.e. xml, text, etc)
and potentially a size, depending on the medium. The remainder of the
frame would be the payload - i.e. the serialised object.
</p>

<p>
In order for this to work we probably need the concept of a "model
group"; the type frame would be done for a group of models.
</p>

<p>
This can be done with or without boost fusion. See this presentation
for details on a boost fusion approach:
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v%3DwbZdZKpUVeg">CppCon 2014: Thomas Rodgers "Implementing Wire Protocols with Boost Fusion"</a></li>
</ul>
</div>
</div>

<div id="outline-container-org996fc2f" class="outline-4">
<h4 id="org996fc2f"><span class="section-number-4">5.6.162</span> Add pimpl support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-162">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code generate PIMPL objects so
that I don't have to do it manually.
</p>

</blockquote></div>

<p>
It may be useful to mark classes as pimpl and generate a private
implementation. On the public header we could forward declare all
types.
</p>
</div>
</div>

<div id="outline-container-org2d3eaab" class="outline-4">
<h4 id="org2d3eaab"><span class="section-number-4">5.6.163</span> Manual typedef generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-163">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of manually generated
typedefs in automated code so that I don't have to manually generate
all code that makes use of these typedefs when when its trivial code.
</p>

</blockquote></div>

<ul class="org-ul">
<li>We should be able to create a stereotype of <code>typedef group</code>. This is
a object type with lots of attributes. The code generator will take
the name and type of each attribute and generate a file with the
name of the group and all the typedefs inside.</li>
<li>We should be able to create a forward declarations like header that
defines typedefs for <code>shared_ptr</code> etc at the users choosing. This
could be implemented as a tag. We could create a <code>memory_fwd</code> header
to avoid cluttering the main <code>fwd</code> file for the type. We will need
another type of relationship to model this, as well as another type
of file in tags; the file would then have several Boolean flags one
can tick such as <code>std_shared_ptr</code>, <code>boost_shared_ptr</code> and so on.</li>
<li>it should also be possible to add some dynamic extensions to an
attribute and get it to generate a typedef, e.g. cpp.typedef = "xyz"
would result in the creation of typedef xyz using the type of the
attribute; getters, setters and property would then be declared with
the typedef.</li>
<li>actually we should have a "type alias" at the modeling level. This
is just a simple mapping of a type to a type definition. This makes
using types such as <code>dec:decimal&lt;8&gt;</code> etc possible without changing
the parsing code.</li>
</ul>
</div>
</div>

<div id="outline-container-orgff8511d" class="outline-4">
<h4 id="orgff8511d"><span class="section-number-4">5.6.164</span> Automatic typedef generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-164">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want dogen to generate typedefs so that I
don't have to create them manually.
</p>

</blockquote></div>

<p>
We should generate typedefs for all smart pointers, containers, etc -
basically anything that has template arguments. This would make
generated code much more readable and could also be used by client
code. In theory all we need is:
</p>

<ol class="org-ol">
<li>determine if the property has type arguments;</li>
<li>if so, construct the typedef name by adding <code>_type</code> to the property
name, e.g. <code>attribute_value</code> becomes <code>attribute_value_type</code>, etc;</li>
<li>create a typedef section at the top of the class declaring all
typedefs;</li>
<li>add a property to the property view model containing the typedef
name and use it instead of the fully qualified type name.</li>
<li>we should also generate a typedef for the key if the class is an
entity. See Typedef keys for each type.</li>
</ol>

<p>
We could also always generate a typedef for smart pointers in the
class that uses the smart pointer, with a simple convention such as
<code>attribute_value_ptr_type</code> or <code>shared_attribute_value_type</code>.
</p>
</div>
</div>

<div id="outline-container-org12dc46d" class="outline-4">
<h4 id="org12dc46d"><span class="section-number-4">5.6.165</span> Add support for iterable enumerations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-165">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want enumerations to be iterable so that I
don't have to manually create code to do this.
</p>

</blockquote></div>

<p>
We should create an additional aspect for each enumerations which
creates a <code>std::array</code> with the enumerators (excluding invalid). This
would allow plugging the enumerations into for loops, boost ranges,
etc. The CPP should contain a static array; The HPP contains a method
which returns it, e.g. <code>my_enumeration_to_array.hpp</code>:
</p>

<pre class="example">
std::array&lt;my_enumeration, 5&gt; my_enumeration_to_array();
</pre>


<p>
We could make this slightly more generic by adding the notion of
enumeration groups. Out of the box we have:
</p>

<ul class="org-ul">
<li>all: includes invalid;</li>
<li>valid: excludes invalid</li>
</ul>

<p>
Users could then add implementation specific properties to create
other groups if needed.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nadult/fwk_enum%0A">fwk<sub>enum</sub></a>: Improved C++14 enum class with iteration and conversion to
strings</li>
</ul>
</div>
</div>

<div id="outline-container-org1b0c82a" class="outline-4">
<h4 id="org1b0c82a"><span class="section-number-4">5.6.166</span> Add support for enumeration subsets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-166">
<p>
Sometimes we have a large enumeration which is made up of several
smaller subsets. For example in yarn we have well-known stereotypes;
these can be grouped into subsets such as element types, etc. It would
be nice to be able to declare these subsets in the meta-model and:
</p>

<ul class="org-ul">
<li>code-generate automatically methods that extract all enumerations in
the subset, not in the subset;</li>
<li>create a bool function that given an enumerator tells us if it is in
a subset or not.</li>
</ul>
</div>
</div>

<div id="outline-container-org3ffb028" class="outline-4">
<h4 id="org3ffb028"><span class="section-number-4">5.6.167</span> Add support for load testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-167">
<p>
Once we have proper support for test data sets (e.g. generate
realistic data) and once we have proper support for networking
(e.g. HTTP, etc), we should consider adding "load testing"
features. That is, we could generate requests (based on suitably
annotated types). We could offer some kind of base functionality for
load testing (requests per second, size, etc).
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/sepehrdaddev/Xerxes">Xerxes GH</a>: DOS tool</li>
<li><a href="https://ntietz.com/tech-blog/load-testing-is-hard-but-why/">Load testing is hard, and the tools are&#x2026; not great. But why?</a>: blog
post on load testing. <a href="https://news.ycombinator.com/item?id=25641234">HN discussion</a>.</li>
<li><a href="https://github.com/tsenart/vegeta">vegeta GH</a>: "Vegeta is a versatile HTTP load testing tool built out
of a need to drill HTTP services with a constant request rate. It
can be used both as a command line utility and a library."</li>
<li><a href="https://en.wikipedia.org/wiki/Apache_JMeter">Apache JMeter wikipedia</a>: "Apache JMeter is an Apache project that
can be used as a load testing tool for analyzing and measuring the
performance of a variety of services, with a focus on web
applications."</li>
<li><a href="https://en.wikipedia.org/wiki/Gatling_(software)">Gatling wikipedia</a>: "Gatling is an open-source load- and
performance-testing framework based on Scala, Akka and Netty."</li>
<li><a href="https://k6.io/">https://k6.io/</a>: Open source load testing tool and SaaS</li>
</ul>
<p>
for engineering teams.
</p>
</div>
</div>

<div id="outline-container-org1062840" class="outline-4">
<h4 id="org1062840"><span class="section-number-4">5.6.168</span> Add support for user supplied test data sets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-168">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of test data without
having to manually add code for it.
</p>

</blockquote></div>

<p>
<b>New understanding</b>:
</p>

<p>
We need to create a test data sets model. it should have an
enumeration for all of the available test data sets, and an
enumeration for the valid file formats. we should be able to pass in a
pair of file formats (input, actual/expected) and out should come a
triplet of directories. This would make maintenance really easy as
we'd only need to add new strings to a string table. The service would
also handle things like the actual and expected directories, etc.
</p>

<p>
It should fix the following issues:
</p>

<ul class="org-ul">
<li>Adding new engine spec tests is hard</li>
<li>Naming of saved yarn/Dia files is incorrect</li>
</ul>

<p>
Actually we should also look into using the DTL library:
</p>

<ul class="org-ul">
<li><a href="https://github.com/cubicdaiya/dtl">diff template library written by C++</a></li>
</ul>

<p>
<b>Old understanding</b>:
</p>

<p>
The correct solution for test data and test data sets is as follows:
</p>

<ul class="org-ul">
<li>the code generated by dogen in the test data directory is one of
many possible ways of instantiating a model with test data.</li>
<li>there are two types of instantiations: code and data. code is like
dogen <code>test_data</code>; data is XML, text or binary - or any other
supported boost archive; it also includes other external formats
such as dia diagrams.</li>
<li>a model should have a default enum with all the available test data
sets: <code>test_data::sets</code>. If left to its default state it has only one
entry (say <code>dogen</code>). The use is free to declare an enumeration on a
diagram with the name test<sub>data</sub><sub>sets</sub> and add other values to it.</li>
<li>there must be a set of folders under test<sub>data</sub> which match the
enumerators of <code>test_data::sets</code>. Under each folder there must be an
entry point such as <code>ENUMERATOR_generator</code>. Dogen will automatically
ignore these folders via regular expressions.</li>
<li>a factory will be created by dogen which will automatically include
all such <code>ENUMERATOR_generator</code>. It will use static methods on the
generator to determine what sort of capabilities the generator has
(file, code, which formats supported, etc.) and throw if the user
attempts to misuse it.</li>
<li>all models must have a repository. Perhaps we need a stereotype of
<code>repository</code> to identify it. This is what the factory will create.</li>
<li>users will instantiate the factory and call <code>make</code>:</li>
</ul>

<pre class="example">
my_model::test_data::factory f1;
auto r = f1.make(my_model::test_data::sets::dogen);

my_model::test_data::factory f2(expected_dir, actual_dir);
auto r = f2.make(my_model::test_data_sets::some_set,
  my_model::test_data::file_formats::boost_xml, file_locations::expected);
</pre>


<ul class="org-ul">
<li>if the user requires parsing a non-boost serialisation file then it
should be make clear on the enum: <code>std_model, std_model_dia</code>. The
second enumerator will read dia files. It will not support any file
formats. The file must exist on either the expected or actual
directory as per <code>file_locations</code> parameter.</li>
</ul>

<p>
Another topic which is also part of test data is the generation of
data for specific tests. At present we have lots of ad-hoc functions
scattered around different places. They should all live under test
data and be part of a test data set. The test data set should probably
be the spec name.
</p>
</div>
</div>

<div id="outline-container-org0895f79" class="outline-4">
<h4 id="org0895f79"><span class="section-number-4">5.6.169</span> Add support for <code>std::function</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-169">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of <code>std::function</code> so
that I don't have to manually generate code for types that use it.
</p>

</blockquote></div>

<p>
At present its not possible to declare an attribute of type
<code>std::function</code> anywhere in a diagram. It won't really be possible to
do so for entities and values because boost serialisation will always
be a problem. If this was really a requirement, we could look into
serialising functions:
</p>

<ul class="org-ul">
<li><a href="https://groups.google.com/forum/?fromgroups%3D#!topic/boost-list/sHWRPlpPsf4">how to serialize boost::function</a></li>
</ul>

<p>
However we don't seem to need this quite just yet. What we do need is
a way of having attributes in services and that is slightly easier:
</p>

<ul class="org-ul">
<li>the parser needs to be able to understand the function template
syntax (e.g. <code>void(int)</code>). It seems this could be hacked easily
enough into the parser.</li>
<li>Nested qualified names need to be able to remember that in the case
of a function, the first argument is a return type (they also need
to know they represent a function). MC: is this actually necessary?
all we need is to be able to reconstruct this syntax at format time.</li>
<li>we need a <code>void</code> type in the built-ins model. This is a bit more
complicated since this type can't have values, only pointers, and we
don't really support raw pointers at the moment. Adding the type
blindly would open up all sorts of compilation errors.</li>
</ul>

<p>
This should be sufficient for services. At present we have a hack that
allows functions without any template arguments, e.g. <code>std::function</code>,
in services.
</p>

<p>
One possible solution is to support the "portable syntax" as per
<code>boost::function</code>, .e.g. <code>std::function&lt;a, b, c&gt;</code>. This would make it
similar to what we already do for variants. The only other problem is
that we would not be able to support const, by ref etc. Yet another
solution is to have an operation syntax in UML but somehow convert the
operation into a type. For example, we could have a <code>masd::function</code>
stereotype, which is applied to an object that can only have a single
operation. Then you can refer to that as an attribute. The
implementation is dependent on the programming language. This could be
a LAM type. This solves the parsing issues, and gives us strong
metamodel level support for these types.
</p>
</div>
</div>

<div id="outline-container-org720a2b6" class="outline-4">
<h4 id="org720a2b6"><span class="section-number-4">5.6.170</span> Add support for references and pointers to types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-170">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of references and
pointers so that I don't have to manually generate code for types that
use it.
</p>

</blockquote></div>

<p>
At present its not possible to create a type that has a reference to
another type. This should be a case of updating the parser to cope
with references and adding reference to property or nested type
name. This would be a good time to inspect our support for raw
pointers, it probably suffers from exactly the same problem and
requires the same solution.
</p>

<p>
In addition we should also bear in mind moving. Ideally one should be
able to declare moveable attributes and the end result should be a
setter that takes the type by <code>&amp;&amp;</code>. The question then is should we
also move on the getter? Sometimes it may not be a copyable type
(e.g. asio's <code>socket</code>).
</p>

<p>
It seems we can't also cope with <code>const</code> or pointers. To be fair we
only need const for shared pointer for now. On all cases we need to
make the parser more clever:
</p>

<pre class="example">
boost::shared_ptr&lt;const my_type&gt;
std::string&amp;
</pre>


<p>
We should try to create tests for all the cases we consider important
and mark them as ignore until we can find a spirit expert to help out.
</p>

<p>
Actually the right approach is to rely on UMLs facilities for these
such as <code>inout</code> etc. We should not have programming language level
constructs for these. In addition, for raw pointers we could create a
type, e.g. <code>masd::pointer</code> which is used to signify this intention.
</p>
</div>
</div>

<div id="outline-container-orgafe9bb7" class="outline-4">
<h4 id="orgafe9bb7"><span class="section-number-4">5.6.171</span> Add support for immutable attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-171">
<p>
Once we have support for defaults on attributes, we can consider
adding immutable attributes. These are attributes in mutable classes
which have been marked as immutable.
</p>

<p>
Validation:
</p>

<ul class="org-ul">
<li>class must not be immutable (probably a mistake)</li>
<li>attribute must have a default value.</li>
</ul>
</div>
</div>

<div id="outline-container-org8bf0d8a" class="outline-4">
<h4 id="org8bf0d8a"><span class="section-number-4">5.6.172</span> Add support for static attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-172">
<p>
At present we cannot add attributes that are static to objects. This
should be fairly straightforward:
</p>

<ul class="org-ul">
<li>add a "is static" property to attribute</li>
<li>populate it by reading static information from front-end such as
dia's field for "class scope".</li>
<li>update templates to mark property as static.</li>
</ul>

<p>
Open questions:
</p>

<ul class="org-ul">
<li>what do we do for serialisation? Maybe it only makes sense to have
const static properties.</li>
</ul>
</div>
</div>

<div id="outline-container-org471bbcf" class="outline-4">
<h4 id="org471bbcf"><span class="section-number-4">5.6.173</span> Immutable static attributes and inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-173">
<p>
In some cases it may make sense to attach an "attribute" at class
level to all derived classes, and provide a virtual function in the
base class to retrieve it. For example, we could have a "meta-id"
attached to the base class:
</p>

<pre class="example">
virtual std::string base::meta_id() const = 0;
</pre>


<p>
The "meta-id" is populated to reflect the derived class, like so:
</p>

<pre class="example">
std::string derived::meta_id() override {
    static const std::string r("derived");
    return r;
}
</pre>


<p>
This pattern could be supported directly by the code-generator by
having a "meta<sub>attribute</sub>" flag in the base class. The derived class
would then also define this attribute (possibly repeating the
"meta<sub>attribute</sub>" flag for good measure) and supplying the default
value.
</p>
</div>
</div>

<div id="outline-container-orga0947b1" class="outline-4">
<h4 id="orga0947b1"><span class="section-number-4">5.6.174</span> Shared pointers as keys in associative containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-174">
<p>
This is not supported; it would require generating the
hashing/comparison infrastructure for shared pointers. Further, as it
has been pointed out, keys should be immutable; having pointers as
keys opens the doors to all sorts of problems. We need to throw an
error at model building time if an user tries to do this.
</p>
</div>
</div>

<div id="outline-container-orgc49aa18" class="outline-4">
<h4 id="orgc49aa18"><span class="section-number-4">5.6.175</span> Add support for <code>smartref</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-175">
<p>
This seems like an interesting library. Not exactly clear how to use
it, but to support it should be easy: add generated code that
registers user defined types:
</p>

<pre class="example">
class Person
{
public:
   auto first_name() {...}
   auto last_name() {...}
};
REFLECTABLE(first_name);
REFLECTABLE(last_name);
</pre>


<p>
However, to properly use it we probably need support for protected
regions so that we can overload calls manually.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/erikvalkering/smartref">GitHub</a></li>
<li><a href="https://medium.com/@eejv/on-the-origin-of-smartref-proxy-pattern-f6fe53f41286">On the Origin of smartref: Proxy Pattern</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1043cf8" class="outline-4">
<h4 id="org1043cf8"><span class="section-number-4">5.6.176</span> Add support for MetaStuff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-176">
<p>
Interesting serialisation library:
</p>

<ul class="org-ul">
<li><a href="https://github.com/eliasdaler/MetaStuff">https://github.com/eliasdaler/MetaStuff</a>.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://eliasdaler.github.io/meta-stuff/">How my little C++ meta-serialization library works and how I wrote
it</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5420557" class="outline-4">
<h4 id="org5420557"><span class="section-number-4">5.6.177</span> Add support for Franca IDL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-177">
<p>
Franca is an IDL language for which there is an XText definition and a
C++ (spirit) implementation <a href="https://github.com/martinhaefner/franca">here</a>. It may be useful as a gateway for
other IDLs.
</p>
</div>
</div>

<div id="outline-container-org0ae5f5f" class="outline-4">
<h4 id="org0ae5f5f"><span class="section-number-4">5.6.178</span> Add support for D-Bus&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-178">
<p>
<a href="https://en.wikipedia.org/wiki/D-Bus">D-Bus</a> is an RPC mechanism used on Linux.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/dbus-asio/dbus-asio">dbus-asio</a>: DBus C++ implementation based on boost asio. <a href="https://fosdem.org/2019/schedule/event/dbus_asio/">FOSDEM talk</a>.</li>
<li><a href="https://gitlab.freedesktop.org/dbus/dbus">libdbus</a>: original D-Bus C library.</li>
</ul>
</div>
</div>

<div id="outline-container-org8c18373" class="outline-4">
<h4 id="org8c18373"><span class="section-number-4">5.6.179</span> Add support for Asio uring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-179">
<div class="epigraph"><blockquote>
<p>
Asio Uring adapts the io<sub>uring</sub> functionality added in the Linux kernel
5.1 to the model of Boost.Asio with the framework laid for future
adaptation to the model of the Networking TS. This enables native
asynchronous file I/O within the context of Boost.Asio.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/RobertLeahy/AsioUring">AsioUring GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0688f4b" class="outline-4">
<h4 id="org0688f4b"><span class="section-number-4">5.6.180</span> Add support for Microsoft Bond&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-180">
<p>
More of a placeholder - will require further investigation. Seems like
Microsoft has their own Thrift/ProtoBuf-like implementation called
<a href="https://github.com/Microsoft/bond/">Bond</a>. It supports <a href="https://microsoft.github.io/bond/manual/bond_cpp.html">C++</a>. Once could conceive Dogen support for it.
</p>
</div>
</div>

<div id="outline-container-org6b3bd22" class="outline-4">
<h4 id="org6b3bd22"><span class="section-number-4">5.6.181</span> Add support for Aeron&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-181">
<p>
Yet another RPC like framework.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/real-logic/aeron">https://github.com/real-logic/aeron</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge209435" class="outline-4">
<h4 id="orge209435"><span class="section-number-4">5.6.182</span> Consider adding support for Boost.Operators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-182">
<p>
It may or may not make sense to add support for <a href="http://www.boost.org/doc/libs/1_58_0/libs/utility/operators.htm">Boost.Operators</a>. There
is a bit of boilerplate which seems easy to code-generate; however,
the point of adding operators is surely that one needs some
hand-crafted functionality. At any rate, this story keeps track of the
thinking on this topic. Articles:
</p>

<ul class="org-ul">
<li><a href="http://arne-mertz.de/2015/01/operator-overloading-the-basics/">Operator Overloading: The Basics</a></li>
<li><a href="http://arne-mertz.de/2015/01/operator-overloading-common-practice/">Operator Overloading: Common Practice</a></li>
<li><a href="http://arne-mertz.de/2015/02/operator-overloading-introduction-to-boost-operators-part-1/">Operator Overloading  Introduction to Boost.Operators, Part 1</a></li>
<li><a href="http://arne-mertz.de/2015/02/operator-overloading-introduction-to-boost-operators-part-2/">Operator Overloading  Introduction to Boost.Operators, Part 2</a></li>
<li><a href="http://arne-mertz.de/2015/03/operator-overloading-introduction-to-boost-operators-part-3/">Operator Overloading  Introduction to Boost.Operators, Part 3</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5e34fe1" class="outline-4">
<h4 id="org5e34fe1"><span class="section-number-4">5.6.183</span> Support for COM/CORBA&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-6-183">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of COM/CORBA so that I
can create code to interface with legacy systems.
</p>

</blockquote></div>

<p>
We should investigate how hard it is to add support for these IDLs.
</p>
</div>
</div>

<div id="outline-container-org4a84632" class="outline-4">
<h4 id="org4a84632"><span class="section-number-4">5.6.184</span> Support for pretty printing libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-6-184">
<p>
<a href="https://github.com/p-ranav/pprint">pprint</a> is a library for pretty printing of C++ objects. It could be
used as an alternative for our current JSON-based approach to IO. It
appears there are <a href="https://news.ycombinator.com/item?id=19780725">a number of similar libraries</a>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/p-ranav/pprint">pprint</a>: github repo.</li>
<li><a href="https://github.com/tfc/pprintpp">pprintpp</a>: Typesafe Python Style Printf Formatting for C++.</li>
<li><a href="https://github.com/calebzulawski/hippo">hippo</a>: Hierarchical Information Pretty-Printer Objects. More macro
based.</li>
<li><a href="https://github.com/tcbrindle/pretty_print.hpp">pretty<sub>print.hpp</sub></a>: another single-header C++14 library for printing
STL-compatible container types to IO streams.</li>
<li><a href="https://lwn.net/Articles/815265/">Improving pretty-printing in Python</a>: some ideas on the problem but
for python.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf34f249" class="outline-3">
<h3 id="orgf34f249"><span class="section-number-3">5.7</span> Miscellaneous</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Stuff that is not directly related to the problem domain but its
needed by Dogen. Tooling, infrastructure, blog posts, etc. However,
they must still be in keeping with the vision, so not too left field.
</p>
</div>

<div id="outline-container-org69955a7" class="outline-4">
<h4 id="org69955a7"><span class="section-number-4">5.7.1</span> Consider cross-platform building&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
At present we use windows and appveyor for windows builds. This is a
bit painful because we don't have a windows machine. It would be nicer
if we could install clang/llvm cross platform tools, including a
debugger, which could run on wine and build windows packages cross
platform. If we could do the same thing for OSX, then we would only
have to support Linux. This would also mean we could setup vcpkg
builds in docker containers with the cross-platform environment.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://gitlab.gnome.org/GNOME/msitools">GH msitools</a>: set of programs to inspect and build Windows Installer
files.</li>
<li><a href="https://github.com/tpoechtrager/osxcross">GH osxcross</a>: Mac OS X cross toolchain for Linux, FreeBSD, OpenBSD
and Android (Termux)</li>
<li><a href="https://askubuntu.com/questions/1117461/how-do-i-create-a-dmg-file-on-linux-ubuntu-for-macos">SO How do I create a DMG file on linux Ubuntu for MacOS</a></li>
<li><a href="https://stackoverflow.com/questions/286419/how-to-build-a-dmg-mac-os-x-file-on-a-non-mac-platform">SO How to build a dmg Mac OS X file (on a non-Mac platform)?</a></li>
<li><a href="http://www.elstensoftware.com/blog/2013/04/17/scripting-dmg-build-osx-linux/">Scripting DMG builds on OS X from Linux</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga632296" class="outline-4">
<h4 id="orga632296"><span class="section-number-4">5.7.2</span> Log file per transform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-2">
<p>
At present we have a good view of the graph of the chain when tracing
is enabled. We then use the GUIDs to find the details of the
transformation in the log. It would be even easier if somehow it was
possible to have sinks in boost log that are added for each transform
and removed at the end of it. This way we could generate "mini log
files" that contain all of the activity that occurred in that
transform.
</p>

<p>
Boost log seems to be setup for it, we'd just have to manipulate the
logger from within the tracer. One slight problem is that we'd only
want to log from "leaf transforms". This probably means that we need
to make sure that only transform chains can call other transforms.
</p>

<p>
In theory all we'd have to do is to get the tracer to do the hooking
and unhooking for each transform. It should already know about chains
vs transforms.
</p>
</div>
</div>

<div id="outline-container-org4a26671" class="outline-4">
<h4 id="org4a26671"><span class="section-number-4">5.7.3</span> Consider adding pre-commit hooks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-3">
<p>
Its not clear how these work with github but they seem interesting.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/pocc/pre-commit-hooks">pre-commit-hooks</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgee0c4f1" class="outline-4">
<h4 id="orgee0c4f1"><span class="section-number-4">5.7.4</span> Add fuzzing tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-4">
<p>
We need to setup some basic fuzzing tests for model inputs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://nullprogram.com/blog/2019/01/25/">The Day I Fell in Love with Fuzzing</a></li>
</ul>
</div>
</div>

<div id="outline-container-org777f6f7" class="outline-4">
<h4 id="org777f6f7"><span class="section-number-4">5.7.5</span> Updates to debian package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-5">
<p>
There are several problems with the debian package:
</p>

<ul class="org-ul">
<li>shared folder is <code>dogen</code> not <code>masd.dogen</code></li>
<li>no hello world sample; need json and dia versions</li>
<li>package name is <code>dogen-applications</code>, should be masd&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org7d37da6" class="outline-4">
<h4 id="org7d37da6"><span class="section-number-4">5.7.6</span> Add stitch section in manual&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-6">
<p>
We need to document stitch:
</p>

<ul class="org-ul">
<li>formal definition of the language and its limitations;</li>
<li>command line usage of the tool.</li>
<li>describe the t4 grammar, our similarities and differences. See the
stories around using t4 terminology in sprint 64 and 68 (most
important bits copied below).</li>
<li>describe available directives.</li>
<li>note on how we don't support class feature blocks and how we use the
class feature block start marker to mean standard control block
start marker.</li>
</ul>

<p>
Relevant comments from previous stories:
</p>

<p>
We found <a href="https://msdn.microsoft.com/en-us/library/bb126478.aspx">a page</a> documenting the elements of T4. These are:
</p>

<ul class="org-ul">
<li><b>Directives</b>: Text template directives provide general instructions to
the text templating engine about how to generate the transformation
code and the output file.</li>
<li><b>Text blocks</b>: A text block inserts text directly into the output
file. There is no special formatting for text blocks.</li>
<li><b>Control blocks</b>: Control blocks are sections of program code that
are used to transform the templates. Two types:
<ul class="org-ul">
<li><b>Standard control blocks</b>: A standard control block is a section
of program code that generates part of the output file.</li>
<li><b>Expression control blocks</b>: An expression control block evaluates
an expression and converts it to a string.</li>
</ul></li>
</ul>

<p>
Additional definitions we made up because we could not find anything
suitable in documentation:
</p>

<ul class="org-ul">
<li><b>Block</b>: one of: text block, control block or any of its descendants.</li>
<li><b>Statement</b>: either a directive or a control block.</li>
<li><b>Inline statement</b>: statement that starts and ends in one line.</li>
<li><b>Marker</b>: one of &lt;#, &lt;#@, &lt;#=, #&gt;. Mark-up that delimits statements.</li>
<li><b>Start Marker</b>: one of &lt;#, &lt;#@, &lt;#=. Can also be specialised to
"start X marker", e.g. start control block marker is &lt;#, and so on.</li>
<li><b>End Marker</b>: #&gt;. Can also be specialised to "end X marker",
e.g. end directive marker is #&gt;.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb6a79c6" class="outline-4">
<h4 id="orgb6a79c6"><span class="section-number-4">5.7.7</span> Diagrams used in manual should be in docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-7">
<p>
Users should be able to follow the examples in the manual by using a
set of diagrams supplied in the dogen package. However, to ensure
these samples are actually working we need to test them as part of
sanity. This means we need the same diagrams packaged twice.
</p>
</div>
</div>

<div id="outline-container-orgcf53b30" class="outline-4">
<h4 id="orgcf53b30"><span class="section-number-4">5.7.8</span> Tidy-up dogen windows package&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-8">
<p>
There are a few inconsistencies with the package:
</p>

<ul class="org-ul">
<li>dogen components have a strange structure:
"Dogen/runtime/dogen".</li>
<li>we should probably have a top-level umbrella for MASD, under which
dogen installs.</li>
<li>package name is windows amd64. We should use the vcpkg triplets for
simplicity (e.g. x64-windows).</li>
</ul>
</div>
</div>

<div id="outline-container-orgb422cc4" class="outline-4">
<h4 id="orgb422cc4"><span class="section-number-4">5.7.9</span> Add project documentation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-9">
<p>
We should be able to create a simple set of docs following on from the
<a href="https://ned14.github.io/outcome/">outcome project</a>. They seem to be using Hugo.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/foonathan/standardese">https://github.com/foonathan/standardese</a></li>
<li><a href="https://github.com/ned14/outcome/tree/develop/doc/src">https://github.com/ned14/outcome/tree/develop/doc/src</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga24f144" class="outline-4">
<h4 id="orga24f144"><span class="section-number-4">5.7.10</span> Create a <code>ci</code> folder in build&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-10">
<p>
We should use the same approach as nupic for organising the scripts: a
top-level <code>ci</code> folder with folders per CI system. We should also
follow their naming convention for the build scripts which seem to
follow the CI events.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/numenta/nupic.core/tree/master/ci">https://github.com/numenta/nupic.core/tree/master/ci</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc8fe49d" class="outline-4">
<h4 id="orgc8fe49d"><span class="section-number-4">5.7.11</span> Fix issues with bintray windows uploads&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-11">
<p>
At present we are doing a lot of hacks for windows:
</p>

<ul class="org-ul">
<li>hardcoding the path to the package</li>
<li>not uploading on just tags</li>
<li>uploading to the top-level folder instead of the version.</li>
</ul>

<p>
Ideally we want to reuse the Travis BinTray descriptor but AppVeyor
does not support this directly.
</p>
</div>
</div>

<div id="outline-container-org7384b8b" class="outline-4">
<h4 id="org7384b8b"><span class="section-number-4">5.7.12</span> Add support for ODB schema version&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-12">
<p>
ODB has good support for schema migration. We need to make sure Dogen
uses it.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.codesynthesis.com/products/odb/doc/manual.xhtml">C++ Object Persistence with ODB</a>: section "13.1 Object Model Version
and Changelog" and "13.2 Schema Migration"</li>
</ul>
</div>
</div>

<div id="outline-container-org8154916" class="outline-4">
<h4 id="org8154916"><span class="section-number-4">5.7.13</span> Add proper DEB support to bintray&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-13">
<p>
At present we are uploading our Debian package to a "generic" area in
bintray. This has served us well so far but has one shortcoming: we
need to manually update packages every time there is a new release,
requiring change of paths, manual downloads, <code>apt-get remove</code> etc. It
would be much easier to upload the package as a DEB and then use
apt-get to install it. We just need to look into the bintray
descriptors to figure out how to upload it to the correct repository.
</p>
</div>
</div>

<div id="outline-container-org339b566" class="outline-4">
<h4 id="org339b566"><span class="section-number-4">5.7.14</span> Add scripts to sanity check packages&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-7-14">
<p>
Create a set of scripts that validate packages:
</p>

<ul class="org-ul">
<li>install packages on all supported platforms.</li>
<li>sanity check that package installed correctly, e.g. check for a few
key files.</li>
<li>run sanity tests, e.g. create a dogen model and validate the results</li>
<li>run uninstaller and sanity check that files are gone
<ul class="org-ul">
<li>this should actually be a build agent so we can see that deployment
is green. We should create a deployment CMake script that does this.</li>
</ul></li>
</ul>

<p>
We had some initial support for this in commit ba54859.
</p>
</div>
</div>

<div id="outline-container-orgf229fdb" class="outline-4">
<h4 id="orgf229fdb"><span class="section-number-4">5.7.15</span> Consider adding profiling support via build type&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-15">
<p>
At present we used a dogen specific variable for profiling:
<code>WITH_PROFILING</code>. However, we could extend the cmake build type
mechanism with a <code>Profiling</code> build type.
</p>

<p>
See:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Milkyway-at-home/milkywayathome_client/blob/master/cmake_modules/Profiling.cmake">milkywayathome<sub>client</sub>'s profiling for CMake</a></li>
</ul>
</div>
</div>

<div id="outline-container-org03f2d73" class="outline-4">
<h4 id="org03f2d73"><span class="section-number-4">5.7.16</span> Add support for coverity analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-16">
<p>
We've created a project and added the badge but we have not yet setup
travis for this.
</p>

<ul class="org-ul">
<li><a href="https://scan.coverity.com/projects/domaindrivenconsulting-dogen/builds/new?tab%3Dtravis_ci">Automate Analysis with Travis CI</a></li>
<li><a href="https://github.com/d-led/picojson_serializer/blob/master/.travis.yml">example .travis.yml</a></li>
</ul>

<p>
We should upload a build whenever we tag a release.
</p>

<p>
Badge:
</p>

<pre class="example">
[![Coverity](https://img.shields.io/coverity/scan/16865.svg)](https://scan.coverity.com/projects/masd-project-dogen)
</pre>


<p>
Patch:
</p>

<pre class="example" id="orgbbc483f">
+env:
+  global:
+    # COVERITY_SCAN_TOKEN
+    secure: "VwgaUWxbt+sGiYNlBWVOcAQOD6BNKYi2+T4Sco0FBddAClDRjOMHBEA4C2DUsK8dbKcihT+YPlz2CnAw/nIn3mn5cVy3Tf0X8ber06nRXMfKTOU84raX8bKNUCaU9tkiqdTeNLwchQutOk5Bgvbt5nRDUwEEOaCexh44vAIymzE="
+
 matrix:
   include:
     #
@@ -62,6 +67,32 @@ addons:
     sources:
       - ubuntu-toolchain-r-test

+addons:
+  coverity_scan:
+
+    # GitHub project metadata
+    # ** specific to your project **
+    project:
+      name: my_github/my_project
+      version: 1.0
+      description: My Project
+
+    # Where email notification of build analysis results will be sent
+    notification_email: marco.craveiro@gmail.com
+
+    # Commands to prepare for build_command
+    # ** likely specific to your build **
+    build_command_prepend: ./configure
+
+    # The command that will be added as an argument to "cov-build" to compile your project for analysis,
+    # ** likely specific to your build **
+    build_command: make
+
+    # Pattern to match selecting branches that will run analysis. We recommend leaving this set to 'coverity_scan'.
+    # Take care in resource usage, and consider the build frequency allowances per
+    #   https://scan.coverity.com/faq#frequency
+    branch_pattern: coverity_scan
+
 install:
   - export SCRIPTS_DIR=${TRAVIS_BUILD_DIR}/build/scripts
   - source ${SCRIPTS_DIR}/travis.install.${TRAVIS_OS_NAME}.sh
@@ -106,6 +137,25 @@ notifications:
     on_success: always
     on_failure: always

+
+
+env:
+  global:
+
+   - COVERITY_SCAN_BRANCH_PATTERN="master"
+   - COVERITY_SCAN_NOTIFICATION_EMAIL="marco.craveiro@gmail.com"
+   - COVERITY_SCAN_BUILD_COMMAND_PREPEND="mkdir -p coverity-build &amp;&amp; cd coverity-build &amp;&amp; cmake .. &amp;&amp; cd .."
+   - COVERITY_SCAN_BUILD_COMMAND="make -C coverity-build"
+   - COVERITY_SCAN_PROJECT_NAME="$TRAVIS_REPO_SLUG"
+
+
+before_script:
+    - mkdir -p coverity-build &amp;&amp; cd coverity-build &amp;&amp; cmake .. &amp;&amp; cd ..
+    - if [[ "x${CC}" = "xclang" ]] ; then curl -s 'https://scan.coverity.com/scripts/travisci_build_coverity_scan.sh' | bash || true ; fi
+
+
+
+
</pre>
</div>
</div>

<div id="outline-container-org5957f60" class="outline-4">
<h4 id="org5957f60"><span class="section-number-4">5.7.17</span> Link against boost dynamic libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-17">
<p>
At present we are statically linking against Boost just to make our
life easier. This was done mainly to fix the problems we had with
Travis red builds but had the side effect of fixing our Debian
packages. However, as soon as boost 1.60 is available on Travis we
probably should go back to dynamic linking. Removed code:
</p>

<pre class="example">
# elseif (UNIX)
#     if (library_path MATCHES "boost")
#         set(version "${Boost_MAJOR_VERSION}")
#         set(version "${version}.${Boost_MINOR_VERSION}")
#         set(version "${version}.${Boost_SUBMINOR_VERSION}")

#         get_filename_component(library_name ${library_path} NAME_WE)
#         string(REGEX REPLACE "_" "-" library_name "${library_name}")

#         # FIXME: boost 1.55 is not the default in unstable yet.
#         # set(library_name "${library_name}-dev")
#         set(library_name "${library_name}${Boost_MAJOR_VERSION}.")
#         set(library_name "${library_name}${Boost_MINOR_VERSION}-dev")
#         if ("${boost_deps}" STREQUAL "")
#             set(boost_deps "${library_name} (&gt;= ${version})")
#         else()
#             set(boost_deps "${boost_deps}, ${library_name} (&gt;= ${version})")
#         endif()
#     endif()
</pre>


<p>
See also main CMakeLists.txt around <code>6b837334c3247bee2f6be8099cd5288a284fa36c</code>.
</p>

<p>
Or is the best practice that the user should choose how to link
against boost in the same way it chooses to generate static or dynamic
libraries internally for Dogen? This seems like a better approach; we
could just add parameters to our shell scripts that build statically
for the build machine.
</p>
</div>
</div>

<div id="outline-container-org3f88c81" class="outline-4">
<h4 id="org3f88c81"><span class="section-number-4">5.7.18</span> Enable doxygen warnings for all undocumented code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-18">
<p>
At present doxygen only warns about undocumented parameters when a
function already has documented parameters. We should consider
enabling warnings for all undocumented code. We also need to figure
out how to mark code as ignored (for example serialisation helpers,
etc won't require documentation).
</p>
</div>
</div>

<div id="outline-container-orge6da007" class="outline-4">
<h4 id="orge6da007"><span class="section-number-4">5.7.19</span> Self-contained build files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-19">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like to build models without having
to add any code so that I use dogen without needing to learn lots
about build systems.
</p>

</blockquote></div>

<p>
It would be nice to be able to generate a complete application from a
given model, or a library. At present there is an expectation that the
user will slot in the generated CMake files into a larger, more
comprehensive CMake build. All we need is:
</p>

<ul class="org-ul">
<li>some kind of binary type: e.g. executable or library. we should have
this anyway. meta data at the model level could be used to convey
this.</li>
<li>if executable, we should automatically ignore a main.cpp in the
source directory.</li>
<li>generate a stand-alone CMake template.</li>
</ul>

<p>
The idea is that with this the user could immediately generate a
binary without any further configuration required.
</p>
</div>
</div>

<div id="outline-container-org525a915" class="outline-4">
<h4 id="org525a915"><span class="section-number-4">5.7.20</span> Remove calls to unix utilities directly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-20">
<p>
We have a couple of cases where we are calling UNIX utilities when
there are equivalent CMake calls. For example
<code>test_data/CMakeLists.txt</code>:
</p>

<pre class="example">
set(target_name "rebase_${model_name}")
if(EXISTS "${git_expected}/")
    add_custom_target(${target_name}
        COMMAND rm -rf ${expected}/*
        COMMAND cp ${actual}/* ${expected}
        COMMAND cp ${actual}/* ${git_expected}/
        WORKING_DIRECTORY ${stage_bin_dir})
</pre>


<p>
These can be replaced with:
</p>

<pre class="example">
file(REMOVE_RECURSE ${stage_test_data_dir}/${dir}/expected)
file(COPY ${curdir}/${dir} DESTINATION ${stage_dir}/test_data)
file(MAKE_DIRECTORY ${stage_test_data_dir}/${dir}/actual)
</pre>


<p>
etc.
</p>
</div>
</div>

<div id="outline-container-org61325df" class="outline-4">
<h4 id="org61325df"><span class="section-number-4">5.7.21</span> Detect the presence of the diff command&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-21">
<p>
The diff targets is dependent on the presence of the diff command, but
we are not checking to see if it exists:
</p>

<pre class="example">
set(target_name "diff_${model_name}")
add_custom_target(${target_name}
    COMMAND diff -r -u ${expected} ${actual}
    WORKING_DIRECTORY ${stage_bin_dir})
add_dependencies(diff_dataset ${target_name})
</pre>


<p>
We need to detect it and only add this targets if diff has been
found. We probably should look for a <code>FindDiff.cmake</code> script.
</p>
</div>
</div>

<div id="outline-container-org3f09d20" class="outline-4">
<h4 id="org3f09d20"><span class="section-number-4">5.7.22</span> Installable package names should follow a well-known convention&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-22">
<p>
We need to make sure our package names are consistent with the
platform conventions.
</p>

<ul class="org-ul">
<li><a href="http://pastebin.com/TR17TUy9">Example of platform IFs</a></li>
<li><a href="http://libdivsufsort.googlecode.com/svn-history/r6/trunk/CMakeModules/ProjectCPack.cmake">Example CPack</a></li>
<li><a href="http://cmake.3232098.n2.nabble.com/Automatically-add-a-revision-number-to-the-CPack-installer-name-td7356239.htmlhttp://cmake.3232098.n2.nabble.com/Automatically-add-a-revision-number-to-the-CPack-installer-name-td7356239.html">Automatically add a revision number to the CPack installer name</a></li>
<li><a href="http://www.cmake.org/Wiki/CMake:CPackConfiguration">CPack Configuration</a></li>
</ul>

<p>
There are some known limitations in package naming:
</p>

<ul class="org-ul">
<li><a href="http://public.kitware.com/Bug/view.php?id%3D12997">0012997: Provide a more flexible way to name package produced by CPack</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6ff16dd" class="outline-4">
<h4 id="org6ff16dd"><span class="section-number-4">5.7.23</span> Allow user to choose whether to build shared or static libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-23">
<p>
We removed the hard-coding, but the code does not compile due to
problems linking Boost Log:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Microsoft/vcpkg/issues/6148">Errors building shared library due to Boost Log and PIC</a></li>
</ul>

<p>
<b>Previous understanding</b>
</p>

<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to generate models as shared objects
so that I don't have to statically link models all the time.
</p>

</blockquote></div>

<p>
With the increase in tests build speeds have started to suffer,
especially on low hardware. One potential way to mitigate this is to
avoid unnecessary linking. The problem we have at present is that
every time something changes in any model we have to relink all the
binaries that use that model as it is consumed as a static library. If
all the static libraries were converted to shared objects this would
no longer be necessary.
</p>

<p>
We probably need a dogen command line option to determine what to
build so that users are not forced to always build static / shared
libraries. We should make sure one of the tests is using a static
library to make sure this scenario doesn't get borked.
</p>

<p>
Actually we need to figure out how to pass this as a parameter into
CMake to let the user configure how the libraries are generated
(static or dynamic). Look for a best practices presentation on CMake
that talks about this.
</p>

<p>
Merged Stories:
</p>

<p>
<b>Build static and dynamic libraries</b>
</p>

<p>
At present we are always building static libraries from
Dogen. However, CMake supports both.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/2152077/is-it-possible-to-get-cmake-to-build-both-a-static-and-shared-version-of-the-sam">Is it possible to get CMake to build both a static and shared
version of the same library?</a></li>
<li><a href="https://github.com/friendlyanon/cxx-static-shared-example">GH cxx-static-shared-example</a>: "CMake Example: support building as
either shared or static".</li>
</ul>
</div>
</div>

<div id="outline-container-org86378c9" class="outline-4">
<h4 id="org86378c9"><span class="section-number-4">5.7.24</span> Migrate from Boost Test to Catch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-24">
<p>
The <a href="https://github.com/philsquared/Catch">Catch</a> testing framework appears to be very nice:
</p>

<p>
<a href="https://vimeo.com/131632252">Testdriven C++ with Catch - Phil Nash</a>
</p>

<p>
We should look into moving from Boost test to Catch. We should also
take the opportunity to extend catch with a few <a href="https://github.com/philsquared/Catch/tree/master/include/reporters">reporters</a>:
</p>

<ul class="org-ul">
<li>boost log reporter such that all the logging from unit testing goes
into the log file and the log file is setup automatically for each
scenario.</li>
<li>"emacs" reporter such that we get compilation error like
messages. This may already be in Catch.</li>
<li>CDash reporter so that we don't have to do all of the CMake magic in
order to see the unit tests in CDash</li>
</ul>

<p>
Merged Stories:
</p>

<p>
We should check the Martin Fowler article on <a href="http://martinfowler.com/bliki/GivenWhenThen.html">Given-When-Then</a> as a way
of specifying unit tests, to see if it would make our tests
clearer. We are already following some kind of Given and Then, but we
should consider making it explicit.
</p>

<p>
The best approach may be to move all unit tests to <a href="https://github.com/philsquared/Catch">Catch</a>, since it
natively supports GWT.
</p>
</div>
</div>

<div id="outline-container-org8f42521" class="outline-4">
<h4 id="org8f42521"><span class="section-number-4">5.7.25</span> Add a GitHub page for Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-25">
<p>
We should be able to create a simple project page for Dogen by using
the automatic project generator:
</p>

<p>
<a href="https://pages.github.com/">https://pages.github.com/</a>
</p>

<p>
However, to do so we probably should convert the README into MarkDown
first. It is used to generate the project page's contents.
</p>
</div>
</div>

<div id="outline-container-org4f04f7c" class="outline-4">
<h4 id="org4f04f7c"><span class="section-number-4">5.7.26</span> Add Doxygen docs to GitHub page&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-26">
<p>
Once we setup the Dogen page, we should automatically upload the
Doxygen documentation there. This should be done from Travis:
</p>

<ul class="org-ul">
<li>setup a Doxygen build in Travis that builds the docs into staging,
then changes branch into <code>gh-pages</code>, then <code>rm -rf</code> the previous docs
and copies across the new docs then commits and pushes.</li>
<li>we need to make sure the docs are not very large.</li>
</ul>

<p>
Example from RapidJSON available <a href="https://github.com/miloyip/rapidjson/blob/master/travis-doxygen.sh">here</a>.
</p>

<p>
This can be done by adding a build to the matrix with a
<code>DOCUMENTATION</code> env variable. When this is on, the travis build builds
and deploys documentation. We should only do this when tagging.
</p>

<p>
Merged Stories:
</p>

<p>
<b>Add doxygen build in travis using GitHub pages</b>
</p>

<p>
It seems is pretty straightforward to add a doxygen build to travis:
</p>

<ul class="org-ul">
<li><a href="http://blog.gockelhut.com/2014/09/automatic-documentation-publishing-with.html">Automatic Documentation Publishing with GitHub and TravisCI</a></li>
</ul>

<p>
See also <a href="https://github.com/tgockel/nginxconfig/blob/master/config/publish-doxygen">this script</a>.
</p>
</div>
</div>

<div id="outline-container-orgfe5af14" class="outline-4">
<h4 id="orgfe5af14"><span class="section-number-4">5.7.27</span> Add vagrant and docker support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-27">
<p>
It would be nice to provide vagrant and docker support to dogen in
terms of development. The idea is that you can <code>git clone</code> the repo
and then <code>vagrant up</code> it and you would be ready to start coding. This
would make drive-by patches much easier.
</p>
</div>
</div>

<div id="outline-container-org02424fe" class="outline-4">
<h4 id="org02424fe"><span class="section-number-4">5.7.28</span> Use clang format to format the code base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-28">
<p>
It seems clang-format is being used by quite a lot of people to save
time with the formatting of the code. More info:
</p>

<p>
<a href="http://clang.llvm.org/docs/ClangFormat.html">http://clang.llvm.org/docs/ClangFormat.html</a>
</p>

<p>
Emacs support:
</p>

<p>
<a href="https://llvm.org/svn/llvm-project/cfe/trunk/tools/clang-format/clang-format.el">https://llvm.org/svn/llvm-project/cfe/trunk/tools/clang-format/clang-format.el</a>
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/STEllAR-GROUP/hpx/blob/master/.clang-format">HPX clang format</a></li>
<li><a href="https://engineering.mongodb.com/post/succeeding-with-clangformat-part-1-pitfalls-and-planning">Succeeding With ClangFormat, Part 1: Pitfalls And Planning</a></li>
<li><a href="https://github.com/basiliscos/cpp-rotor/blob/master/.clang-format">example: clang format in rotor</a></li>
<li><a href="https://github.com/jbapple-cloudera/clang-format-infer">clang-format-infer GH</a></li>
<li><a href="https://zed0.co.uk/clang-format-configurator/">clang-format-configurator</a></li>
<li><a href="http://clangformat.com/">http://clangformat.com/</a></li>
<li><a href="https://github.com/johnmcfarlane/unformat">Unformat</a>: Python3 utility to generate a .clang-format file from
example code-base.</li>
</ul>
</div>
</div>

<div id="outline-container-org5ca7e8c" class="outline-4">
<h4 id="org5ca7e8c"><span class="section-number-4">5.7.29</span> Consider adding an emblem for clang's analysis checks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-29">
<p>
NeoVim appears to have emblems for waffle as well as clang's analysis
checks:
</p>

<p>
<a href="https://github.com/neovim/neovim">https://github.com/neovim/neovim</a>
</p>
</div>
</div>

<div id="outline-container-org11b9b66" class="outline-4">
<h4 id="org11b9b66"><span class="section-number-4">5.7.30</span> Consider adding nuget support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-30">
<p>
Seems like AppVeyor supports deployment into nugget. Example:
</p>

<p>
<a href="http://www.nuget.org/packages/RxCpp/">http://www.nuget.org/packages/RxCpp/</a>
</p>

<p>
It also comes with a couple of useful emblems:
</p>

<p>
<a href="https://github.com/Reactive-Extensions/RxCpp">https://github.com/Reactive-Extensions/RxCpp</a>
</p>

<p>
We should push both the C++ libraries as well as the dogen binary.
</p>

<p>
Merged stories:
</p>

<p>
<b>Add nuget support to bintray</b>
</p>

<p>
It would be nice to add a nuget "repo" (if that is the right term) to
bintray, so that users can install Dogen from nuget. It should support
MSIs - but if it doesn't we may need to manually package Dogen as a
<code>nupkg</code>. This is not too difficult: we need the descriptor and some
basic shell scripts.
</p>
</div>
</div>

<div id="outline-container-org7e2c049" class="outline-4">
<h4 id="org7e2c049"><span class="section-number-4">5.7.31</span> Consider hosting documentation in read the docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-31">
<p>
We should consider hosting the documentation here:
</p>

<ul class="org-ul">
<li><a href="https://readthedocs.org/">https://readthedocs.org/</a></li>
</ul>

<p>
This probably means we need to move to Mark Down.
</p>
</div>
</div>

<div id="outline-container-org5ae7aee" class="outline-4">
<h4 id="org5ae7aee"><span class="section-number-4">5.7.32</span> Consider adding support for clang-tidy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-32">
<p>
As <a href="http://clang.llvm.org/extra/clang-tidy/">per docs</a>:
</p>

<div class="epigraph"><blockquote>
<p>
clang-tidy is a clang-based C++ linter tool. Its purpose is to
provide an extensible framework for diagnosing and fixing typical
programming errors, like style violations, interface misuse, or bugs
that can be deduced via static analysis. clang-tidy is modular and
provides a convenient interface for writing new checks.
</p>

</blockquote></div>

<p>
As with clang-format, we should create a meta-model element to
generate this file.
</p>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="https://github.com/polysquare/clang-tidy-target-cmake">clang-tidy-target-cmake</a></li>
<li><a href="https://www.kdab.com/clang-tidy-part-1-modernize-source-code-using-c11c14/?utm_source%3DMaster%2520List%252006-16&amp;utm_campaign%3Dd11fea20e3-EMAIL_CAMPAIGN_2017_03_23&amp;utm_medium%3Demail&amp;utm_term%3D0_bdde4cdc11-d11fea20e3-101553725&amp;goal%3D0_bdde4cdc11-d11fea20e3-101553725">Clang-Tidy, part 1: Modernize your source code using C++11/C++14</a></li>
<li><a href="https://github.com/STEllAR-GROUP/hpx/blob/master/.clang-tidy">hpx clang tidy file</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5f2fd7c" class="outline-4">
<h4 id="org5f2fd7c"><span class="section-number-4">5.7.33</span> Add support for the <code>scan-build</code> static analyser&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-33">
<p>
<code>scan-build</code> is a command line utility that enables a user to run the
static analyzer over their codebase as part of performing a regular
build.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://clang-analyzer.llvm.org/scan-build.html">scan-build</a> project page</li>
</ul>
</div>
</div>

<div id="outline-container-org216187a" class="outline-4">
<h4 id="org216187a"><span class="section-number-4">5.7.34</span> Add support for iwyu&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-34">
<p>
There is a clang based tool that checks if which includes are actually
used by the translation unit. We should have a build for this that
breaks whenever one includes something which is not required.
</p>

<ul class="org-ul">
<li><a href="https://include-what-you-use.org/">include-what-you-use</a></li>
<li><a href="https://github.com/include-what-you-use/include-what-you-use">iwyu project page</a></li>
<li><a href="http://mpd.jinr.ru/svn/mpdroot/trunk/cmake/modules/FindIWYU.cmake">FindIWYU.cmake</a></li>
<li><a href="https://github.com/christophgysin/addp/blob/master/cmake/iwyu.cmake">iwyu.cmake</a></li>
<li><a href="https://github.com/clangd/clangd/issues/79">IWYU: Unused headers/missing includes #79</a></li>
</ul>

<p>
build.linux:
</p>

<pre class="example">
cmake_defines="${cmake_defines} -DCMAKE_CXX_INCLUDE_WHAT_YOU_USE=/path/to/include-what-you-use/build/include-what-you-use"
</pre>


<p>
Patches:
</p>

<pre class="example">
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7489d14..863162f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -161,7 +161,7 @@ target_link_libraries(include-what-you-use
   LLVMObject # BitReader, Core, Support
   LLVMBitReader # Core, Support
   LLVMCore # BinaryFormat, Support
- LLVMBinaryFormat # Support
- # LLVMBinaryFormat # Support
  LLVMSupport # Demangle
  LLVMDemangle
  )
diff --git a/iwyu_include_picker.cc b/iwyu_include_picker.cc
index 840057f..232a5c6 100644
--- a/iwyu_include_picker.cc
+++ b/iwyu_include_picker.cc
@@ -832,7 +832,7 @@ void MakeNodeTransitive(IncludePicker::IncludeMap* filename_map,
     // in /internal/.  We could CHECK-fail in such a case, but it's
     // probably better to just keep going.
     if (StartsWith(key, "\"third_party/") ||
-        key.find("internal/") != string::npos) {
+        key.find("boost/") != string::npos) {
       VERRS(4) &lt;&lt; "Ignoring a cyclical mapping involving " &lt;&lt; key &lt;&lt; "\n";
       return;
     }
</pre>
</div>
</div>

<div id="outline-container-org9b739c3" class="outline-4">
<h4 id="org9b739c3"><span class="section-number-4">5.7.35</span> Add support for clang sanitizers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-35">
<p>
This seems like another interest dynamic analysis tool:
</p>

<ul class="org-ul">
<li><a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer#Introduction">Address Sanitizer</a></li>
<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a></li>
<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a></li>
<li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UndefinedBehaviorSanitizer</a></li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.reddit.com/r/cpp/comments/jzky8o/what_linters_do_you_recommend/">What linters do you recommend?</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgaa7c42a" class="outline-4">
<h4 id="orgaa7c42a"><span class="section-number-4">5.7.36</span> Add support for CPPCheck&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-36">
<p>
Seems like CPPCheck has a different take on dynamic analysis when
compared to Valgrind. We should look into how hard it is to integrate
it with CTest, Travis, etc.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://cmake.3232098.n2.nabble.com/Static-code-analysis-with-CDash-td6079787.html">CMake and CPPCheck</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbab3ab4" class="outline-4">
<h4 id="orgbab3ab4"><span class="section-number-4">5.7.37</span> Create a demo of installing dogen and generating hello world&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-37">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want basic instructions on using the
program so that I don't have to figure it all out by myself.
</p>

</blockquote></div>

<p>
We need to start creating a series of quick videos demoing dogen. The
script for the first video of the series is as follows:
</p>

<ul class="org-ul">
<li>download packages from GitHub and install them.</li>
<li>obtain the hello world model from git.</li>
<li>generate the hello world model.</li>
<li>create a hello world main with make files and compile it.</li>
<li>give a quick overview of the available facilities.</li>
<li>update hello world to latest diagram version, with right colour
theme.</li>
</ul>
</div>
</div>

<div id="outline-container-org75d9924" class="outline-4">
<h4 id="org75d9924"><span class="section-number-4">5.7.38</span> Mine MongoDB Smasher for test data ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-38">
<p>
There is a project to generate large data sets for MongoDB:
</p>

<ul class="org-ul">
<li><a href="https://github.com/duckie/mongo_smasher">mongo<sub>smasher</sub></a></li>
</ul>

<p>
We should have a look at their feature set and see if any of the
features make sense for dogen. It would be great to have a generalised
"service smasher" based on a service model.
</p>
</div>
</div>

<div id="outline-container-org921ec8d" class="outline-4">
<h4 id="org921ec8d"><span class="section-number-4">5.7.39</span> Write blog post on reflexive programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-39">
<p>
Basic idea is that domain expertise tightens the agile circle,
allowing for much faster progress. Check Soros definition of
reflexive.
</p>
</div>
</div>

<div id="outline-container-orgacbeaa7" class="outline-4">
<h4 id="orgacbeaa7"><span class="section-number-4">5.7.40</span> Read A Concept Design for the STL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-7-40">
<p>
It seems this paper has a lot of useful information for meta-modeling:
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">A Concept Design for the STL</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb267b2d" class="outline-3">
<h3 id="orgb267b2d"><span class="section-number-3">5.8</span> Visionary</h3>
<div class="outline-text-3" id="text-5-8">
<p>
These stories are far in the future or just plain crazy: visionary
work and random ideas. They are require fundamental rethinking of the
core, or are not obviously related to dogen's current vision.
</p>
</div>

<div id="outline-container-org9fb57f4" class="outline-4">
<h4 id="org9fb57f4"><span class="section-number-4">5.8.1</span> Investigate integrating HTM with dogen</h4>
<div class="outline-text-4" id="text-5-8-1">
<p>
HTM is numenta's
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/htm-community/htm.core">htm.core GH</a>: "This is a Community Fork of the nupic.core C++
repository, with Python bindings. This implements the theory as
described in Numenta's BAMI."</li>
</ul>
</div>
</div>

<div id="outline-container-orgf5edf01" class="outline-4">
<h4 id="orgf5edf01"><span class="section-number-4">5.8.2</span> Add support for digests</h4>
<div class="outline-text-4" id="text-5-8-2">
<div class="epigraph"><blockquote>
<p>
Experimental C++11 header-only message digest library. Derived from
cppcrypto in an attempt to devise a more modern yet flexible and
universal C++ API for cryptographic hash functions.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/kerukuro/digestpp">digestpp GH</a></li>
<li><a href="https://numenta.com/resources/biological-and-machine-intelligence/">Biological and Machine Intelligence (BAMI)</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgeda3e11" class="outline-4">
<h4 id="orgeda3e11"><span class="section-number-4">5.8.3</span> Consider adding support for scheduling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-3">
<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/PerMalmberg/libcron">libcron GH</a>: "A C++ scheduling library using cron formatting."</li>
</ul>
</div>
</div>

<div id="outline-container-org5f7d454" class="outline-4">
<h4 id="org5f7d454"><span class="section-number-4">5.8.4</span> Consider adding support for <code>cpp-equiv</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-4">
<div class="epigraph"><blockquote>
<p>
Creating equivalence relations with indexes as elements, merging
elements and testing for equivalence. Also supports adding and
removing elements from existing equivalence relations, comparing
fine-ness, creating all equivalence relations of a given size, and
other auxilary functions/methods.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Ahajha/cpp-equiv">cpp-equiv GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8a8a11e" class="outline-4">
<h4 id="org8a8a11e"><span class="section-number-4">5.8.5</span> Consider adding support for trees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-5">
<p>
We often require a tree datastructure. There must be c++ libraries
implementing these that we can use.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/gvinciguerra/PGM-index">PGM-index GH</a>: "The Piecewise Geometric Model index (PGM-index) is a
data structure that enables fast lookup, predecessor, range searches
and updates in arrays of billions of items using orders of magnitude
less space than traditional indexes while providing the same
worst-case query time guarantees."</li>
<li><a href="https://github.com/Kronuz/cpp-btree">C++ B-tree GH</a>: "Code in this repository is based on Google's B-tree
implementation. C++ B-tree is a template library that implements
ordered in-memory containers based on a B-tree data structure."</li>
</ul>
</div>
</div>

<div id="outline-container-org0a657d1" class="outline-4">
<h4 id="org0a657d1"><span class="section-number-4">5.8.6</span> Consider adding support for <code>libvineyard</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-6">
<div class="epigraph"><blockquote>
<p>
Vineyard is an in-memory immutable data manager that provides
out-of-box high-level abstraction and zero-copy in-memory sharing for
distributed data in big data tasks, such as numerical computing,
machine learning, and graph analytics.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/alibaba/libvineyard">libvineyard GH</a></li>
<li><a href="https://github.com/apache/arrow/blob/master/cpp/apidoc/tutorials/plasma.md">Using the Plasma In-Memory Object Store from C++</a>: "Apache Arrow
offers the ability to share your data structures among multiple
processes simultaneously through Plasma, an in-memory object store."</li>
</ul>
</div>
</div>

<div id="outline-container-org9d31b60" class="outline-4">
<h4 id="org9d31b60"><span class="section-number-4">5.8.7</span> org-block extras&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-7">
<p>
See if we can mine this org documentation for ideas that can be
applied to Dogen:
</p>

<ul class="org-ul">
<li><a href="https://alhassy.github.io/org-special-block-extras/#Judgements-Inference-rules-and-proof-trees">org-special-block-extras</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgfede444" class="outline-4">
<h4 id="orgfede444"><span class="section-number-4">5.8.8</span> Investigate <code>ganja.js</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-8">
<p>
It is not entirely clear what exactly this library does, but it is
related to code generation, so it may come under dogen's umbrella:
</p>

<div class="epigraph"><blockquote>
<p>
Technically, ganja.js is a code generator producing classes that
reificate algebraic literals and expressions by using reflection, a
built-in tokenizer and a simple AST translator to rewrite functions
containing algebraic constructs to their procedural counterparts.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/enkimute/ganja.js">GH project</a></li>
<li><a href="https://news.ycombinator.com/item?id=25471046">HN discussion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6a52d7a" class="outline-4">
<h4 id="org6a52d7a"><span class="section-number-4">5.8.9</span> Investigate adding support for unity builds&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-9">
<p>
Now that CMake has unity builds support, we should try building dogen
this way and see if its faster. However, we need to first remove all
of the static state we have in translation units at present:
</p>

<ul class="org-ul">
<li>loggers</li>
<li>strings with error messages, etc.</li>
</ul>

<p>
These should become class state. There is also the issue with private
classes defined in the cpp; we need to ensure these have unique names.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://onqtam.com/programming/2018-07-07-unity-builds/">A guide to unity builds</a></li>
<li><a href="https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake">Precompiled Headers and Unity (Jumbo) Builds in upcoming CMake</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga6dbfc5" class="outline-4">
<h4 id="orga6dbfc5"><span class="section-number-4">5.8.10</span> Consider adding support for replxx&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-10">
<div class="epigraph"><blockquote>
<p>
A small, portable GNU readline replacement for Linux, Windows and
MacOS which is capable of handling UTF-8 characters. Unlike GNU
readline, which is GPL, this library uses a BSD license and can be
used in any kind of program.
</p>

</blockquote></div>

<p>
It would be nice if Dogen could generate code to integrate with
<code>replxx</code>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/AmokHuginnsson/replxx">GH replxx</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge8ea42e" class="outline-4">
<h4 id="orge8ea42e"><span class="section-number-4">5.8.11</span> Consider adding support for rocksdb&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-11">
<div class="epigraph"><blockquote>
<p>
This code is a library that forms the core building block for a fast
key-value server, especially suited for storing data on flash
drives. It has a Log-Structured-Merge-Database (LSM) design with
flexible tradeoffs between Write-Amplification-Factor (WAF),
Read-Amplification-Factor (RAF) and Space-Amplification-Factor
(SAF). It has multi-threaded compactions, making it especially
suitable for storing multiple terabytes of data in a single database.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/facebook/rocksdb">GH rocksdb</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga1d65d5" class="outline-4">
<h4 id="orga1d65d5"><span class="section-number-4">5.8.12</span> Consider adding support for typesense&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-12">
<div class="epigraph"><blockquote>
<p>
Typesense is a fast, typo-tolerant search engine for building
delightful search experiences.
</p>

</blockquote></div>

<p>
It would be nice if dogen could generate code to integrate with
typesense - whatever that means precisely, upload documents into the
search engine? Serialise to a format compatible?
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/typesense/typesense">GH typesense</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/OpenSearch">OpenSearch</a></li>
<li><a href="https://github.com/phaistos-networks/Trinity">GH Trinity</a>: "Trinity is a modern C++ information-retrieval library
for building queries, indexing documents and other content, running
queries and scoring documents matching them."</li>
</ul>
</div>
</div>

<div id="outline-container-orgdcb59af" class="outline-4">
<h4 id="orgdcb59af"><span class="section-number-4">5.8.13</span> Consider adding support for snowflake&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-13">
<div class="epigraph"><blockquote>
<p>
In certain situations you need a low-latency, distributed,
uncoordinated, (roughly) time ordered, compact and highly available Id
generation system. This project was inspired by Twitter's Snowflake
project which has been retired.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Shenggan/SnowFlake">GH SnowFlake</a></li>
<li><a href="https://github.com/sniper00/snowflake-cpp">GH snowflake-cpp</a></li>
<li><a href="https://developer.twitter.com/en/docs/twitter-ids">twitter ids</a></li>
<li><a href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html">Announcing Snowflake</a></li>
<li><a href="https://medium.com/ingeniouslysimple/why-did-we-shift-away-from-database-generated-ids-7e0e54a49bb3">Why Did We Shift Away From Database-Generated Ids?</a></li>
<li><a href="https://github.com/RobThree/IdGen">GH IdGen</a> (C#)</li>
<li><a href="https://github.com/KMakowsky/CppShortID">CppShortID</a></li>
<li><a href="https://kvz.io/create-short-ids-with-php-like-youtube-or-tinyurl.html">Create Youtube-Like IDs With PHP/Python/Javascript/Java/SQL</a></li>
<li><a href="https://github.com/turbo/pg-shortkey">pg-shortkey</a></li>
<li><a href="https://www.2ndquadrant.com/en/blog/sequential-uuid-generators/">Sequential UUID Generators</a></li>
<li><a href="https://hashids.org/">hashids</a>: generate short unique ids from integers</li>
<li><a href="https://github.com/schoentoon/hashidsxx">GH hashidsxx</a></li>
</ul>
</div>
</div>

<div id="outline-container-org77ee9b0" class="outline-4">
<h4 id="org77ee9b0"><span class="section-number-4">5.8.14</span> Consider moving to <code>PEGTL</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-14">
<p>
Seems like a modern replacement for Boost.Spirit.
</p>

<div class="epigraph"><blockquote>
<p>
The Parsing Expression Grammar Template Library (PEGTL) is a
zero-dependency C++ header-only parser combinator library for creating
parsers according to a Parsing Expression Grammar (PEG).
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/taocpp/PEGTL">GH repo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org62ecef5" class="outline-4">
<h4 id="org62ecef5"><span class="section-number-4">5.8.15</span> Consider integrating with <code>NN-512</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-15">
<div class="epigraph"><blockquote>
<p>
NN-512 is a compiler that generates C99 code for neural net inference:
</p>

<ul class="org-ul">
<li>It takes as input a simple text description of a convolutional
neural net inference graph</li>
<li>It produces as output a stand-alone C99 implementation of that graph</li>
<li>The generated C99 code uses AVX-512 vector instructions to perform
inference</li>
</ul>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://nn-512.com/">NN-512 site</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/k3hiud/generate_standalone_cc_code_for_neural_net/">reddit discussion</a></li>
<li><a href="https://www.ccoderun.ca/darkhelp/api/API.html">DarkHelp</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9d56cfc" class="outline-4">
<h4 id="org9d56cfc"><span class="section-number-4">5.8.16</span> Investigate <code>refureku</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-16">
<div class="epigraph"><blockquote>
<p>
Refureku is a powerful C++17 RTTI free runtime reflection library
based on Kodgen. It allows to retrieve information on namespaces,
structs/classes, fields, methods, non-member variables, non-member
functions, enums and enum values at runtime.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/jsoysouvanh/Refureku">GH repo</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbe5e0fe" class="outline-4">
<h4 id="orgbe5e0fe"><span class="section-number-4">5.8.17</span> Investigate <code>kodgen</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-17">
<div class="epigraph"><blockquote>
<p>
Kodgen is a C++17 library based on libclang. It provides tools to
parse C++ source files, extract data from it, and generate files from
the parsed data. The C++ entities parsed in the current implementation
are namespaces, structs/classes, non-member and member variables,
non-member and member functions, enums and enum values.
</p>

</blockquote></div>

<p>
One possible use for this would be to backout PDM models from existing
source code.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/jsoysouvanh/Kodgen">GH repo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org19babfd" class="outline-4">
<h4 id="org19babfd"><span class="section-number-4">5.8.18</span> Investigate cookietemple project templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-18">
<div class="epigraph"><blockquote>
<p>
A cookiecutter based project template creation tool supporting several
domains and languages with advanced linting, syncing and standardized
workflows to get your project kickstarted in no time.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/cookiejar/cookietemple">GH project</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/jzp8pe/if_you_are_looking_for_an_easy_way_to_start_a_new/">reddit: If you are looking for an easy way to start a new project,
checkout Cookietemple!</a></li>
</ul>
</div>
</div>

<div id="outline-container-org37b3583" class="outline-4">
<h4 id="org37b3583"><span class="section-number-4">5.8.19</span> Consider adding support for <code>repr</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-19">
<div class="epigraph"><blockquote>
<p>
repr is a header-only library. Add include/ to your
target<sub>include</sub><sub>directories</sub> and include &lt;repr/repr.h&gt;.
</p>

<p>
repr(value) returns a printable string representation of value. To
achieve this, repr uses libfmt, magic<sub>enum</sub> and boost::pfr, and
provides a nice convenience function.
</p>

<p>
repr() supports fundamental types, strings, containers, container
adapters, aggregate-initializable classes/structs and chrono types.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/p-ranav/repr">GH repo</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/jzgzoz/repr_for_c_return_printable_string_representation/">reddit: repr for C++: Return printable string representation of a value</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7771b34" class="outline-4">
<h4 id="org7771b34"><span class="section-number-4">5.8.20</span> Product based operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-20">
<p>
It would be interesting to provide a "product API" which is closer to
how we develop in practice. At present we are forced to think at the
level of git (feature branches, master, etc) and associated tools
(docker, kubernetes, etc=. In reality, we have a very small set of
simple operations we do with products. It would be nice if dogen could
provide a wrapper around these. In order to do so we need to force
structural patterns on how these are implemented (i.e. do not allow
for variation outside of a narrow set of well-defined use cases). This
story attempts to capture these use cases. The basic ideas are coming
from several existing tools such as <code>dotnet</code>, <code>cargo</code>, etc.
</p>

<p>
When we start working on a product, it would be nice to be able to do
something like:
</p>

<pre class="example">
dogen product new
</pre>


<p>
or
</p>

<pre class="example">
dogen new product
</pre>


<p>
It would require some additional parameters such as:
</p>

<pre class="example">
--name abc
--forge https://github.com/ORGANISATION
</pre>


<p>
Note that a dogen product maps to a forge organisation (e.g. github,
etc). This may be different for other forges. It assumes some
top-level config with all of the authentication setup. Presumably
there could be an <code>--add-forge</code> command or just edit files manually.
</p>

<p>
The new product command would a top-level directory for the product
and create the organisation.
</p>

<pre class="example">
dogen component new
</pre>


<p>
This would create a new git repo with some standard components. There
could be a <code>--template</code> command to choose the template for the
component. The approach should be similar to <code>dotnet</code>. Note that these
templates are models inside of dogen. Also, when creating the repo, it
would perform the initial git commit, create the repository remotely
and push it. It would also do the worktree setup:
</p>

<ul class="org-ul">
<li><code>PRODUCT.COMPONENT.git.remote</code>: points to remote master and should always be
kept clean for pushes and pulls.</li>
<li><code>PRODUCT.COMPONENT.git.local</code>: local checkout to do work. Further locals can be
created, e.g. <code>local0</code>, etc.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates">Custom templates for dotnet new</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2bb1132" class="outline-4">
<h4 id="org2bb1132"><span class="section-number-4">5.8.21</span> Integration of <code>vcpkg</code> and <code>build2</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-21">
<p>
There are two types of dependencies that we need to worry about:
</p>

<ul class="org-ul">
<li>those external to dogen; these we call "the platform".</li>
<li>those "internal" to dogen; these are the user models.</li>
</ul>

<p>
As it turns out, there are two different ways of managing these two
types of dependencies. The best package managers for C++, such as
conan and vcpkg, have a very large number of packages
available. These are great for the first kind of dependencies because
they have large coverage of C++ libraries. In addition, vcpkg is
written in c++, making integration easier - though perhaps a "vcpkg
lib" would have to be created.
</p>

<p>
Build2, on the other hand, would be very suitable to manage the dogen
created artefacts because it is a "modern" package manager with an
understanding of versions etc. It has some limitations (does not
support binaries, etc), but these are not too taxing if its only for a
small set of models.
</p>

<p>
The trick would be for dogen to orchestrate these two package managers
in a way that is transparent to the user somehow; e.g. you can declare
a vcpkg dependency on your product and it would result in vcpkg doing
the right thing. You can also build a docker image with all the vcpkg
dependencies at a given version and then use that for the build
machines, deployments etc. We would require some conceptual framework
around vcpkg: snapshots, versioning, publishing, etc. Note also that
we should be able to rely on system packages if available. vcpkg
should be seen as the override, used only when we cannot find the
package at that version.
</p>

<p>
We may also want products to share their vcpkg setup so that we don't
have to build core libraries multiple times. Or perhaps we need the
concept of a product family with its associated vcpkg directory setup,
and then the products with their own setup. Libraries can be installed
at the family level or at the product level - or even at the component
level? we need to look for use cases for this.
</p>

<p>
For extra bonus points, it would be nice if we could create a DEB
package for each of these vcpkg exports, so that the src package of
the product and components could depend on the vcpkg, and similarly
the binary package could depend on the vcpkg binary package. One could
then install the platform and then install the product. You could
create dependency trees between the platform and the product. And
these should ideally be side-by-side installable, so that multiple
versions of the platform and the product can coexist. However, note
that we have platform packages at the different levels:
</p>

<ul class="org-ul">
<li>family</li>
<li>product</li>
<li>component</li>
</ul>

<p>
These are placed in the path accordingly, so that the component takes
priority, then the product and finally the family. Note that the
packages themselves have versions, which are not at all related with
the individual libraries they contain. As an example, say we have:
</p>

<ul class="org-ul">
<li>masd: family</li>
<li>dogen: product</li>
<li>dogen: component</li>
</ul>

<p>
We could create a <code>masd.platform_1.0.0.deb</code> package, which installs
into a well known hierarchy. The directory name should have the
family, product etc as well as the version:
</p>

<pre class="example">
/usr/local/masd.platform/1.0.0
</pre>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/microsoft/vcpkg">vcpkg GH</a></li>
<li><a href="https://github.com/microsoft/vcpkg/issues/9258">vcpkg #9258: Add ability to export .deb and .rpm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard (FHS)</a></li>
<li><a href="https://learn.hashicorp.com/waypoint">hashicorp's waypoint</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf16d806" class="outline-4">
<h4 id="orgf16d806"><span class="section-number-4">5.8.22</span> Investigate build time library configuration post&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-22">
<div class="epigraph"><blockquote>
<p>
Why do libraries offer these build-time switches? What do they
accomplish?
</p>

<p>
In the majority of situations, I believe that offering compile-time
tweaks are an antipattern. I could write a detailed post on why, but
thats not the point I want to focus on.
</p>

<p>
Instead, I want to focus on the cases where having these dials and
switches is hugely beneficial or essential.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://vector-of-bool.github.io/2020/10/04/lib-configuration.html">A New Approach to Build-Time Library Configuration</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc35e62e" class="outline-4">
<h4 id="orgc35e62e"><span class="section-number-4">5.8.23</span> Investigate CG-SQL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-23">
<div class="epigraph"><blockquote>
<p>
CG/SQL is a code generation system for the popular SQLite library that
allows developers to write stored procedures in a variant of
Transact-SQL (T-SQL) and compile them into C code that uses SQLites C
API to do the coded operations. CG/SQL enables engineers to create
highly complex stored procedures with very large queries, without the
manual code checking that existing methods require.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/facebookincubator/cg-sQL">GH</a></li>
<li><a href="https://engineering.fb.com/open-source/cg-sql/">CG/SQL: Easy, accurate code generation for SQLite</a></li>
</ul>
</div>
</div>

<div id="outline-container-org85cc302" class="outline-4">
<h4 id="org85cc302"><span class="section-number-4">5.8.24</span> AWS boilerplate generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-24">
<p>
Consider generating AWS boilerplate.
</p>

<div class="epigraph"><blockquote>
<p>
The primary objective of this boilerplate is to give you a production
ready code that reduces the amount of time you would normally have to
spend on system infrastructure's configuration. It contains a number
of services that a typical web application has (frontend, backend api,
admin panel, workers) as well as their continuous deployment. Using
this boilerplate you can deploy multiple environments, each
representing a different stage in your pipeline.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/apptension/aws-boilerplate">aws-boilerplate GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5cea1fa" class="outline-4">
<h4 id="org5cea1fa"><span class="section-number-4">5.8.25</span> MDE links and information&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-25">
<p>
Research story to gather information about MDE.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://modelpractice.wordpress.com/about/">modelpractice</a></li>
</ul>
</div>
</div>

<div id="outline-container-org04cc743" class="outline-4">
<h4 id="org04cc743"><span class="section-number-4">5.8.26</span> Org-mode integration with modeling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-26">
<p>
Since org-mode will be very central to all our modeling efforts, we
need to learn more about it. This story is a general gathering of
links of org-mode and tools.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://kitchingroup.cheme.cmu.edu/blog/2017/01/03/Find-stuff-in-org-mode-anywhere/">Find stuff in org-mode anywhere</a></li>
<li><a href="https://www.mcls.io/blog/encouraging-a-culture-of-written-communication">Encouraging a Culture of Written Communication</a></li>
<li><a href="https://github.com/alphapapa/org-rifle">org-rifle</a>: What does my rifle do? It searches rapidly through my Org
files, quickly bringing me the information I need to defeat the
enemy.</li>
<li><a href="https://writequit.org/articles/emacs-org-mode-generate-ids.html">Emacs Org-mode: Use good header ids!</a></li>
<li><a href="https://github.com/org-roam/org-roam">org-roam GH</a>: Org-roam is a solution for effortless non-hierarchical
note-taking with Org-mode. With Org-roam, notes flow naturally,
making note-taking fun and easy. Org-roam should also work as a
plug-and-play solution for anyone already using Org-mode for their
personal wiki.</li>
<li><a href="https://github.com/bastibe/org-journal">org-journal GH</a>: Functions to maintain a simple personal diary /
journal using in Emacs.</li>
<li><a href="http://www.howardism.org/Technical/Emacs/capturing-intro.html">Org Capturing Introduction</a>: The following essay attempts to be a
gentle introduction to org-capture. I will assume you are familiar
with both Org and Emacs, but dont know anything about org-capture.</li>
<li><a href="https://github.com/weirdNox/org-noter">org-noter GH</a>: Org-noters purpose is to let you create notes that
are kept in sync when you scroll through the document, but that are
external to it - the notes themselves live in an Org-mode file.</li>
<li><a href="https://github.com/samhedin/rustdoc-to-org">rustdoc-to-org:</a> A Pandoc filter that converts rust documentation to
.org-files, and a minor mode to go with!</li>
</ul>
</div>
</div>

<div id="outline-container-orgc885b2d" class="outline-4">
<h4 id="orgc885b2d"><span class="section-number-4">5.8.27</span> Investigate telosys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-27">
<p>
It appears to an interesting code generator, though we cannot locate
any academic papers.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.telosys.org/index.html#intro">telosys homepage</a></li>
<li><a href="https://github.com/telosys-tools-bricks">GH telosys</a></li>
<li><a href="https://modeling-languages.com/telosys-tools-the-concept-of-lightweight-model-for-code-generation/">Telosys  a lightweight and pragmatic code-generator</a></li>
</ul>
</div>
</div>

<div id="outline-container-org29d1cd9" class="outline-4">
<h4 id="org29d1cd9"><span class="section-number-4">5.8.28</span> Consider allowing users to create their own parts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-28">
<p>
It would be nice if one could create our own parts. However the main
problem is how would you allocate modeling elements to a part. At
present this is done via the formatter; perhaps we could override this
in meta-data? This is a very complex task and we need clear use cases
for it. Alternatively we could state that a user defined part's
content is ignored entirely.
</p>
</div>
</div>

<div id="outline-container-orgc7b00b5" class="outline-4">
<h4 id="orgc7b00b5"><span class="section-number-4">5.8.29</span> Check RedHat guidelines on release notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-29">
<p>
This post seems to contain a lot of interesting information about
release notes:
</p>

<ul class="org-ul">
<li><a href="http://community.redhat.com/blog/2015/12/guidelines-for-announcing-software-releases/">Guidelines For Announcing Software Releases</a></li>
</ul>
</div>
</div>

<div id="outline-container-org00a9b3a" class="outline-4">
<h4 id="org00a9b3a"><span class="section-number-4">5.8.30</span> Add support for CBadge&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-30">
<p>
It seems we can add badges for CDash.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/brennonbrimhall/CBadge">GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1e61cbf" class="outline-4">
<h4 id="org1e61cbf"><span class="section-number-4">5.8.31</span> Consider adding support for <code>libcudacxx</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-31">
<div class="epigraph"><blockquote>
<p>
libcu++, the NVIDIA C++ Standard Library, is the C++ Standard Library
for your entire system. It provides a heterogeneous implementation of
the C++ Standard Library that can be used in and between CPU and GPU
code.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/NVIDIA/libcudacxx">GH</a></li>
<li><a href="https://news.ycombinator.com/item?id=24526145">HN post</a></li>
<li><a href="https://docs.nvidia.com/cuda/thrust/index.html">thrust</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga17d357" class="outline-4">
<h4 id="orga17d357"><span class="section-number-4">5.8.32</span> Consider adding <code>using</code> statements to models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-32">
<p>
It probably would be quite trivial, once we move over to org-mode, to
add a top-level section with <code>using</code> statements:
</p>

<pre class="example">
using identification::entities::physical_meta_id
</pre>


<p>
This would then mean that every time we see <code>physical_meta_id</code> we
replace it with the full name. Ideally these should be added at a
package level and have a recursive use. It should be transparent to
code generation. If we detect duplicates we should error.
</p>
</div>
</div>

<div id="outline-container-orgb05cb0a" class="outline-4">
<h4 id="orgb05cb0a"><span class="section-number-4">5.8.33</span> Consider creating wrappers for containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-33">
<p>
A common pattern we see in Dogen are indices and repositories. These
tend to contain standard library containers with domain types. For
example, in <code>mapping_set</code> we have <code>by_agnostic_id</code> which has:
</p>

<pre class="example">
std::unordered_map&lt;
    identification::entities::technical_space,
    std::unordered_map&lt;
        identification::entities::logical_id,
        identification::entities::logical_name&gt;
&gt;
</pre>


<p>
What would be really nice is if we could avoid exposing all of the
internals of the STL containers and provide only the operations that
are needed for the domain types in question. This is very experimental
at present, but the idea is that maybe there is a small subset of
operations we actually do in these types; if that's the case then we
could create a meta-type for them, e.g.:
</p>

<ul class="org-ul">
<li><code>repository</code></li>
<li><code>index</code></li>
</ul>

<p>
And then enable the operations via meta-data. In many ways this is a
bit like a primitive: the meta-type would have a <code>key</code> and a <code>value</code>,
and then define the set of operations. However, we need to do more
thinking. We should start by looking at how these containers are being
used and see if we can abstract the operations from there.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>in every case where we have containers we have a simple pattern of
iteration over the elements (and possibly sub-elements, for
containers of containers), e.g.:</li>
</ul>

<pre class="example">
for (auto&amp; as_pair : m.regions_by_logical_id()) {
    auto&amp; as(as_pair.second);
    for (auto&amp; a_pair : as.artefacts_by_archetype()) {
        auto&amp; a(*a_pair.second);
        apply(a, m.outputting_properties().force_write());
</pre>


<p>
It would be really nice if we could generate a set of top-level
functions in the container that would allow iteration at each of
these levels via a lambda, const and non-const, e.g.:
</p>

<pre class="example">
container.for_each([](const X&amp; x) { ... }
</pre>


<p>
For extra bonus points, we should have an overload with dereferenced
pointer.
</p>
<ul class="org-ul">
<li>we should find appropriate exceptions in the standard library for
all the operations in the container so that we do not have to rely
on the presence of a generated exception.</li>
<li>we also have a very common get by ID, which throws:</li>
</ul>

<pre class="example">
const auto i(global_enablement_properties.find(pmid));
if (i == global_enablement_properties.end()) {
    BOOST_LOG_SEV(lg, error) &lt;&lt; global_configuration_not_found &lt;&lt; pmid;
    BOOST_THROW_EXCEPTION(transform_exception(
            global_configuration_not_found + pmid.value()));
}
const auto&amp; gep(i-&gt;second);
</pre>


<ul class="org-ul">
<li>we also have an insert by ID that checks for duplicates:</li>
</ul>

<pre class="example">
for (const auto&amp; region : regions) {
    const auto lid(region.logical_element()-&gt;name().id());
    const auto pair(std::make_pair(lid, region.physical_region()));
    const auto inserted(rbli.insert(pair).second);
    if (inserted)
        continue;

    BOOST_LOG_SEV(lg, error) &lt;&lt; duplicate_id &lt;&lt; lid;
    BOOST_THROW_EXCEPTION(transform_exception(duplicate_id + lid.value()));
}
</pre>


<p>
We can detect if we are an associative container and generate this
operation. We could have a "strict" and "non-strict" insert.
</p>
</div>
</div>

<div id="outline-container-orga5dfe2f" class="outline-4">
<h4 id="orga5dfe2f"><span class="section-number-4">5.8.34</span> Consider adding support for Matplot++&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-34">
<div class="epigraph"><blockquote>
<p>
Matplot++ is a graphics library for data visualization that provides
interactive plotting, means for exporting plots in high-quality
formats for scientific publications, a compact syntax consistent with
similar libraries, dozens of plot categories with specialized
algorithms, multiple coding styles, and supports generic backends.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/alandefreitas/matplotplusplus">matplotplusplus GH</a></li>
<li><a href="https://github.com/davecom/SVGChart">SVGChart GH</a>: A C++ Library for Making SVG Charts (fork of PPlot)</li>
<li><a href="https://github.com/pabristow/svg_plot">svg<sub>plot</sub> GH</a>: Plot data in SVG format using C++ library.</li>
<li><a href="https://github.com/thclark/cpplot">cpplot GH</a>: Interactive graphs and charts for C++ 11 upward, viewable
in-browser using cpplot-viewer.</li>
<li><a href="https://www.researchgate.net/post/What_are_the_best_plot_and_charting_C_package_which_can_be_used_for_data_visualization">What are the best plot and charting C++ package which can be used
for data visualization?</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8def7aa" class="outline-4">
<h4 id="org8def7aa"><span class="section-number-4">5.8.35</span> Consider adding support for Crypto3&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-35">
<div class="epigraph"><blockquote>
<p>
Modern cryptography suite built in C++ with concept-based architecture.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/NilFoundation/crypto3">GitHub</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdd58ffa" class="outline-4">
<h4 id="orgdd58ffa"><span class="section-number-4">5.8.36</span> Consider adding support for libstud-json&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-36">
<p>
From project:
</p>

<div class="epigraph"><blockquote>
<p>
The goal of this library is to provide a pull-style parser (instead of
push/SAX or DOM) and push-style serializer with clean, modern
interfaces and conforming, well-tested (and well-fuzzed, including the
serializer) implementations. In particular, pull-style parsers are not
very common, and we couldn't find any C++ implementations that also
satisfy the above requirements.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/libstud/libstud-json/">libstud-json</a>: "JSON parser/serializer library for C++"</li>
</ul>
</div>
</div>

<div id="outline-container-org8b2a96c" class="outline-4">
<h4 id="org8b2a96c"><span class="section-number-4">5.8.37</span> Consider adding support for automigrate&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-37">
<p>
Interesting tool for SQL migrations.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/abe-winter/automigrate">automig GH</a>: "Automigrate is a command-line tool for SQL
migrations. Unlike other migration tools, it uses git history to do
diffs on create table statements instead of forcing you to write
up/down diffs for every change."</li>
<li><a href="https://abe-winter.github.io/2020/08/03/yr-of-git.html">One year of automatic DB migrations from git</a></li>
<li><a href="https://www.sqlalchemy.org/">sqlalchemy</a>: "SQLAlchemy is the Python SQL toolkit and Object
Relational Mapper that gives application developers the full power
and flexibility of SQL."</li>
<li><a href="https://alembic.sqlalchemy.org/en/latest/">Alembics documentation</a>: "Alembic is a lightweight database
migration tool for usage with the SQLAlchemy Database Toolkit for
Python."</li>
</ul>
</div>
</div>

<div id="outline-container-orgaaad9c7" class="outline-4">
<h4 id="orgaaad9c7"><span class="section-number-4">5.8.38</span> Consider adding support for eCAL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-38">
<p>
Yet another interprocess communication framework.
</p>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/continental/ecal">ecal GH</a>: The enhanced communication abstraction layer (eCAL) is a
middleware that enables scalable, high performance interprocess
communication on a single computer node or between different nodes
in a computer network.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdbbc5a1" class="outline-4">
<h4 id="orgdbbc5a1"><span class="section-number-4">5.8.39</span> AutoMapper in Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-39">
<p>
AutoMapper is an interesting C# library:
</p>

<div class="epigraph"><blockquote>
<p>
AutoMapper is an object-object mapper. Object-object mapping works by
transforming an input object of one type into an output object of a
different type. What makes AutoMapper interesting is that it provides
some interesting conventions to take the dirty work out of figuring
out how to map type A to type B. As long as type B follows
AutoMappers established convention, almost zero configuration is
needed to map two types.
</p>

</blockquote></div>

<p>
Whilst we don't entirely think its a good idea to use auto mapping at
run time, perhaps it may make more sense in terms of meta-model
constructs. We could abstract the rules that auto mapper has and use
them to generate mapping code. We can also reuse all of the mapping
annotations as meta-data to hint the mapping. This would be useful in
the cases where we generate two representations of objects that are
very similar such as a HTTP data model vs a domain model, or even in
some cases a relational model.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://docs.automapper.org/en/stable/Getting-started.html">AutoMapper: Getting Started Guide</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9ad0e22" class="outline-4">
<h4 id="org9ad0e22"><span class="section-number-4">5.8.40</span> Consider adding support for aspects in logical model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-40">
<p>
At present we avoided having any kind of logging in the generated
code. This was because we did not want users to be coupled to choices
in Dogen such as our logging choices. Since we mainly generate data
objects this has not been a great problem. However, as we move up the
stack and start generating other kinds of elements such as services,
factories and so on, it would be really nice to be able to have
logging. One possible way of solving this is to add support for
aspects. There are a few use cases:
</p>

<ul class="org-ul">
<li>logging</li>
<li>security, permissions</li>
<li>metrics, benchmarks</li>
</ul>

<p>
For each of these cases we have fairly well defined patterns, but
which need some configuration. The user may not want them at all, or
may want to use a specific library for its use case. Each aspect then
has some options related to which implementation to use (this can be
supplied as meta-data). The aspect exists as a stand alone meta-model
element, but must be somehow accessible to any other meta-model
element such that when we start to code generate we can check the
aspects content's. Note that we do not allow users to supply their own
implementation of the aspect; they can merely configure the
aspect. Also, note that both the joint point (e.g. the place where the
advice will be put) as well as the advice (e.g. the code that we want
to put in if the aspect is enabled) will not be configurable by the
user. All that can be done is to choose from a list of options.
</p>

<p>
As a bit of context, Wikipedia <a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">states</a>:
</p>

<div class="epigraph"><blockquote>
<p>
Join point models
</p>

<p>
The advice-related component of an aspect-oriented language defines a
join point model (JPM). A JPM defines three things:
</p>

<ol class="org-ol">
<li>When the advice can run. These are called join points because they
are points in a running program where additional behavior can be
usefully joined. A join point needs to be addressable and
understandable by an ordinary programmer to be useful. It should
also be stable across inconsequential program changes in order for
an aspect to be stable across such changes. Many AOP
implementations support method executions and field references as
join points.</li>
<li>A way to specify (or quantify) join points, called
pointcuts. Pointcuts determine whether a given join point
matches. Most useful pointcut languages use a syntax like the base
language (for example, AspectJ uses Java signatures) and allow
reuse through naming and combination.</li>
<li>A means of specifying code to run at a join point. AspectJ calls
this advice, and can run it before, after, and around join
points. Some implementations also support things like defining a
method in an aspect on another class.</li>
</ol>

<p>
Join-point models can be compared based on the join points exposed,
how join points are specified, the operations permitted at the join
points, and the structural enhancements that can be expressed.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a></li>
<li><a href="https://stackoverflow.com/questions/325558/aspect-oriented-programming-examples">SO: Aspect-oriented programming examples</a></li>
</ul>
</div>
</div>

<div id="outline-container-org67d3d80" class="outline-4">
<h4 id="org67d3d80"><span class="section-number-4">5.8.41</span> Consider adding support for static site generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-41">
<p>
It should be possible to add meta-model elements that model static
site generators. We should then be able to generate the site. The
content files are added as org-babel. We should also add the build
files scripts to generate the file.
</p>

<p>
In an ideal world we want to be able to mix and match the static
generated content with Wt.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://lwn.net/Articles/825507/">Hugo: a static-site generator</a></li>
<li><a href="https://blog.getpelican.com/">Pelican Static Site Generator, Powered by Python</a>: Pelican is a
static site generator that requires no database or server-side
logic.</li>
<li><a href="https://github.com/theiceshelf/firn/">firn GH</a>: "Firn generates a static site from org-mode files. It is a
bit different from other static site generators, in that it intends
to be a drop in solution for creating sites from already existing
folders of org-files." <a href="https://firn.theiceshelf.com/tutorial">Example site</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org9fe75cb" class="outline-4">
<h4 id="org9fe75cb"><span class="section-number-4">5.8.42</span> Consider adding support for cpprouter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-42">
<p>
From the site:
</p>

<div class="epigraph"><blockquote>
<p>
A modern, header-only request router for C++
</p>

<p>
Routing requests
</p>

<p>
This library is designed to route requests to an associated
callback. Requests are matched using a pattern, which may contain
embedded regular expressions. The data matched with the regular
expression is then parsed and provided to the callback.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/omartijn/cpprouter">https://github.com/omartijn/cpprouter</a></li>
</ul>
</div>
</div>

<div id="outline-container-org172d3ee" class="outline-4">
<h4 id="org172d3ee"><span class="section-number-4">5.8.43</span> Consider adding support for LogDevice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-43">
<p>
It would be nice if we could dump types into a distributed log such as
log device. Similar to AMQP support, we probably could also add
elements to the logical model to model core concepts of the log, which
need to be analysed but presumably must be like a topic, etc. We
should also be able to read and write to the log, etc.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/facebookincubator/LogDevice">LogDevice</a>: "LogDevice is a scalable and fault tolerant distributed
log system. While a file-system stores and serves data organized as
files, a log system stores and delivers data organized as logs. The
log can be viewed as a record-oriented, append-only, and trimmable
file."</li>
<li><a href="https://github.com/cdapio/tigon">tigon</a>: "Tigon is an open-source, real-time, low-latency,
high-throughput stream processing framework."</li>
</ul>
</div>
</div>

<div id="outline-container-org6925047" class="outline-4">
<h4 id="org6925047"><span class="section-number-4">5.8.44</span> Improve C# primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-44">
<p>
First we need to check if these are already supported. Then we need to
see if there are any things we're missing from projects already
implementing such types.
</p>

<p>
Primitives are in the current C# ref impl model.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/GeirGrusom/IdGenerator">IdGenerator GH</a>: "This project adds a source generator to your
project that creates identity types. It's used for types that
identifies some resource. For example a user id or application id."
See template at the bottom of <a href="https://github.com/GeirGrusom/IdGenerator/blob/master/src/IdGenerator/IdGenerator.cs">this</a> file.</li>
</ul>
</div>
</div>

<div id="outline-container-org9ef8cc6" class="outline-4">
<h4 id="org9ef8cc6"><span class="section-number-4">5.8.45</span> Consider allowing restrictions on primitives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-45">
<p>
In XML it is possible to state the following:
</p>

<pre class="code"><code>  &lt;<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">simpleType</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"Scheme"</span>&gt;
    &lt;<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">annotation</span>&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">documentation</span> <span style="color: #C586C0; font-weight: bold;">xml</span>:<span style="color: #85DDFF;">lang</span>=<span style="color: #DB8E73;">"en"</span>&gt;The base class for all types which define<span style="color: #D16969; background-color: #171F24; font-weight: bold;"> coding schemes that are allowed to be empty.</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">&lt;</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">/</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">xsd</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">:</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">documentation</span><span style="color: #D16969; background-color: #171F24; font-weight: bold;">&gt;</span>
    &lt;/<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">annotation</span>&gt;
    &lt;<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">restriction</span> <span style="color: #85DDFF;">base</span>=<span style="color: #DB8E73;">"NormalizedString"</span>&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">maxLength</span> <span style="color: #85DDFF;">value</span>=<span style="color: #DB8E73;">"255"</span> /&gt;
    &lt;/<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">restriction</span>&gt;
  &lt;/<span style="color: #C586C0; font-weight: bold;">xsd</span>:<span style="color: #D9DAA2;">simpleType</span>&gt;
</code></pre>

<p>
Then the type <code>Scheme</code> is now a restriction of a string:
</p>

<div class="epigraph"><blockquote>
<p>
The normalizedString data type is derived from the String data type.
</p>

<p>
The normalizedString data type also contains characters, but the XML
processor will remove line feeds, carriage returns, and tab
characters.
</p>

</blockquote></div>

<p>
It would be really nice if we could also have restrictions on our
primitive types, particularly with things such as normalised string.
</p>
</div>
</div>

<div id="outline-container-org8b2336c" class="outline-4">
<h4 id="org8b2336c"><span class="section-number-4">5.8.46</span> Consider adding scripts or targets for core dumping&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-46">
<p>
We will likely need the same kind of scripts to retrieve core dumps
from generated applications. We could either create CMake targets for
these or maybe shell scripts. At least for the most common scenarios.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Microsoft/ProcDump-for-Linux">ProcDump GH</a>: ProcDump is a Linux reimagining of the classic ProcDump
tool from the Sysinternals suite of tools for Windows. ProcDump
provides a convenient way for Linux developers to create core dumps
of their application based on performance triggers.</li>
<li><a href="https://linux.byexamples.com/archives/371/gcore-obtain-core-dump-of-current-running-application/">gcore: obtain core dump of current running application</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf9666b" class="outline-4">
<h4 id="orgdf9666b"><span class="section-number-4">5.8.47</span> Consider adding support for <code>zq</code> and ZNG&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-47">
<p>
Interesting tool for log parsing, and associated format.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/brimsec/zq">GH project</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc67728c" class="outline-4">
<h4 id="orgc67728c"><span class="section-number-4">5.8.48</span> Consider adding support for <code>objectbox</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-48">
<p>
This is a very interesting project:
</p>

<div class="epigraph"><blockquote>
<p>
ObjectBox is a superfast database for objects. These are the C and C++
APIs to run ObjectBox as an embedded database in your C/C++
application. In this embedded mode, it runs within your application
process.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/objectbox/objectbox-c">GH project</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7442a34" class="outline-4">
<h4 id="org7442a34"><span class="section-number-4">5.8.49</span> Consider adding support for <code>libmish</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-49">
<div class="epigraph"><blockquote>
<p>
Libmish adds a command prompt to your program, and telnet access. With
your own commands.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/buserror/libmish">libmish GH</a></li>
<li><a href="https://github.com/ggerganov/incppect">incppect GH</a>: Inspect C++ memory in the browser</li>
</ul>
</div>
</div>

<div id="outline-container-orgf1e1425" class="outline-4">
<h4 id="orgf1e1425"><span class="section-number-4">5.8.50</span> Consider adding support for gatbage collection via Oilpan&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-50">
<p>
This looks like an interesting project: Oilpan.
</p>

<div class="epigraph"><blockquote>
<p>
Oilpan is a garbage collector written in C++ for managing C++ memory
</p>

</blockquote></div>

<p>
Links:
</p>
<ul class="org-ul">
<li><a href="https://chromium.googlesource.com/v8/v8.git/+/HEAD/include/cppgc/">source code</a></li>
<li><a href="https://v8.dev/blog/high-performance-cpp-gc">High-performance garbage collection for C++</a></li>
</ul>
</div>
</div>

<div id="outline-container-org966ef7f" class="outline-4">
<h4 id="org966ef7f"><span class="section-number-4">5.8.51</span> Add support for QR codes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-51">
<p>
It should be pretty straightforward to add support for QR
codes. Wikipedia definition:
</p>

<div class="epigraph"><blockquote>
<p>
QR code (abbreviated from Quick Response code) is the trademark for a
type of matrix barcode (or two-dimensional barcode) first designed in
1994 for the automotive industry in Japan. A barcode is a
machine-readable optical label that contains information about the
item to which it is attached. In practice, QR codes often contain data
for a locator, identifier, or tracker that points to a website or
application. A QR code uses four standardized encoding modes (numeric,
alphanumeric, byte/binary, and kanji) to store data efficiently;
extensions may also be used.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nayuki/QR-Code-generator/tree/master/cpp">QR-Code-generator GH</a>: This project aims to be the best, clearest QR
Code generator library in multiple languages. The primary goals are
flexible options and absolute correctness. Secondary goals are
compact implementation size and good documentation comments. See
also <a href="https://github.com/nayuki/QR-Code-generator">top-level page</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/QR_code">QR code Wikipedia</a></li>
<li><a href="https://github.com/RaymiiOrg/cpp-qr-to-png">cpp-qr-to-png GH</a>: A bridge between two great libraries,
QR-Code-Generator and Tiny-PNG-Out. Article <a href="https://raymii.org/s/software/Cpp_generate_qr_code_and_write_it_to_png_scaled.html">here</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org3e15f16" class="outline-4">
<h4 id="org3e15f16"><span class="section-number-4">5.8.52</span> Investigate SQLancer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-52">
<p>
This looks like an interesting project:
</p>

<div class="epigraph"><blockquote>
<p>
SQLancer (Synthesized Query Lancer) is a tool to automatically test
Database Management Systems (DBMS) in order to find logic bugs in
their implementation. We refer to logic bugs as those bugs that cause
the DBMS to fetch an incorrect result set (e.g., by omitting a
record).
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/sqlancer/sqlancer">GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3e48176" class="outline-4">
<h4 id="org3e48176"><span class="section-number-4">5.8.53</span> Investigate how RBAC can be integrated with Dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-53">
<p>
At some point we will need permissions in Dogen. RBAC is a possibility.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://cmw.web.cern.ch/CMW/rbacAPI/index.html">http://cmw.web.cern.ch/CMW/rbacAPI/index.html</a></li>
<li><a href="http://www.authenticationworld.com/Single-Sign-On-Authentication/SSOandLDAP.html">http://www.authenticationworld.com/Single-Sign-On-Authentication/SSOandLDAP.html</a></li>
<li><a href="https://payhip.com/b/41Tw">https://payhip.com/b/41Tw</a></li>
<li><a href="https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=summary">https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=summary</a></li>
<li><a href="https://github.com/casbin/casbin-cpp">casbin-cpp GH</a>: An authorization library that supports access control
models like ACL, RBAC, ABAC in C/C++.</li>
<li><a href="https://github.com/sirikata/liboauthcpp">liboauthcpp GH</a>: A pure C++ OAuth library.</li>
<li><a href="https://github.com/InfiniteRasa/Authentication-Server">Authentication-Server</a></li>
<li><a href="https://stackoverflow.com/questions/11580944/client-to-server-authentication-in-c-using-sockets">Client to Server Authentication in C++ using sockets</a></li>
<li><a href="https://www.omg.org/news/meetings/workshops/presentations/docsec_present/1997/1-1.pdf">Introduction to CORBA Security</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge74b999" class="outline-4">
<h4 id="orge74b999"><span class="section-number-4">5.8.54</span> Consider adding OpenHMI support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-54">
<p>
This is a Qt only framework but seems very interesting:
</p>

<div class="epigraph"><blockquote>
<p>
"Open HMI Tester" or OHT is an application framework for the
development of GUI testing tools. It uses real-time GUI introspection
to capture and simulate real user interaction, which enhances
robustness and tolerance to changes during testing stage.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/pedromateo/openhmitester">GH project</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd07d7d8" class="outline-4">
<h4 id="orgd07d7d8"><span class="section-number-4">5.8.55</span> Consider adding AMQP support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-55">
<p>
It seems fairly straightforward to extend the logical model to support
AMQP. We could add the following entities:
</p>

<ul class="org-ul">
<li>cluster: package. Has a name.</li>
<li>node: package. belongs to a cluster, has a name.</li>
<li>virtual host: package. belongs to a node, has a name.</li>
<li>exchange: class. has a name, belongs to a host.</li>
<li>queue: class. has a name, belongs to a host.</li>
<li>binding: relationship. associates exchanges with exchanges or
queues. Has a routing key and a set of KVPs (called arguments).</li>
</ul>

<p>
With this we can do the basic modeling of simple setups for AMQP. We
could also generate code that generates this infrastructure (or
destroys it).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we could associate objects in the object model to topics and to
routing keys. This could be done via a short-hand that says "for
this object create an associated topic" whatever that means
precisely.</li>
<li>we could generate all the code for reading and writing the object.</li>
<li>we should add these logical model elements to AMQP namespace and
wait until other MQs show up. Then we can abstract them into a MQ
namespace, potentially.</li>
<li>initialisation code should only be triggered on demand; this is
because if we have multiple services we may have race conditions. We
need to ensure one of them has the lock to create the
infrastructure.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">Advanced Message Queuing Protocol</a></li>
<li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">RabbitMQ: AMQP 0-9-1 Model Explained</a></li>
<li><a href="https://qpid.apache.org/releases/qpid-cpp-1.39.0/index.html">Qpid C++ 1.39.0</a>: Qpid C++ offers a connection-oriented messaging API
and a message broker written in C++ that stores, routes, and
forwards messages using AMQP.</li>
<li><a href="https://github.com/apache/qpid-cpp">qpid GH</a>. <a href="https://github.com/apache/qpid-cpp/tree/master/examples/messaging">Examples</a>.</li>
<li><a href="https://github.com/bloomberg/corokafka">corokafka GH</a>: Coroutine-based Kafka messaging library! CoroKafka is
a scalable and simple to use C++ library built on top of cppkafka
and quantum, supporting any number of parallel producers and
consumers.</li>
<li><a href="https://github.com/mfontanini/cppkafka">cppkafka GH</a>: "cppkafka allows C++ applications to consume and
produce messages using the Apache Kafka protocol. The library is
built on top of librdkafka, and provides a high level API that uses
modern C++ features to make it easier to write code while keeping
the wrapper's performance overhead to a minimum."</li>
</ul>
</div>
</div>

<div id="outline-container-org908f121" class="outline-4">
<h4 id="org908f121"><span class="section-number-4">5.8.56</span> Consider supporting nano-id&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-56">
<p>
At present we are relying on UUIDs for several things such as tracing
file names. These will be used even more once we get into
services. Apparently there is a slightly more compact way of doing
this: nano-id. We could not locate a port to C++.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/codeyu/nanoid-net">GH nanoid-net</a>: nano-id for C#</li>
<li><a href="https://medium.com/javascript-in-plain-english/you-might-not-need-uuid-v4-for-generating-random-identifiers-89e8a28a7d77">You Might Not Need UUID V4 for Generating Random Identifiers</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb955734" class="outline-4">
<h4 id="orgb955734"><span class="section-number-4">5.8.57</span> Consider developing a org-mode log format&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-57">
<p>
We seem to be applying org-mode to everything, with some
success. Perhaps it could also be applied to log files. Whilst the
structure of the logs is normally flat, they are encoding a space with
topology. That is to say, if one imagines a single-threaded program
(multi-threaded is much more complex), it would be great if one could
see the logged data as a graph that is isomorphic to the product and
component structure. Note though that we are not proposing a
"physical" representation of the graph, or else we will end up with a
debugger output or a profile (e.g. function call tree). Instead, the
idea is that with the domain knowledge one has, you can choose what
containment relationships are relevant and these may not at all
coincide with the function call tree. Instead, what you are looking
for is "readability" of the graph: can a user follow it through and
figure out what high-level operations the system is performing?
</p>

<p>
Most of the data in a log file can be encoded in org-mode:
</p>

<ul class="org-ul">
<li>timestamps can be encoded as org-mode timestamps.</li>
<li>log level can be a tag.</li>
<li>object and attribute names can be titles in a header.</li>
<li>content can be encoded depending on the types; see the story on
tracing via org-mode for ideas.</li>
</ul>

<p>
In addition, for performance reasons we could encode the data into a
binary format, which can be cracked open into org-mode as required. We
could also create a "org-logger" designed specifically to log data in
this hierarchy, with appropriate functions (create scope, etc). We
could add appropriate scope guards to perform entry and exit of scopes
as we do with tracing. We could also use macros as boost log does for
performance reasons.
</p>

<p>
Its important to note that this would be very complicated in a
multi-threaded world. We could take the easy approach and make each
thread a root topic, but then its not clear how one would follow the
context from where the thread was created.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://kitchingroup.cheme.cmu.edu/blog/2017/01/03/Find-stuff-in-org-mode-anywhere/">Find stuff in org-mode anywhere</a>: org-mode in a SQLite database.</li>
</ul>
</div>
</div>

<div id="outline-container-org0d9c344" class="outline-4">
<h4 id="org0d9c344"><span class="section-number-4">5.8.58</span> Consider adding support for SignalR&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-58">
<p>
SignalR:
</p>

<div class="epigraph"><blockquote>
<p>
SignalR is a free and open-source software library for Microsoft
ASP.NET that allows server code to send asynchronous notifications to
client-side web applications. The library includes server-side and
client-side JavaScript components.
</p>

</blockquote></div>

<p>
Once we have support for Casablance, we can also consider adding
support for SignalR.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/aspnet/SignalR-Client-Cpp">SignalR-Client-Cpp</a>: C++ Client for ASP.NET Core SignalR</li>
<li><a href="https://blog.3d-logic.com/2015/05/20/signalr-native-client/">SignalR c++ client</a>: blog post on c++ client implementation.</li>
<li><a href="https://github.com/SystemTera/signalr-cpp">signalr-cpp</a>: SignalR C++ Implemenation (server)</li>
</ul>
</div>
</div>

<div id="outline-container-org16a1efa" class="outline-4">
<h4 id="org16a1efa"><span class="section-number-4">5.8.59</span> Add support for T2T transforms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-59">
<p>
We have done a lot of analysis work on text-to-text (T2T) transforms,
and even implemented the key classes but it was not suitable for
stitch and wale so it was removed. It should be usable for cartridges
though such as ODB and XSD tool.
</p>

<p>
Commits:
</p>

<pre class="example">
b9e7fe0263 text: remove text to text transforms
c4e1e092d6 text: remove t2t transform data
9fcf0ec8fc integration text.cpp, physical: remove unused attribute for text to text transform
ceee85f654 text.cpp: remove used wale key for text template transform
5bd2ea45b4 text.cpp: remove used functionality in wale for text template transform
</pre>
</div>
</div>

<div id="outline-container-orgc5814ed" class="outline-4">
<h4 id="orgc5814ed"><span class="section-number-4">5.8.60</span> Consider making <code>stitch_template_builder</code> a text template builder&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-60">
<p>
At present we are manually crafting a stream in
<code>stitch_template_builder</code> that resembles a stitch template. Perhaps we
should be building the domain objects of a stitch template instead,
and then have a formatter than renders the template as a string. This
would be the "opposite" of the current formatter which instantiates
the template.
</p>
</div>
</div>

<div id="outline-container-orgfe5b86a" class="outline-4">
<h4 id="orgfe5b86a"><span class="section-number-4">5.8.61</span> Consider implementing transforms as dataflow graphs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-61">
<p>
Transforms are very similar data structures to the elements of a data
flow pipeline: it would probably not require huge amounts of mapping
to create a data flow pipeline that represents the transforms and
transform chains in Dogen. We also now have a very good idea of what
the interfaces for transforms should be in each model. We should
probably wait until we have sorted out the story around error messages
but once that is done its worth investigating if transforms can be
implemented as a graph in a data flow library. Performance may benefit
a little - there are a few things we can do in parallel such as
injection - but its not the key objective here.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://flowbasedprogramming.com/docs/html/index.html">DSPatch</a>: The Refreshingly Simple C++ Dataflow Framework</li>
<li><a href="https://github.com/RaftLib/RaftLib">RaftLib GitHub</a>: The RaftLib C++ library, streaming/dataflow
concurrency via C++ iostream-like operators. See also <a href="http://raftlib.io">home page</a>.</li>
<li><a href="https://github.com/taskflow/taskflow">Taskflow GH</a>: Modern C++ Parallel Task Programming. <a href="https://taskflow.github.io/taskflow/index.html">API docs</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orga6e748e" class="outline-4">
<h4 id="orga6e748e"><span class="section-number-4">5.8.62</span> Consider adding suppot for SeqAn&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-62">
<p>
This is a very interesting library, though its not clear how we'd use
it.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/seqan/seqan3">seqan3 GitHub</a>: The modern C++ library for sequence
analysis. Contains version 3 of the library and API docs</li>
</ul>
</div>
</div>

<div id="outline-container-orgaebdb2c" class="outline-4">
<h4 id="orgaebdb2c"><span class="section-number-4">5.8.63</span> Use static registration with initialisers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-63">
<p>
Since the start, we avoided using static registration for
initialisation due to the static initialisation order fiasco. Its much
better to manually determine the order of initialisation and do it
under programatic control rather than depend on the linker. However,
the downside is that we now have lots of code that needs to be called,
and every so often we forget to join all the dots. Perhaps we need
something in between complete "manual registration" and static
registration. Instead of supplying the registrars from the top-level,
we could instead:
</p>

<ul class="org-ul">
<li>use static registration for a top-level initialiser. This is a very
simple interface that has only one method: initialise. It uses
regular static registration, but it merely adds itself to a
list. Nothing else happens during static initialisation.</li>
<li>when program starts, we call <code>initialise()</code> on all initialisers.</li>
<li>within a given component, the top-level initialiser calls other
initialisers. Internally, it obtains references to static registrars
as required (e.g. features, etc). All of this happens during normal
program execution, so we can log.</li>
<li>DLLs can register initialisers on load. However, we are expected to
load them prior to calling initialisation.</li>
<li>all registrars should have a "validate" method. We should check that
they are not empty. This method should be called prior to use. We
should also have a "initialised" flag that stops
double-initialisation. It should be set as the last step of
initialisation.</li>
</ul>

<p>
Actually we changed our minds on this story. We are keeping it in the
backlog because it may be of use for something else, but for this
particular case what we really want is to implement "static DI". There
shall be a story for this.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://dxuuu.xyz/cpp-static-registration.html">C++ patterns: static registration</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0165425" class="outline-4">
<h4 id="org0165425"><span class="section-number-4">5.8.64</span> Consider adding a <code>--dump-stats</code> option&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-64">
<p>
It would be nice if one could know some stats for a given run:
</p>

<ul class="org-ul">
<li>total models loaded.</li>
<li>total elements processed.</li>
<li>total files generated.</li>
<li>total files written to the filesystem.</li>
<li>total files that have not changed.</li>
<li>total files ignored via regexes.</li>
<li>time spent on each part of the pipeline. Percentages of the overall
cost.</li>
</ul>

<p>
Users could supply a command line option such as <code>--dump-stats</code> and
then Dogen would output all of the stats to the console.
</p>

<p>
Data should be dumped in a way that would facilitate the creation of
timeseries and plots. For example, we should be able to do a dump for
each release of dogen and then create a timeseries. We could have a
<code>--reporting-style</code> of <code>csv</code> for instance.
</p>

<p>
Merged stories:
</p>

<p>
<b>Dump model stats and metrics</b>
</p>

<p>
It would be nice to be able to get some information about a model. We
already have a dumpspecs command but that is more for the system
itself. What we also need is to dump stats on the model such as number
of objects, whether the generated code is up-to-date, etc. We could
also link this story with <a href="#orgea63f06">measurements of complexity</a>.
</p>
</div>
</div>

<div id="outline-container-org588eb02" class="outline-4">
<h4 id="org588eb02"><span class="section-number-4">5.8.65</span> Feature toggles and code generation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-65">
<p>
This article by Fowler has some interesting ideas:
</p>

<ul class="org-ul">
<li><a href="http://martinfowler.com/articles/feature-toggles.html">Feature Toggles</a></li>
</ul>

<p>
It is not clear how it applies to code generation, if at all. This
story is to bookmark the article so we can mine it later for ideas.
</p>

<p>
Note that we would not use feature toggles directly in dogen, because
we are already using feature models for this. But we could conceivably
generate code for applications to use feature toggles. Actually that's
not quite true; variability model has a role to play within
code-generation. However, we could still make use of a feature model
for other purposes:
</p>

<ul class="org-ul">
<li>when we have a web api, we may want to enable or disable
functionality in that service, possibly dynamically (for A/B
testing).</li>
<li>when we have a UI, we will have a similar requirement.</li>
</ul>

<p>
These two approaches serve different needs. In addition, feature
toggles are not specific to Dogen and can be used by any product
generated by Dogen.
</p>
</div>
</div>

<div id="outline-container-orgc40f57d" class="outline-4">
<h4 id="orgc40f57d"><span class="section-number-4">5.8.66</span> Add support for design by contract&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-66">
<p>
If dogen had a way to parse <a href="https://en.wikipedia.org/wiki/Object_Constraint_Language">OCL</a>, we could allow users to specify OCL
constraints on operations. These could then be used to code-generate
design by contract code. For C++ we could use <a href="https://www.boost.org/doc/libs/develop/libs/contract/doc/html/index.html">Boost.Contract</a>. This
appears to be a very difficult thing to do. There may also be C++ 20
support for contracts.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.reddit.com/r/cpp/comments/cmk7ek/what_happened_to_c20_contracts/">What Happened to C++20 Contracts?</a> Contracts didn't make it to
C++ 20.</li>
<li><a href="https://www.modernescpp.com/index.php/c-core-guidelines-a-detour-to-contracts">C++ Core Guidelines: A Short Detour to Contracts in C++20</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5ee922f" class="outline-4">
<h4 id="org5ee922f"><span class="section-number-4">5.8.67</span> Add the the EMF purchase order examples to manual&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-67">
<p>
We should make use of the examples for eCore to demo Dogen. We could
make a similar chapter flow in the manual, starting with a simpler
model and then evolving it to the most complicated one. It would
require a little bit of an adaptation since Dogen does not support all
of the features that EMF has, but it seems a better way to demo Dogen
rather than just talk about the code structure. We could add this
after the section on authoring diagrams. Or maybe we should try to
build all of the missing features in Dogen as part of this
exercise. This could form the basis of the Dogen manual.
</p>
</div>
</div>

<div id="outline-container-orgc6b18dd" class="outline-4">
<h4 id="orgc6b18dd"><span class="section-number-4">5.8.68</span> Investigate CLAFER&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-68">
<p>
As per their site:
</p>

<div class="epigraph"><blockquote>
<p>
Clafer is a general-purpose lightweight structural and behavioral
modeling language developed by GSD Lab, University of Waterloo, and
MODELS group at IT University of Copenhagen. Clafer can be used for
modeling of static hierarchical structures and for modeling the change
of the structures over time (behavior). Clafer allows for naturally
expressing variability in both the structure and behavior. The main
goal of Clafer is to make modeling more accessible to a wider range of
users and domains.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/gsdlab/clafer">GitHub repo</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6323bf8" class="outline-4">
<h4 id="org6323bf8"><span class="section-number-4">5.8.69</span> Consider adding a GIR/GObject injector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-69">
<p>
GIR seems to be yet another format that could be suitable for a dogen
injector.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://gitlab.com/mnauw/cppgir">cppgir</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/bbp25s/gobjectintrospection_c_binding_wrapper_generator/">GObject-Introspection C++ binding wrapper generator</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2d29519" class="outline-4">
<h4 id="org2d29519"><span class="section-number-4">5.8.70</span> Message replay&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-70">
<p>
This is a very speculative story. Once we are able to generate
services with messages, etc., it would make sense to have a "replay"
mode. This basically recalls a session with requests and responses so
that users can replay a session. The messages should be stored on a
database (or perhaps the filesystem? maybe it should be a meta-data
variable). We should also have an interface with an history of
requests and responses and allow users to re-submit a request,
switching on logging for that particular request. Logging is also
written to a database table, allowing one to correlate the request
processing with the logging. Even better would be if any request made
to downstream systems would also enable those flags so that we could
follow through with the logging.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://firefox-replay.com/">Firefox WebReplay</a>: main site. Should give us some ideas for the UI.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/WebReplay">Firefox WebReplay</a>: documentation.</li>
</ul>
</div>
</div>

<div id="outline-container-orgad9f5d5" class="outline-4">
<h4 id="orgad9f5d5"><span class="section-number-4">5.8.71</span> Consider adding support for binary logging&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-71">
<p>
Dogen logs are very large when we log at high-level such as <code>debug</code>
and <code>trace</code>. It also takes a bit longer to run. This means its not
very practical to enable logging all the time, only when we are
troubleshooting. However, for "dogen as a service" we probably will
end up using logging a lot more often so it would be nice to have a
more efficient way of logging. One possibility is to use binary logs.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Morgan-Stanley/binlog">binlog</a>: A high performance C++ log library, producing structured
binary logs <a href="http://binlog.org">http://binlog.org</a></li>
<li><a href="https://github.com/odygrd/quill">quill</a>: Asynchronous Low Latency Logging Library</li>
<li><a href="https://github.com/KjellKod/g3log">g3log</a>: G3log is an asynchronous, "crash safe", logger that is easy
to use with default logging sinks or you can add your own.</li>
<li><a href="https://github.com/PlatformLab/NanoLog">NanoLog</a>: Nanolog is an extremely performant nanosecond scale logging
system for C++ that exposes a simple printf-like API.</li>
</ul>
</div>
</div>

<div id="outline-container-org03e8db0" class="outline-4">
<h4 id="org03e8db0"><span class="section-number-4">5.8.72</span> Consider using command line indicators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-72">
<p>
Dogen is, by design, pretty quick to execute. However, we may want to
consider supporting a command line progress bar. This would be useful
when we use relational dumping, for example.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/p-ranav/indicators">indicators</a></li>
<li><a href="https://github.com/Llawliet0872/progress_bar_cpp">progress<sub>bar</sub><sub>cpp</sub> GH</a>: "This is a simple library for progress bars in
c++."</li>
</ul>
</div>
</div>

<div id="outline-container-org04ed4ce" class="outline-4">
<h4 id="org04ed4ce"><span class="section-number-4">5.8.73</span> Consider adding support for tabulate&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-73">
<p>
This library allows dumping tables to the command line. It would be
nice if we could have a facet that allows IO as a table for certain
types.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/p-ranav/tabulate">tabulate</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7ac3dd9" class="outline-4">
<h4 id="org7ac3dd9"><span class="section-number-4">5.8.74</span> Consider visualisation like source trail&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-74">
<p>
Once we move to org files, we will no longer be able to visualise the
files easily. We had considered using graphviz. An interesting
alternative is to see what lessons can be learned from source
trail. We don;t necessarily need a UI exactly like source trail, but
instead something that would work within emacs and display a
"graphical" (e.g. text) view of the model as we are editing. We also
need some kind of integration like org-noter, whereby as we move
around the org document, the visualisation changes. The data being
visualised should be like source trail. It should also be possible to
link back to the physical model (e.g. for a given model element,
display the files it generates). In effect we need more of a "dogen
mode" which does a number of things at the same time:
</p>

<ul class="org-ul">
<li>LSP on org-mode.</li>
<li>specialised treemacs.</li>
<li>COGRE displaying UML diagram.</li>
<li>preview of file which updates when model is regenerated.</li>
</ul>

<p>
Similarly, if we had a "dogen studio", the UI could contain a
visualisation for this.
</p>

<p>
We should also see C++ Depend.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this could be implemented as an emacs mode that calls dogen behind
the scenes to generate the lisp representing the portion of the
diagram we're interested in. In fact, better than COGRE would be to
just do a partial PlantUML diagram with classes "near" the current
class; as you are moving in the org mode file, the dogen LSP server
is returning the svg for the "nearby" classes. This could be
implemented in a generic way so that any LSP server could use it.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=Cfu6f0uyzc8">SourceTrail demo</a></li>
<li><a href="https://github.com/weirdNox/org-noter">org-noter github</a></li>
<li><a href="https://www.youtube.com/watch?v=Un0ZRXTzufo">org-noter demo</a></li>
<li><a href="http://cedet.sourceforge.net/uml.shtml">CEDET COGRE</a>: Emacs mode for UML diagrams.</li>
<li><a href="https://www.cppdepend.com/cppdependv2020">C++ Depend</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf747ce4" class="outline-4">
<h4 id="orgf747ce4"><span class="section-number-4">5.8.75</span> Create some basic naming guidelines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-75">
<p>
As per Framework Design Guidelines, we need some basic guidelines for
naming in Dogen. We don't need to go overboard, we just need something
to get us started and evolve it as we go along.
</p>

<p>
For extra bonus points, it would be nice to integrate these with
Dogen, such that one would get warnings or errors when processing a
diagram.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://isocpp.org/wiki/faq/coding-standards">C++ Coding Standards</a></li>
<li><a href="http://wiki.c2.com/?CapitalizationRules">Capitalization Rules</a></li>
<li><a href="https://en.wikipedia.org/wiki/Snake_case">Snake Case</a></li>
<li><a href="http://cs.smu.ca/~porter/csc/ref/stl/naming_conventions.html">Naming Conventions for these STL Reference Pages</a></li>
<li><a href="https://style-guides.readthedocs.io/en/latest/cpp.html">C++ coding style guide</a></li>
<li><a href="https://stxxl.org/tags/1.4.1/coding_style.html">Coding Style Guidelines</a></li>
<li><a href="https://www.fluentcpp.com/2018/04/24/following-conventions-stl/">Make Your Containers Follow the Conventions of the STL</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2c044b4" class="outline-4">
<h4 id="org2c044b4"><span class="section-number-4">5.8.76</span> Add Levenshtein distance to enums when converting from string&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-76">
<p>
When we fail to convert a string to an enum, it would be nice if the
converter could, optionally, calculate the levenshtein distance of the
string to valid enums and provide suggestions. We could add these to
the exception error.
</p>
</div>
</div>

<div id="outline-container-org9fdd87d" class="outline-4">
<h4 id="org9fdd87d"><span class="section-number-4">5.8.77</span> Add GraphViz/Dot export support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-77">
<p>
At present we assume the physical model is the only destination for
models. However, once we start moving to text based injectors, it may
be useful to generate UML diagrams. This could be achieved via dot.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this could be added to the convert activity.</li>
<li>we could then have options such as include attributes, include
comments, etc.</li>
<li>PlantUML makes use of dot to generate nice-looking diagrams. We
should try to get some examples of the dot code they generate and
see if we can copy it. <a href="https://real-world-plantuml.com/">Image examples here</a>. It <a href="https://forum.plantuml.net/2034/add-dot-as-output-format">may not be possible</a>
though.</li>
<li>graphviz can be consumed as a library. This would mean we wouldn't
have any external dependencies, and we could generate PDFs
directly.</li>
<li>not yet supported on <a href="https://github.com/Microsoft/vcpkg/issues/737">vcpkg</a>.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.ffnn.nl/pages/articles/media/uml-diagrams-using-graphviz-dot.php">UML Diagrams Using Graphviz Dot</a></li>
<li><a href="https://lornajane.net/posts/2011/uml-diagrams-with-graphviz">UML Diagrams with Graphviz</a></li>
<li><a href="https://www.graphviz.org/pdf/libguide.pdf">Using Graphviz as a Library</a></li>
<li><a href="https://fsteeg.wordpress.com/2006/11/17/uml-class-diagrams-with-graphviz/">UML class diagrams with Graphviz</a></li>
<li><a href="https://www.graphviz.org/pdf/dotguide.pdf">Drawing graphs with dot</a></li>
<li><a href="https://www.drdobbs.com/cpp/graphviz-and-c/184402049">GraphViz and C++</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga0e9f2a" class="outline-4">
<h4 id="orga0e9f2a"><span class="section-number-4">5.8.78</span> Syntax checking support for stitch templates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-78">
<p>
It would be really nice to have syntax checking for stitch
templates. This may be simpler than expected. We have two types of
errors:
</p>

<ul class="org-ul">
<li>stitch errors: these are invalid stitch templates. We already detect
these. We just need to output a GCC-style error message.</li>
<li>c++ errors: these occur after we've weaved, by compiling the c++
code. These are slightly trickier: we need to map the c++ lines to
the stitch lines; this can be done during the generation of the
stitch template, where as we output the code, we also keep track of
the lines. For example, in a loop, one stitch template line will map
to many c++ lines. We also need access to the compilation
database. We then shell out using Boost.Process, run the compiler
against the c++ code, retrieve the GCC/Clang errors, and map the
line and columns from the compiler back into the stitch line and
columns. We then output the errors, but using the stitch line and
column numbers (presumably the column remains unchanged, or perhaps
we should just remove it).</li>
</ul>

<p>
Ideally we want to preserve the original compiler output as much as
possible, only interfering with the mapping. We should also make sure
we only map lines in the template file, ignoring everything else.
</p>

<p>
We will also have to reactivate the weaving mode, so this will require
a bit of thinking:
</p>

<ul class="org-ul">
<li>we only want to weave a single template; however, in the new world,
that is actually equivalent to weaving the entire model because we
need to go through all of the transforms.</li>
<li>this also means we may end up with lots of errors from other
templates. We need to avoid this.</li>
</ul>

<p>
This should be implemented via LSP delegation (look for story on
this).
</p>
</div>
</div>

<div id="outline-container-orgdc4e024" class="outline-4">
<h4 id="orgdc4e024"><span class="section-number-4">5.8.79</span> Consider adding TableGen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-79">
<p>
Its not entirely clear how one would use this but since its code
generation, we've added a story here. From the docs:
</p>

<pre class="example" id="orge9e6d15">
TableGens purpose is to help a human develop and maintain records of
domain-specific information. Because there may be a large number of
these records, it is specifically designed to allow writing flexible
descriptions and for common features of these records to be factored
out. This reduces the amount of duplication in the description,
reduces the chance of error, and makes it easier to structure domain
specific information.

The core part of TableGen parses a file, instantiates the
declarations, and hands the result off to a domain-specific backend
for processing.

The current major users of TableGen are The LLVM Target-Independent
Code Generator and the Clang diagnostics and attributes.
</pre>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://llvm.org/docs/TableGen/">https://llvm.org/docs/TableGen/</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4752b52" class="outline-4">
<h4 id="org4752b52"><span class="section-number-4">5.8.80</span> Consider adding support for TOML&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-80">
<p>
<a href="https://github.com/toml-lang/toml">TOML</a> (Tom's Obvious, Minimal Language) is a configuration file
format. Its very similar to INI files.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/marzer/tomlplusplus/">toml++</a>: header-only toml parser and serializer for C++17, C++20 and
whatever comes after.</li>
<li><a href="https://github.com/ToruNiina/toml11">toml11</a>: TOML for Modern C++</li>
<li><a href="https://github.com/skystrife/cpptoml">cpptoml</a>: cpptoml is a header-only library for parsing TOML</li>
<li><a href="https://www.reddit.com/r/cpp/comments/f70io2/toml_a_toml_parser_and_serializer_for_c17/">reddit discussion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org39ca249" class="outline-4">
<h4 id="org39ca249"><span class="section-number-4">5.8.81</span> Consider integration with GNU plot library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-81">
<p>
For certain models which produce time-series data, it may make sense
to integrate with GNU plot to generate graphs. In fact, in general, it
would be nice if one could decide to serialise a type into a GNU Plot
graph. We need to find specific examples.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/vincent-picaud/GnuPlotScripting">GnuPlotScripting</a>: A simple C++17 lib that helps you to quickly plot
your data with GnuPlot</li>
</ul>
</div>
</div>

<div id="outline-container-org8b7b232" class="outline-4">
<h4 id="org8b7b232"><span class="section-number-4">5.8.82</span> Consider adding JSON schemas and XSDs as an injection source&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-82">
<p>
Similar to XSD, perhaps JSON schemas could also be used to inject
models into Dogen. This could be useful in the context of the Open API
specification.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-00">JSON Schema: A Media Type for Describing JSON Documents</a></li>
<li><a href="https://cswr.github.io/JsonSchema/spec/introduction/#json">JSON schema introduction</a></li>
<li><a href="https://www.json.org/json-en.html">JSON spec</a></li>
<li><a href="http://json-schema.org/">JSON Schema</a>, <a href="https://modeling-languages.com/jsonschema-uml-tool-generate-diagrams-json/">JSONSchema To UML</a></li>
<li><a href="https://jsonnet.org/">jsonnet</a></li>
<li><a href="https://json-schema.org/learn/miscellaneous-examples.html">JSON schema examples</a></li>
<li><a href="https://github.com/aspnet/Home/wiki/Project.json-file">Project.Json</a></li>
<li><a href="https://github.com/json-schema-org/JSON-Schema-Test-Suite">JSON-Schema-Test-Suite</a></li>
<li><a href="https://github.com/pboettch/json-schema-validator">json-schema-validator</a>: JSON schema validator for JSON for Modern C++</li>
</ul>
</div>
</div>

<div id="outline-container-org8ee78a8" class="outline-4">
<h4 id="org8ee78a8"><span class="section-number-4">5.8.83</span> Consider generating SSL certificates and keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-83">
<p>
When creating an HTTPS service, one needs to have certificates,
etc. It would be nice if dogen could create self-signed certificates,
or added support for Lets encrypt. This could be done via integration
with OpenSSL library.
</p>
</div>
</div>

<div id="outline-container-org06ce721" class="outline-4">
<h4 id="org06ce721"><span class="section-number-4">5.8.84</span> Add support for terraform&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-84">
<p>
Terraform is a Infrastructure as Code (IaC) language. We should be
able to model most of its concepts into the assets meta-model
(modules, variables, <code>main.tf</code>, etc). In an ideal world, the user
should be able to add a model with terraform elements and generate the
IaC for it.
</p>

<p>
For extra bonus points we should integrate the CI (travis, etc) with
the IaC. We should also have a policy of naming for environments
etc. This could be part of a theme.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Terraform_(software)">Terraform Wikipedia</a></li>
<li><a href="https://www.terraform.io/docs/configuration/syntax.html">Terraform: Configuration Syntax</a></li>
<li><a href="https://www.terraform.io/docs/configuration/index.html">Configuration Language</a></li>
<li><a href="https://github.com/syohex/emacs-terraform-mode">terraform emacs mode</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6860b22" class="outline-4">
<h4 id="org6860b22"><span class="section-number-4">5.8.85</span> Consider using ditaa&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-85">
<p>
Ditaa is a diagramming tool that takes ascii art and creates
diagrams. It could be useful as an injector or as an output technical
space.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://ditaa.sourceforge.net/">http://ditaa.sourceforge.net/</a></li>
<li><a href="http://plantuml.com/ditaa">http://plantuml.com/ditaa</a>: integration with Plant UML.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcf8bf04" class="outline-4">
<h4 id="orgcf8bf04"><span class="section-number-4">5.8.86</span> Consider adding a wt frontend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-86">
<p>
Once we have the relational model hooked in, the next step is to make
use of the available information in the database. We will start with
simple PL/SQL scripts etc but this is a cumbersome way of
understanding the data. It would be really nice to have a wt interface
to visualise all the information in the database such as the transform
graph.
</p>

<p>
Ideas:
</p>

<ul class="org-ul">
<li>we could create a baobab like graph, if it is available in wt, to
show the cost of each transform.</li>
<li>we could also display the associated log lines with each transform
and have a "filtering function" that uses postgres' text search.</li>
<li>we could also add the transform graph. The ideal scenario would be
to have an interactive graph with weighted sizes for each transform
and chain, and allow users to click on a chain to see its
components.</li>
<li>we can start making comparisons of run duration per target model,
per operation. We can even make sure we are comparing like with like
because we can see what the initial options were - though it is a bit
harder to tell if the model configuration is comparable. This could
be achieved by diffing the variability models&#x2026;</li>
<li>we need a screen that captures the "element lifecycle" across all
stages of the pipeline, and can be drilled down to individual
transforms. Even better would be to be able to see the "before" and
"after" state of the element. In an ideal world, the JSON in the
database would be formatted so that we can run a quick diff (DTL
would do) on the before and after. This way we can quickly validate
that a given model element was processed correctly all the way until
generation.</li>
<li>it would be nice to have a graph that shows how a given injection
element was converted to a number of assets elements and these into
a number of artefacts. Perhaps a tree is better to display this?
Maybe there are several "tree views": the assets view, the injection
view, the "extraction view" and the tree represents the model for
that view?</li>
<li>we should have a log viewer that enables us to see the log
entries. This could be just a flat log viewer, or a transform graph
based log viewer. In this case it would have the transform tree on
the left and as the user selects nodes the log lines would narrow to
the current transform or transform chain. The log view should have
filters and be searchable. It should make errors and warnings very
easy to spot and allow filtering on those as well (e.g. log level
filter). For log lines with JSON, it would be nice to be able to
detect the JSON by looking at object markers (e.g. <code>{}</code>, <code>[]</code>, etc)
and extract the JSON out of the log line and format it. An
interactive JSON widget would be even better.</li>
<li>it would be nice to have a "validation checks view", where we could
see all of the checks that were performed and their result. These
are the checks that one day will be converted to errors and warnings
to output to end users by the command line.</li>
<li>use injection elements as a filter: it may be nice to have a list of
all injection elements and then only display those which are
selected. The idea would be that the user would have a "complete
view" on the right with all transforms, etc - but only the assets
and extraction elements that are associated with selected injection
elements are displayed. This would make troubleshooting much easier.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Charts in site</b>
</p>

<p>
When we have a dogen site with code-generation functionality, we could
allow users to produce transform probe data. This could be stored in
redis. We could then have a json diff in the site. We could also have
a visualisation like baobab with a tree on one side and a graph
breaking down the time. And even more ideal would be if we could see
all log lines from the start and end transform.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nlohmann/json">JSON</a>: C++ JSON library that supports the json diff spec.</li>
<li><a href="https://wiki.gnome.org/Apps/Baobab">baobab screenshot</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5cc07a8" class="outline-4">
<h4 id="org5cc07a8"><span class="section-number-4">5.8.87</span> Consider using typedefs for variants&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-87">
<p>
When we create types that have variants, the generated code is really
awkward. It would be nice if users could create typedefs that are used
internally in the class using the variant (and possibly
everywhere?). We need support for typedefs as a meta-model element
first.
</p>
</div>
</div>

<div id="outline-container-org478376e" class="outline-4">
<h4 id="org478376e"><span class="section-number-4">5.8.88</span> Investigate if Seamless template can be used instead of stitch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-88">
<p>
According to their project:
</p>

<div class="epigraph"><blockquote>
<p>
Seamless (CMLS) is a brand-spanking new experimental web framework. It
includes:
</p>

<ul class="org-ul">
<li>A C++20 template engine that allows you to write C++ and markup in
the same file, just like you would with Laravel's blade engine for
PHP, or ASP.NET Razor. The file extension for these files is .cmls.
&#x2026;</li>
</ul>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/haikarainen/cmls">cmls</a></li>
</ul>
</div>
</div>

<div id="outline-container-org198491f" class="outline-4">
<h4 id="org198491f"><span class="section-number-4">5.8.89</span> Consider adding support for OData&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-89">
<p>
OData is defined as follows:
</p>

<div class="epigraph"><blockquote>
<p>
OData (Open Data Protocol) is an ISO/IEC approved, OASIS
standard that defines a set of best practices for building and
consuming RESTful APIs. OData helps you focus on your business logic
while building RESTful APIs without having to worry about the various
approaches to define request and response headers, status codes, HTTP
methods, URL conventions, media types, payload formats, query options,
etc. OData also provides guidance for tracking changes, defining
functions/actions for reusable procedures, and sending
asynchronous/batch requests.
</p>

</blockquote></div>

<p>
Dogen could generate the schema, the entities in the expected formats
and the end-points. It could also be used to generate the client code
as per examples.
</p>

<p>
Note that there are a lot of similarities between GraphQL and OData so
we should look at these two stories at the same time to make sure we
capture the commonalities.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.odata.org/">OData</a></li>
<li><a href="https://www.odata.org/documentation/">OData documentation</a></li>
<li><a href="https://stackoverflow.com/questions/32858371/what-is-swagger-and-does-it-relate-to-odata">What is Swagger and does it relate to OData?</a></li>
<li><a href="https://github.com/OData/odatacpp-server">odatacpp-server</a>: github project for an OData server.</li>
<li><a href="https://github.com/OData/odatacpp-client">odatacpp-client</a>: github project for an OData client.</li>
<li><a href="https://www.odata.org/getting-started/basic-tutorial/">OData: Basic Tutorial</a></li>
<li><a href="https://jeffhandley.com/2018-09-13/graphql-is-not-odata">GraphQL is not OData</a></li>
<li><a href="https://github.com/microsoft/cppgraphqlgen">cppgraphqlgen</a></li>
<li><a href="https://taocpp.github.io/">A collection of high-quality C++ libraries</a></li>
<li><a href="https://github.com/taocpp/PEGTL">PEGTL</a>: library used to generate a parser for GraphQL.</li>
</ul>
</div>
</div>

<div id="outline-container-orgccb995e" class="outline-4">
<h4 id="orgccb995e"><span class="section-number-4">5.8.90</span> Consider adding support for BERT&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-90">
<p>
It seems this is yet another RPC framework:
</p>

<div class="epigraph"><blockquote>
<p>
BERT and BERT-RPC are an attempt to specify a flexible binary
serialization and RPC protocol that are compatible with the
philosophies of dynamic languages such as Ruby, Python, PERL,
JavaScript, Erlang, Lua, etc.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://bert-rpc.org/">specification</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge7b45ae" class="outline-4">
<h4 id="orge7b45ae"><span class="section-number-4">5.8.91</span> LSP daemon for MOP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-91">
<p>
One of the problems we have when creating models is that there is no
assistance from the editor. At present, because we are using either
JSON or Dia, this is more or less expected - though conceivably, one
can imagine some python extensions into Dia to make the modelers' life
easier. In the future, when we finally settle on a MOP frontend such
as text UML, what would be ideal is a full blown LSP mode (we already
have <a href="#org292e944">a story for MOP</a>).
</p>

<p>
LSP use cases:
</p>

<ul class="org-ul">
<li>completion:
<ul class="org-ul">
<li>when adding attributes, we need completion based on the models
referenced.</li>
<li>when setting stereotypes, we need completion based on the profiles
and object templates that have been defined.</li>
<li>when typing meta-data keys, we need completion based on the
feature model, and taking into account the binding types of each
feature. In addition, if the feature is linked to an enumeration,
we also need a way to see what the valid values are.</li>
<li>when adding a reference, a list of all of the referenceable
models, given the current include paths.</li>
</ul></li>
<li>find usages:
<ul class="org-ul">
<li>given a model element, find all of its uses in the models.</li>
<li>given a model element, find all of its uses in the generated and
handcrafted code, with the ability to choose (both, handcrafted,
generated).</li>
</ul></li>
<li>find definition:
<ul class="org-ul">
<li>given a model element usage, take me to its definition.</li>
<li>given a model reference, take me to its definition.</li>
</ul></li>
<li>hierarchies (treemacs support):
<ul class="org-ul">
<li>list all of the model elements in a model as a tree, with their
attributes.</li>
<li>follow current position in the tree.</li>
</ul></li>
<li>syntax checker:
<ul class="org-ul">
<li>for models, highlight lines where there are errors and warnings.</li>
<li>needs the ability to parse invalid models.</li>
<li>diagnostics and code actions (clang FixIts). This is useful for
levenshtein-like errors in spelling.</li>
<li>for stitch templates, highlight lines where there are errors and
warnings at the stitch level; map errors from C++ code back into
the stitch location by calling out to clang somehow. There is
already a story for this.</li>
</ul></li>
<li>symbol rename:
<ul class="org-ul">
<li>given a symbol, rename all of its uses across all referenced
models. For extra bonus points, also rename them in the generated
language.</li>
</ul></li>
<li>documentation:
<ul class="org-ul">
<li>bring up documentation for symbol at point.</li>
</ul></li>
</ul>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we probably will need a separate git repo for the language server,
as we are running out of resources on our travis builds. We will
need a lot of extra code to implement the language server because
the data structures are completely different from how we are
querying the data at present - though we can probably reuse a large
number of the transforms.</li>
<li>we should look at existing c++ language servers to see if we can
reuse or steal some of their ideas. In particular, the protocol
implementation part should be common to all servers (messages,
etc). We should be able to create a simple library with model types
that implement the messages and the request/response interactions
without binding it to the dogen specific logic.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a></li>
<li><a href="http://llvm.org/viewvc/llvm-project/clang-tools-extra/trunk/clangd/">clangd</a></li>
<li><a href="https://github.com/cquery-project/cquery">cquery</a></li>
<li><a href="https://github.com/MaskRay/ccls">ccls</a></li>
</ul>
</div>
</div>

<div id="outline-container-org73b0280" class="outline-4">
<h4 id="org73b0280"><span class="section-number-4">5.8.92</span> Add design by contract to code-base&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-92">
<p>
We should really declare pre/post conditions, etc in Dogen. This can
either be done using C++ 20 when we upgrade or an already existing
library such as <a href="https://www.boost.org/doc/libs/1_70_0/libs/contract/doc/html/index.html">Boost.Contract</a>. The only slight problem is that
libraries have very macro based syntax whereas C++ 20 has proper
attribute support, making the code look much nicer.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://speakerdeck.com/rollbear/accu2019-programming-with-contracts-in-c-plus-plus-20">Programming with contracts in C++ 20</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgaf88e50" class="outline-4">
<h4 id="orgaf88e50"><span class="section-number-4">5.8.93</span> Improving boost test support with org-mode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-93">
<p>
This story is somewhat random at present but there is a kernel of
usefulness to it. At present we are using <a href="https://github.com/sgoericke/boost-test">boost-test mode</a> in emacs to
run boost tests and visualise a test report. This mode has its
shortcomings - its more of a report viewer. In an ideal world, we
would like to have an org-mode file with all test suites in a given
product, and then with the output of each test suite inside a
tree. Then, we need some kind of way to execute nodes of the
tree. Org-mode has <a href="https://orgmode.org/worg/org-contrib/babel/intro.html">babel support</a> for this. Thing is dogen may help
code-generate this org-mode file:
</p>

<ul class="org-ul">
<li>dogen is alreay aware if boost test is being used or not. Dogen also
knows of all projects in a product.</li>
<li>at present we are using a hacked CMake macro to detect tests and add
them to CTest. A better way would be to have dogen code generate the
code to do this. This code could also be used to generate the
org-mode file. We could even make use of top-level arguments such as
<code>log_level</code>, etc. These are set at the model level.</li>
<li>another way of looking at the problem is to create a separate tool
that takes the boost.test XML and uses it to create the org-mode
file. The advantage is that we can then take into account things
like timings, etc. It is also dogen independent. We could create an
XSD for the XML and then use XSD tool to generate C++ code for
it. The tool would then be responsible for converting the result to
an org file. Dogen could be responsible for creating a "project
file" telling the tool about the location of the tests (though its
not clear how it would know about this).</li>
<li>we could use labels for generated tests, or add them to a separate
tree.</li>
<li>you can execute all blocks using <code>org-babel-execute-buffer</code>.</li>
<li>if we could have a "test location" variable somewhere in the
org-file, we could create a single org-mode file and then execute it
against the different configurations.</li>
<li>we could look into how boost-test parses the XML; maybe the output
of boost test could be parsed and used to compute things in the
org-mode file such as pass/fail, timings, etc. We could even build a
org-mode table with the timings at each level: product, test suite,
etc.</li>
<li>for extra bonus points we could insert file links that take you to
the original c++ file for the test, test suite etc.</li>
</ul>

<p>
Actually a much easier way to do this does not involve dogen at
all. We could simply create a transform from the XML output of test
unit frameworks into org-mode. You could call the "dumper" against the
output of the tool and it would produce an org-mode file which is able
to execute the tests and get the output of the tests. It should also
be able to mark tests as pass or fail. Dogen could then also comply
with this format, if required, but this is more or less
orthogonal. This could be its own product, where the domain of the
product is a uniform format for unit testing data:
</p>

<ul class="org-ul">
<li>injector models: boost test, nunit, etc.</li>
<li>core model: models unit test frameworks in generat.</li>
<li>extraction: org-mode.</li>
</ul>

<p>
Then, from emacs you could call this utility the first time to build
the org-mode files per unit test framework. The interesting thing
about this is that you could use the org-mode document as
documentation for the unit tests. These could then generate HTML/Latex
files without the test results. The key thing is that check-ins to git
should be done without the output of the unit tests. We should also
have variables pointing to the different output locations (it should
integrated with the build system).
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://fgiasson.com/blog/index.php/2016/05/30/creating-and-running-unit-tests-directly-in-source-files-with-org-mode/">Creating and Running Unit Tests Directly in Source Files with Org-mode</a></li>
<li><a href="https://github.com/structureddynamics/org-mode-clj-tests-utils">Clojure test utilities for Org-mode</a></li>
<li><a href="https://irreal.org/blog/?p=5297">Running Unit Test with Org Mode</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4d6a659" class="outline-4">
<h4 id="org4d6a659"><span class="section-number-4">5.8.94</span> Consider splitting transforms into rules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-94">
<p>
According to MDE, transforms are split out into several parts:
</p>

<ul class="org-ul">
<li>the filtering of the targets of the transform.</li>
<li>the application of the transform.</li>
</ul>

<p>
For example, we seem to loop through the model and then find elements
of interest to mutate. They seem to suggest we should first
query/filter the model using a rule and then apply the mutation to the
result of the query/filter. This would perhaps improve the code. The
query result could be a typed container (pointer container?) with the
elements that match. That means we can then start to converge towards
a rule engine. However, we'd have to go through all the transforms and
see if they would all benefit from this split.
</p>

<p>
We don't really have a need for a flexible rules application engine
that schedules rules and so forth, but we could take on the aspects
that make the code cleaner.
</p>

<p>
In <a href="https://gsd.uwaterloo.ca/sites/default/files/ibm06.pdf">Feature-Based Survey of Model Transformation Approaches</a>, Czarnecki
and Helsen state:
</p>

<div class="epigraph"><blockquote>
<p>
Transformation rules. In this paper, transformation rules are
understood as a broad term describing the smallest units of
transformation. Rewrite rules with a left-hand side (LHS) and a
right-hand side (RHS) are obvious examples of transformation rules;
however, we also consider a function or a procedure implementing some
transformation step as a transformation rule. In fact, the boundary
between rules and functions is not so clear-cut;
</p>

</blockquote></div>

<p>
Notes:
</p>

<ul class="org-ul">
<li>our source-target relationship is chosen based on the needs of the
transform. Sometimes we use in-place, in other cases (such as
merging and translation) we use distinct source and targets. We
should probably add comments to each transform describing these
properties.</li>
<li></li>
</ul>
</div>
</div>

<div id="outline-container-orgb85144f" class="outline-4">
<h4 id="orgb85144f"><span class="section-number-4">5.8.95</span> Create a new data-driven architecture for dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-95">
<p>
We finally found a good model for the data in dogen, and its based on
data driven design. Basically, we need to let go of OOP constructs
that aggregate data that is logically related from a human perspective
and start to think of data usage patterns. From this perspective,
there is no such thing as a modeling element - just a scattering of
properties that are used by different transforms all the way into text
transformation. Even text transforms don't really operate on
elements - they operate on specific element properties. If we segment
the text transforms this way, we end up with a large number of small
text transforms, each with very specific tasks, generating chunks of a
file. Finally, at the end, we need to concatenate these chunks to form
the end product. With this approach we solve the impedance mismatch
between the modeling model and the generational model - all we now
have are additional containers with properties. This also means that
its much easier to have different models further down the pipeline
because they are just adding more properties. We can even use
inheritance for this, e.g. generational model inherits from modeling
model and adds properties x, y, z; generational cpp model inherits
from generational model and so forth. As an example, instead of
generating the decoration properties for every artefact, we now split
all elements into two groups: those that have "standard" decoration
properties and those that have overriden decoration properties. We
then generate these two groups. For those sharing the common
decoration properties, we insert those in their vector X times. This
is still not the most efficient (we really only need one copy) but its
orders of magnitude (at least one) faster than the current
approach. Similarly with namespaces: we only need to do the namespaces
once for all types in a facet.
</p>

<p>
However, we are very far from this at present.
</p>

<p>
Merged stories:
</p>

<p>
<b>Evaluate all of our data structures based on usage</b>
</p>

<p>
This presentation is very interesting:
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v%3DrX0ItVEVjHc">CppCon 2014: Mike Acton "Data-Oriented Design and C++"</a></li>
</ul>

<p>
The presenter makes a lot of points that are directly applicable to
Dogen. The main one is that we need to look at all the data structures
to see how they are used, and to try to extract deeply nested if's
that in many cases can easily be extracted from the bottom and moved
to the top. There are many other excellent points, we probably need to
watch the presentation again and write each of them down.
</p>

<p>
The key point though is that the re-engineering exercise should only
be done after we finished all of the current refactorings - we must
make sure the code does all that it is intended to do first and then
tackle the Acton's suggestions. This is to ensure that we have
captured all the main use cases. Data analysis can be done after this.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=yy8jQgmhbAU">CppCon 2018: Stoyan Nikolov OOP Is Dead, Long Live Data-oriented
Design</a></li>
<li><a href="https://en.wikipedia.org/wiki/Data-oriented_design">Data-oriented design</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgce48674" class="outline-4">
<h4 id="orgce48674"><span class="section-number-4">5.8.96</span> Support for locations other than filesystems&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-96">
<p>
It would be nice to be able to point to an injection model anywhere,
such as for example in github and generate it. For this we just need
to detect the protocol in the path and if supported, read in the file;
the frontend implementations should take in a stream rather than a
file path. For cases such as LibXML, we may need to read up all of the
data first and then create a stringstream for it.
</p>

<p>
We should not implement this story unless we need it such as for
example when we have a site/service. At that point it would be nice to
allow users to just point to their models in github. This could be
done when we add support for <code>-I</code> to Dogen.
</p>
</div>
</div>

<div id="outline-container-orgb96abfb" class="outline-4">
<h4 id="orgb96abfb"><span class="section-number-4">5.8.97</span> HTTP API support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-97">
<p>
It should be possible to define a few classes in a diagram, annotate
them as HTTP and have dogen generate all of the restful
infrastructure. We should take a similar approach to ServiceStack.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>the user should supply the routes as meta-data against each object,
as well as the HTTP verbs supported (PUT, GET, etc).</li>
<li>we should also allow the user to pair request and responses
DTOs. This is also done via meta-data.</li>
<li>the user should also define a top-level service class, with the
comments that are to be displayed on the web-page that we
automatically generate. The attributes of the service are the DTOs
it supports. However, since the service contains the implementation,
we can't code generate it really. We could either treat it as a
concept or create an interface for it that the user has to
implement. We could use the "lambda approach": the user just has to
initialise the generated code by supplying lambdas that do the
processing; we automatically generate all of the HTTP
machinery. However, we then have to worry about state.</li>
<li>we should support both XML and JSON via the same API as service
stack:</li>
</ul>

<pre class="example">
http://localhost:/students?format=json
</pre>


<ul class="org-ul">
<li>it should support multiple backends, chosen via meta-data. Example:
casablanca/RestSDK, Boost.Beast.</li>
<li>things like hostname, port etc must be handled outside the generated
code.</li>
<li>insane idea: we can use stitch templates to generate HTML just like
with razor. Example razor template:</li>
</ul>

<pre class="example">
@using StudentReports.Models
@inherits ViewPage&lt;ienumerable&lt;student&gt;&gt;

@{
    ViewBag.Title = "Student List";
}

&lt;div class=""row""&gt;
    &lt;div class=""panel" panel-default"=""&gt;

                @{
                    foreach (var item in Model)
                    {

                    }
                }
</pre>


<ul class="org-ul">
<li>if we use stitch this means we can define classes (or even profiles)
and associate them with stitch and wale templates just like we do
with formatters. We then generate code to bind these to the API. The
objective is to make an interactive view of the API, not to replace
Wt. We could also use mustache templates for simple cases. There is
also static sites generation (see hugo, etc).</li>
<li>actually, we should definitely not use stitch for this. We want to
use a specialised library that is well maintained with lots of use
cases outside of dogen. Example: <a href="https://github.com/pantor/inja">inja</a></li>
<li>we should generate the swagger interactive interface as they do for
the <a href="https://petstore.swagger.io/">petstore</a>.</li>
<li>we should also allow users to add documentation for the API,
including introduction, examples etc. This should be done in
Markdown format and follow the same layout as for <a href="https://www.consul.io/api/index.html">Hashicorp</a>.</li>
<li>our logical model elements should probably follow the latest ASP MVC
API. It seems simple enough. Controllers are the top-level handler
of a URL. They are associated with a number of API versions. This
should be handled by Dogen versioning (see story on this for the
POCO types). Each method of the controller is associated with an
HTTP verb (GET, etc) and a route. It also may be associated with
permissions.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.dotnetcurry.com/aspnet/1056/introducing-service-stack-tutorial">Introducing ServiceStack</a></li>
<li>See also the story on Swagger/OpenAPI</li>
<li><a href="https://docs.microsoft.com/en-gb/teamblog/announcing-rest-improvements">Announcing Updates to the REST API Experience</a>: microsoft has created
a centralised place to try all REST APIs. We should be able to code
generate something similar. However, we need a way to create a
single site with all APIs - this is not so easy because we'd have to
load up shared objects from different models. It would be nicer to
have some kind of tree with all the products on the left and then
all of the internal APIs for each product (perhaps grouped by
top-level functionality?). Then, when you click on a request you get
the documentation for the end point as well as an interactive "try
it" environment. This should work even without a login. The MSFT
documentation includes a description of all of the returned types as
well as the input parameters and the return codes. These contain
documentation from the types and their attributes. The graph is
expanded to aggregate types so that there is a link to the aggregate
type. Primitive types have their documentation inline. We have two
options for the API browser: either have a product that is
responsible for it and each product has a serialised description of
their APIs, or have a <code>webapi.browser.PRODUCT</code> for each product that
is code-generated.</li>
<li><a href="https://docs.microsoft.com/en-gb/rest/api/?WT.mc_id=docsmsft-blog&amp;view=Azure">REST API browser</a></li>
<li><a href="https://docs.microsoft.com/en-gb/rest/api/appservice/webapps/list">Web Apps - List</a></li>
<li><a href="https://github.com/cpp-netlib/cpp-netlib">cpp-netlib GitHub</a></li>
<li><a href="https://github.com/boostorg/beast">Boost.Beast GitHub</a></li>
<li><a href="https://github.com/microsoft/cpprestsdk">C++ Rest SDK</a></li>
<li><a href="https://github.com/omartijn/cpprouter">cpprouter GH</a>: A modern, header-only request router for C++. Can be
used with Beast.</li>
<li><a href="https://github.com/an-tao/drogon">drogon GH</a>: C++14/17-based HTTP application framework. Drogon can be
used to easily build various types of web application server
programs using C++.</li>
<li><a href="https://gitlab.com/eidheim/Simple-Web-Server/">Simple-Web-Server GL</a>: A very simple, fast, multithreaded, platform
independent HTTP and HTTPS server and client library implemented
using C++11 and Asio (both Boost.Asio and standalone Asio can be
used).</li>
<li><a href="https://www.techempower.com/benchmarks/#section=data-r19&amp;hw=ph&amp;test=composite">Benchmarks Composite scores</a>: benchmarks for several web frameworks.</li>
<li><a href="https://github.com/matt-42/lithium">lithium GH</a>: Lithium's goal is to ease the development of C++ high
performance HTTP APIs.</li>
<li><a href="https://github.com/yhirose/cpp-httplib">cpp-httplib GH</a>: A C++11 single-file header-only cross platform
HTTP/HTTPS library.</li>
<li><a href="https://github.com/blockspacer/CXTPL">CXTPL GH</a>: "Template engine with full C++ power (transpiles template
into valid C++ code, supports Cling, etc.)."</li>
</ul>
</div>
</div>

<div id="outline-container-org1f168ac" class="outline-4">
<h4 id="org1f168ac"><span class="section-number-4">5.8.98</span> Consider generating consul service discovery code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-98">
<p>
Once we support services, we should also generate service discovery
code. We could use an implementation such as consul for this. There
are several C++ libraries that support consul, see other story on
consul.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.consul.io/discovery.html">Consul - Service discovery made easy</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf8f122" class="outline-4">
<h4 id="orgdf8f122"><span class="section-number-4">5.8.99</span> Grepping non-generated code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-99">
<p>
In order to determine if a type is no longer used, it would be really
useful to grep non-generated code. This could be an option in dogen
itself: given a project or set of projects, it determines the list of
non-generated files and then runs grep on those.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>this could be implemented as an activity, e.g. <code>grep</code>. It would take
as input either a model, a project or a directory with models; it
would load up all models, figure out the list of handcrafted files
and then run grep on those.</li>
<li>we probably need specific transform chains for these, to avoid doing
lots of unnecessary work. However, unpicking transforms won't be
trivial.</li>
<li>think of code as a graph, where handcrafted files are leaves and
generated files are non-leafs. In fact, it probably makes more sense
to generate a graph using dot which highlights all of the entities
which are not reached by non-generated entities. This is a bit
tricky because we may make use of an entity in regular C++ code, so
we will need something like LSP to produce a list of "types used" by
a given type.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_61_0/libs/regex/example/grep/grep.cpp">Grep in c++ using boost regex</a></li>
<li><a href="https://unix.stackexchange.com/questions/494595/how-can-i-search-a-specific-list-of-files-with-ripgrep">How can I search a specific list of files with ripgrep?</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcd500df" class="outline-4">
<h4 id="orgcd500df"><span class="section-number-4">5.8.100</span> Add support for data anonymisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-100">
<p>
If users could mark certain fields as "sensitive", we could use test
data generation for them. The process would be as follows:
</p>

<ul class="org-ul">
<li>mark certain fields in a model as sensitive. Names, addresses, etc.</li>
<li>provide a anonymiser facet. For each field, it creates a map using
the appropriate test data source for the field. The map is important
so that each original value corresponds to one and only one mapped
value, thus preserving the properties of the original data. Users
supply a graph of objects to anonymise.</li>
<li>anonymised data can now be serialised and supplied as test
data. Dogen itself can use this framework. See "Model anonymizer and
slicer".</li>
</ul>
</div>
</div>

<div id="outline-container-org90ebcc7" class="outline-4">
<h4 id="org90ebcc7"><span class="section-number-4">5.8.101</span> Consider using indices rather than associative containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-101">
<p>
Once we generate the final model the model becomes constant; this
means we can easily assign an <a href="https://en.wikipedia.org/wiki/Ordinal_number">ordinal number</a> to each model
element. These could be arranged so that we always start with
generatable types first; this way we always generate dense
containers - there are some cases where we need both generatable types
and non-generatable types; in other cases we just need generatable
types; we never need just non-generatable types. We also need to know
the position of the first non-generatable type (or alternatively, the
size of the generatable types set).
</p>

<p>
Once we have this, we can start creating vectors with a fixed size
(either total number of elements or just size of generatable
types). We can also make it so that each name has an id which is the
ordinal (another model post-processing activity). Actually we should
call it "type index" or some other name because its a transient
id. This means both properties and settings require no lookups at all
since all positions are known beforehand (except in cases where the
key of the associative container must be the <code>yarn::name</code> because we
use it for processing).
</p>

<p>
In theory, a similar approach can be done for formatters too. We know
upfront what the ordinal number is for each formatter because they are
all registered before we start processing. If formatters obtained
their ordinal number at registration, wherever we are using a map of
formatter name to a resource, we could use a fixed-size
vector. However, formatters may be sparse in many cases (if not all
cases?). For example, we do not have formatter properties for all
formatters for every <code>yarn::name</code> because many (most) formatters don't
make sense for every yarn type. Thus this is less applicable, at least
for formatter properties. We need to look carefully at all use cases
and see if there is any place where this approach is applicable. It is
probably going to be more useful for formatters than elements.
</p>

<p>
Tasks:
</p>

<ul class="org-ul">
<li>in resolver, assign element indices and update property names with
them.</li>
<li>change final model to have a vector of size maximum index (a
property of the intermediate model).</li>
<li>in the final model generation, for each type, look at its index and
populate the slot accordingly.</li>
<li>update quilt to use the indices where possible.</li>
</ul>
</div>
</div>

<div id="outline-container-org292e944" class="outline-4">
<h4 id="org292e944"><span class="section-number-4">5.8.102</span> Model Oriented Programming&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-102">
<p>
There is a type of programming called MOP - Model Oriented
Programming. Umple seems to be the main language implementing
MOP. Some of the ideas of MOP are quite interesting: to develop a
modeling language that can be used just like regular code. This would
be ideal for Dogen because we are using UML diagrams with lots of
extensions to be ale to convey the full Dogen DSL. Instead, we could
create a MOP lanugage that is the dogen DSL:
</p>

<pre class="example">
import "my_profile";
import "model_a";
import "model_b";

traits {
    internal trait Definable {
        facet cpp.types {
            option default_constructor = 1;
        }
    }

    internal trait Serialisable {
        comments "Model type can be serialised."
        facet cpp.serialisation.boost {
            option with_xml = 1;
        }
    }

    internal trait SomeTrait {
        inherit Definable, Serialisable;
</pre>

<p>
;     }
</p>
<pre class="example">
}

model my_model {
    name a;
    external_modules b.c;
    model_modules d.e;
    input_language cpp;
    output_language cpp; # or just language cpp;
    type generatable; # or proxy, defaults to generatable.
    target executable; # library
    using profile p1;

    module a_module {
        using profile p2;
        enumeration my_enum {
            comments "My enumeration";
            type int;
            enumerators {
                a = 1,
                b = 2
            }
        }

        public object my_object {
            immutable; # defaults to mutable
            comment "This is an object";
            using profile p2; # override global profile
            generation handcrafted;
            concepts c1, c2;
            parents o2;
            using traits types, serialisation, hashing; # using abstract facets, relies on mapping
            using traits types.cpp; # using concrete facets.
            public property p1 {
                comments "my property";
                type int;
            }
            public method a(in std::list&lt;std::string&gt; l) returns std::string;
        }
    }
}
</pre>


<p>
The language could have profiles as first class citizens and support
includes. This would make sharing profiles across models much easier,
and also defining a product (just include all models into the
product).
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>its not obvious that there are a lot of advantages over plain
JSON. At present: 1) language could have support for comments, 2)
inclusion in JSON is not obvious 3) the syntax can be made
specifically to fit our DSL (for example, we could force that files
must start with <code>model</code>, or <code>product</code> or <code>profile</code> and not require
<code>{}</code> for these elements). An alternative to JSON which could be more
suitable is <a href="https://github.com/toml-lang/toml#user-content-example">TOML</a>.</li>
<li>creating a parser for the language will not be trivial.</li>
<li>on the plus side, we can then place the model definition with the
component itself. There is a nice symmetry with source code.</li>
<li>MOP then becomes the DSL for the methodology which is nice from a
MDE perspective.</li>
<li>its not clear there are advantages over org-mode. The latter would
be much more flexible for code-merging for example. Or perhaps we
could still call it MOP - but the AST is org-mode.</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://cruise.eecs.uottawa.ca/umple/">UMPLE Home</a></li>
<li><a href="https://github.com/umple/umple">GitHub repo</a></li>
<li><a href="https://cruise.eecs.uottawa.ca/umple/GettingStarted.html">UMPLE manual</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8e04600" class="outline-4">
<h4 id="org8e04600"><span class="section-number-4">5.8.103</span> Interactive interface to models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-103">
<p>
There are a number of interactive interfaces available such as
Jupiter. It may be interesting to think of ways to generate the
interactive interface automatically from a model. Its not quite clear
what that interface would do: are we updating the model or the
entities it generates? We need to have a much clearer use case before
we start to look into this.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://glench.github.io/fuzzyset.js/ui/">FuzzySet</a>: A Human-Readable Interactive Representation of a Code
Library</li>
<li><a href="https://github.com/QuantStack/xeus-cling">xeus-cling</a>: C++ interface for Jupyter notebooks.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf02ba77" class="outline-4">
<h4 id="orgf02ba77"><span class="section-number-4">5.8.104</span> Consider extending stitch with ideas from Xpand/Xtend&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-104">
<p>
We created our own templating language to make it easy. Stitch works,
but its not as nice as Xpand:
</p>

<ul class="org-ul">
<li>we are mixing C++ and template logic in templates. It would be nice
if templates just had template logic.</li>
<li>Xpand makes the "template methods" more explicit, making variability
regions etc more natural.</li>
<li>it is already a standard language so we can rely on existing
documentation / examples, to an extent.</li>
<li>seems like Xpand has been replaced by Xtend: <a href="http://blog.efftinge.de/2013/06/five-good-reasons-to-port-your-code.html">Five good reasons to
port your code generator to Xtend</a> (presentation included). Xtend has
a lot of interesting features including commands for spacing like
<code>before</code> and <code>after</code>, <code>separator</code> etc. These could be copied and
mapped. We do not need grey space support because we believe pretty
printing is done by a cartridge that knows the language.</li>
</ul>

<p>
Our implementation of Xpand would be a bit special though:
</p>

<ul class="org-ul">
<li>the metamodel is hardcoded to our code generation metamodel.</li>
<li>we would transform Xpand code into C++ code, that would then be
compiled in.</li>
<li>file names would be automatically generated.</li>
<li>there is no assistant, so we need some way to access the things
which are not directly available in the metamodel.</li>
<li>we would have to write a boost::spirit parser for Xpand, which would
keep the template blocks (potentially it could even reuse the stitch
model / abstract syntax).</li>
<li>we would probably have to bastardise Xpand. We can't allow multiple
files on a template, filenames are defined by the framework, we need
support for boilerplate, etc.</li>
<li>we still need support for includes, computed externally. So the
formatter would be made up of the existing formatting code plus the
template. On the plus side we could agument Xpand with the
variability support required so that all functions could have a very
simple predicate based on features being on or off. We could also
have support for inclusion built in, via some commands specifically
designed for it. This would mean we could associate inclusion with
"template methods" so that if a template method is off, the
inclusion will not be added.</li>
<li>so really we could make the template language specifically for our
code generation metamodel, with understanding of facets, features,
etc so that making a template would be very simple. In addition, we
should also have a fixed interface so that the C++ code could define
both the implementation and the interface in the C++, as well as
register itself. Then we could get rid of wale. The objective is for
the generated code to match the code that stitch is generating it at
present.</li>
</ul>

<p>
Changes to the stitch approach:
</p>

<ul class="org-ul">
<li>there is no wale; wale machinery is hard-coded in stitch2. These are
expressed as "template types", either a formatter or a helper.</li>
<li>there are no inclusion dependencies. They are automatically done for
you.</li>
<li>inclusion building is done via DSL extensions. We need to add
commands to the DSL to allow it to support all of the use cases we
identified with stitch.</li>
<li>boilerplate etc are commands in the language. We need a name for
these.</li>
<li>helper commands are commands in the language. For example, instead
of:</li>
</ul>

<pre class="example">
if (a.supports_defaulted_functions()) {
</pre>


<p>
you need to create a predicate for the variability region:
</p>

<pre class="example">
supports_defaulted_functions
</pre>


<p>
these are exposed as part of the API.
</p>

<ul class="org-ul">
<li>variability regions must support <code>ELSEIF</code> predicates.</li>
<li>variability regions may have a comment/description as well as a
name.</li>
<li>variability regions can have a predicate based on a feature
configuration or on any other structural query.</li>
</ul>

<p>
Requirements for the template language:
</p>

<ul class="org-ul">
<li>create templates that are very close to the generated code so that
you can take an existing file and templatise it, or you can look at
an existing template and predict what the generated code will look
like.</li>
<li>produce simple C++ code that any regular c++ developer can debug.</li>
<li>The idea is that the user can take an existing text file and add
some additional metadata and it becomes a template; very low barrier
to entry. In addition, generator should also create a CMakeFile to
create a DLL. All boilerplate code is generated by stitch: DLL entry
points, plugin registration (Boost.DLL), etc. The user simply has to
compile.</li>
</ul>
</div>
</div>

<div id="outline-container-org0c4b61b" class="outline-4">
<h4 id="org0c4b61b"><span class="section-number-4">5.8.105</span> Feature Models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-105">
<p>
Feature Models are a useful way to describe features in a system. If
there was a textual way to describe features, we could link them to
Dogen models. Its not clear at all how this would work.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.boost.org/community/feature_model_diagrams.html">Feature Model Diagrams in text and HTML</a></li>
<li><a href="https://github.com/EmilianoSanchez/Feature-Model-Optimization">Feature-Model-Optimization</a></li>
</ul>
</div>
</div>

<div id="outline-container-org00285fe" class="outline-4">
<h4 id="org00285fe"><span class="section-number-4">5.8.106</span> Make more use of stack instead of heap&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-106">
<p>
We should do some analysis as to how the following classes are being
used:
</p>

<ul class="org-ul">
<li>name</li>
<li>location</li>
<li>achetype location</li>
</ul>

<p>
They are all making a lot of use of the heap. In reality they follow a
very simple usage pattern: we construct them, update them slightly on
resolution and then they remain constant for the rest of program
execution.
</p>

<p>
If we can spot some kind of constraints in terms of sizes, we could
possibly eliminate the use of lists and strings and instead use
<code>std::array</code>. For strings, these can be exposed as
<code>std::string_view</code>. It seems we have a few code-generation patterns:
</p>

<ul class="org-ul">
<li>array of enumerations: we align the enumeration to fit the array
indices and provide some kind of getter that casts the enum into an
int and queries the array. This is the case with the qualified name
map.</li>
<li>stack based strings. This is just a case of receiving a string view
in the constructor, then ensuring we have enough space on the array
to copy across the string, then copying the string across. We could
easily have a setter that receives string views and a getter that
returns the string view based on the array. When a user sets a
property to string view, we automatically generate all the
boilerplate to read and write to the array. The user has to supply
the size of the array (we should offer a sensible default). We need
to look for the correct exception to throw if the string is not big
enough. This approach seems to be useful enough that we should have
some kind of stereotype for it like "stack string" or some such.</li>
<li>the other interesting thing is that we probably have a very limited
number of locations in a model: these will all manifest themselves
as modules. If we somehow could have a handle to the module we
wouldn't have to carry the location with every name.</li>
<li>similarly with name trees, we don't really need to carry all the
name information - really a name tree is more of a tree of
handles. If these handles were indices into an array then we'd have
a very efficient way to perform lookups.</li>
</ul>

<p>
In general, it seems the biggest problem we have is we started of with
an OOP model of the world which is very far from how the data is
actually used. Once we have finished with the current clean-ups we
need to do some analysis on how the data is being used and try to work
out data structures that are more suitable for this. We should also
measure the cache hits / misses before and after the changes, as well
as the memory sizes.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_72_0/libs/beast/doc/html/beast/ref/boost__beast__static_string.html">boost static<sub>string</sub></a>: fixed size string with no dynamic
allocation. We could probably convert these to string views as well.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd08060d" class="outline-4">
<h4 id="orgd08060d"><span class="section-number-4">5.8.107</span> Add support for field renaming in annotations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-107">
<p>
At present if a field changes its name between dogen releases,
diagrams stop working. For example, we renamed:
</p>

<pre class="example">
yarn.dia.external_modules
</pre>


<p>
to
</p>

<pre class="example">
yarn.external_modules
</pre>


<p>
With this change, dogen stopped working. We need some way to
"remember" the previous name before a rename so that previous versions
still work.
</p>
</div>
</div>

<div id="outline-container-org13c6d43" class="outline-4">
<h4 id="org13c6d43"><span class="section-number-4">5.8.108</span> Transform tracing "coordinates"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-108">
<p>
Allow users to supply coordinates to transforms in some form so that
we only dump a subset of the transform data. This could be the ID of
the transform.
</p>
</div>
</div>

<div id="outline-container-orga9fe03e" class="outline-4">
<h4 id="orga9fe03e"><span class="section-number-4">5.8.109</span> Add support for UML profiles and XMI&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-109">
<p>
In order to communicate with external tools, we should try to support
XMI as an injector. For this we could use the XSD for XMI as the basis
for the injector. We also need to create the MASD UML profile with
full support for all of the logical model elements.
</p>

<p>
Previous understanding:
</p>

<p>
We now understand most of the picture of how UML is related to
Dogen. eCore is an implementation of UML's meta-model - it diverges
from UML slightly, but for our purposes we can think of it as
equivalent to UML's meta-model. At the meta-model level, it is
possible to extend UML: this is done via profiles and
stereotypes. Profiles are basically a collection of types which make
use of UML stereotypes to extend the UML meta-model. So it is possible
to inherit from say <code>Class</code> and create a new meta-class that extends
<code>Class</code> in some way (in eCore terms, <code>eClass</code>).
</p>

<p>
For instance, we could create a meta-class called <code>visitor</code>. In fact,
all meta-types in <code>masd</code> can be redone as extensions to the UML
meta-model (e.g. MASD profile). It just so happens that we did not
understand the UML meta-model properly so we created a completely
separate meta-model and then we mapped the Dia representation of the
UML meta-model into yarn. But this muddles things because we are using
Dia's diagram meta-model, which contains an incomplete representation
of UML's meta-model (since it exists purely for drawing diagrams). A
better way to go about this is:
</p>

<ul class="org-ul">
<li>create a c++ implementation of the ecore model. Use exactly the same
terminology - e.g. <code>eclass</code> etc.</li>
<li>create a dia to XMI exporter. This would have obtained the essence
of the UML diagram required for code-generation, removing all of the
"diagramatic" aspects of the model. <a href="https://www.ibm.com/developerworks/library/x-wxxm24/">XMI example</a>:</li>
</ul>

<pre class="code"><code>&lt;?<span style="color: #339CDB; font-weight: bold;">xml</span> <span style="color: #777778;">version="1.0"</span>?&gt;
&lt;<span style="color: #D9DAA2;">XMI</span> <span style="color: #85DDFF;">xmi.version</span>=<span style="color: #DB8E73;">"1.2"</span> <span style="color: #C586C0; font-weight: bold;">xmlns</span>:<span style="color: #85DDFF;">UML</span>=<span style="color: #DB8E73;">"org.omg/UML/1.4"</span>&gt;
 &lt;<span style="color: #D9DAA2;">XMI.header</span>&gt;
  &lt;<span style="color: #D9DAA2;">XMI.documentation</span>&gt;
   &lt;<span style="color: #D9DAA2;">XMI.exporter</span>&gt;ananas.org stylesheet&lt;/<span style="color: #D9DAA2;">XMI.exporter</span>&gt;
  &lt;/<span style="color: #D9DAA2;">XMI.documentation</span>&gt;
  &lt;<span style="color: #D9DAA2;">XMI.metamodel</span> <span style="color: #85DDFF;">xmi.name</span>=<span style="color: #DB8E73;">"UML"</span> <span style="color: #85DDFF;">xmi.version</span>=<span style="color: #DB8E73;">"1.4"</span>/&gt;
 &lt;/<span style="color: #D9DAA2;">XMI.header</span>&gt;
 &lt;<span style="color: #D9DAA2;">XMI.content</span>&gt;
  &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Model</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"M.1"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"address"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"public"</span>
              <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">isRoot</span>=<span style="color: #DB8E73;">"false"</span>
              <span style="color: #85DDFF;">isLeaf</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">isAbstract</span>=<span style="color: #DB8E73;">"false"</span>&gt;
   &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Namespace.ownedElement</span>&gt;
    &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Class</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"C.1"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"address"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"public"</span>
               <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">namespace</span>=<span style="color: #DB8E73;">"M.1"</span> <span style="color: #85DDFF;">isRoot</span>=<span style="color: #DB8E73;">"true"</span>
               <span style="color: #85DDFF;">isLeaf</span>=<span style="color: #DB8E73;">"true"</span> <span style="color: #85DDFF;">isAbstract</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">isActive</span>=<span style="color: #DB8E73;">"false"</span>&gt;
     &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Classifier.feature</span>&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.1"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"name"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.2"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"street"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.3"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"zip"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.4"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"region"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.5"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"city"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
      &lt;<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Attribute</span> <span style="color: #85DDFF;">xmi.id</span>=<span style="color: #DB8E73;">"A.6"</span> <span style="color: #85DDFF;">name</span>=<span style="color: #DB8E73;">"country"</span> <span style="color: #85DDFF;">visibility</span>=<span style="color: #DB8E73;">"private"</span>
                     <span style="color: #85DDFF;">isSpecification</span>=<span style="color: #DB8E73;">"false"</span> <span style="color: #85DDFF;">ownerScope</span>=<span style="color: #DB8E73;">"instance"</span>/&gt;
     &lt;/<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Classifier.feature</span>&gt;
    &lt;/<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Class</span>&gt;
   &lt;/<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Namespace.ownedElement</span>&gt;
  &lt;/<span style="color: #C586C0; font-weight: bold;">UML</span>:<span style="color: #D9DAA2;">Model</span>&gt;
 &lt;/<span style="color: #D9DAA2;">XMI.content</span>&gt;
&lt;/<span style="color: #D9DAA2;">XMI</span>&gt;
</code></pre>

<ul class="org-ul">
<li>note that the dia to XMI exporter would have to make use of some
"extensions" to dia such as the <code>yarn.dia.comment</code>. But the key
thing is we would end up with a UML meta-model description of the
diagram (XMI is roughly speaking an XML representation of the UML
meta-model).</li>
<li>create a UML profile for <code>yarn</code> describing all of the meta-model
elements in terms of the UML meta-model. This could be the exact
same diagram we have for <code>yarn</code> right now, except all the meta-model
entities would be marked as <code>stereotypes</code> (i.e. with a UML
stereotype of <code>stereotype</code>) and would have to inherit from <code>ecore</code>
classes such as <code>eclass</code>.</li>
<li>create a <code>ecore</code> XMI reader.</li>
<li>create a <code>yarn.ecore</code> transformer. The transformer outputs a <code>yarn</code>
model, just like the current <code>yarn</code> frontends would. The remaining
of the processing is done as it is for the current <code>yarn</code> models.</li>
<li>in the main <code>yarn</code> workflows: whenever it encounters a class with a
stereotype of <code>stereotype</code> it knows it must inherit from the
appropriate meta-model. It effectively expands these
meta-stereotypes into inheritance relationships from the meta-model.</li>
<li>create a UML profile for <code>quilt.cpp</code> (and <code>quilt.csharp</code>). Again,
this could be the exact same <code>quilt.cpp</code> model we have, except all
of the meta-model entities are described as meta-stereotypes, and
inherit from the <code>yarn</code> meta-model entities. This means that instead
of extending the <code>yarn</code> types via composition, we would have to use
inheritance. This is somewhat non-trivial because we need to extend
the base class <code>element</code> since all <code>quilt.cpp</code> elements have common
properties.</li>
<li>note: it is important to note that we're not interested in eCore
models per se. To generate an eCore model requires having the eCore
model at run-time as well. This is a completely separate kernel from
<code>quilt</code>. The kind of models we'd be generating would be very
different from the <code>quilt</code> models (generated types would inherit
from <code>eObject</code>, they would have reflection support and so forth -
all features that we are not interested in at present). However,
eCore as a plain meta-model is useful because it is directly related
to XMI and to UML profiles (since its just UML meta-model in
disguise).</li>
<li>proxy models now become just regular XMI models (either JSON or XML)
with suitably annotated models indicating its a proxy model.</li>
<li>the total set of expanders are our implementation of meta-model to
meta-model transformation. Some of these expanders are replaceable
by generated code: all that are simply reading meta-data. Others
must remain. This task will be tricky because we have mixed the
meta-data expansion with additional logic in the expanders. We now
need to decouple the two.</li>
<li>we will lose scoping on the tagged values. We can still have some
kind of hierarchical structure, perhaps <code>MODEL.CLASS.ATTRIBUTE</code> but
this is now limited to the meta-model structure because we must be
able to mechanically map from a tag value to a class and
attribute. We should also read the UML spec on valid tagged values
in case they forbid some characters such as dots.</li>
<li>up to now we have extended the dia format to perform yarn-like
operations; for example, we read stereotypes in the <code>yarn.dia</code>
frontend and convert them into <code>yarn</code> types. In an XMI world this
will no longer happen. We must pass-through the dia stereotypes into
a XMI class. All changes to dia must be seen as XMI extensions.</li>
</ul>

<p>
Advantages of this approach:
</p>

<ul class="org-ul">
<li>we'd be relying on standards: any tool that can output XMI can be
used as a front-end, and all the extensions used for Dogen are part
of XMI/UML. Nothing is proprietary.</li>
<li>since all extensions to meta-model elements are done via profiles,
we are able to figure out where the meta-data is (all tagged values
in the profile are annotations). It is still not totally clear how
one would map the <code>annotation</code> types (e.g. <code>text</code>, <code>number</code> etc) to
programming language types, but the gist is we should be able to
generate the factories that read meta-data and instantiate
objects. Not all mappings are trivial of course.</li>
<li>we can create arbitrary extensions to the meta-model just by using
the meta-stereotype. Users can create their own on their diagrams,
and because of the stitch integration, they can already add their
own templates. This makes the system arbitrarily extensible. Of
course, we still need to plug in the new meta-model items to the
pipeline (how would they get populated?).</li>
</ul>

<p>
High-level tasks to get us there:
</p>

<ul class="org-ul">
<li>create a <code>ecore</code> <code>yarn</code> model.</li>
<li>add a <code>ecore.xmi</code> model that reads XMI and instantiates
<code>ecore</code>. Actually we should probably create an <code>xmi</code> model that
reads XML and JSON and then use that model as input for the
<code>ecore.xmi</code> transformer.</li>
<li>change the <code>yarn</code> model to inherit from the appropriate <code>ecore</code>
entities. This will be a bit problematic if there is use of
reflection (e.g. eObject etc).</li>
<li>transform <code>quilt.cpp</code> and <code>quilt.csharp</code> into <code>yarn</code>
extensions. Instead of composition we need to use inheritance
somehow. Composition is possible of course, but basically we need to
be able to express it as a UML profile.</li>
<li>add a <code>yarn.ecore</code> model that converts <code>ecore</code> into <code>yarn</code>.</li>
<li>update <code>yarn</code> to understands meta-stereotypes. When it sees a
stereotype of <code>stereotype</code> it looks for a tagged value for
inheritance and instantiates the inheritance relationship of
meta-model items. In practice we can support this right now in yarn,
there is no dependency on anything else for this. Users just need to
add the meta-model to their list of referenced models, add a
stereotype of <code>stereotype</code> and the appropriate generalisation
relationship. The <code>stereotype</code> is just for cosmetic purposes, <code>yarn</code>
workflows would already inherit correctly.</li>
<li>create a <code>dia.xmi</code> model that outputs XMI documents, possibly in
<a href="https://github.com/dsevilla/xmi-to-json">JSON as well</a>. Delete the current <code>yarn.dia</code> frontend and rewrite it
in terms of <code>dia.xmi</code> and <code>yarn.xmi</code>.</li>
</ul>

<p>
Note:
</p>

<ul class="org-ul">
<li>it is interesting to notice that in practice we don't actually need
to link <code>ecore</code> to <code>yarn</code> (inheritance, etc), provided that we
support interoperability between the two: stereotypes, tagged
values, etc. As long as the mapping results in the correct
instantiation of the <code>yarn</code> model, this is semantically equivalent
to making <code>yarn</code> a proper specialisation of the UML
meta-model. Problems start when users try to make use of UML
meta-model types for their own templates though.</li>
<li><p>
it seems there is no publicly available XMI XSD for UML. Actually it
seems there is no proper UML support in XMI and each vendor has
created incompatible extensions. See:
</p>
<ul class="org-ul">
<li><a href="https://bugs.kde.org/show_bug.cgi?id=56184">https://bugs.kde.org/show_bug.cgi?id=56184</a></li>
<li><a href="http://plantuml.com/xmi">http://plantuml.com/xmi</a></li>
<li><a href="https://github.com/plantuml/plantuml">https://github.com/plantuml/plantuml</a></li>
</ul>
<p>
The only solution for this problem is to create a "libxmi" that has
many frontends and supports a single object model that covers all of
UML as per OMG UML XMI. Then manually create XMI XSD schemas for
each variant of UML, use the XSD tool to create C++ representations
of these and manually create mappings between these dialects and the
standard UML object model. One should try to make the mappings
bidirectional so that the library could be used to create a
converter between XMI formats. However, this is a very large task
and its not clear its worth it. Actually we probably want a "libuml"
product which contains the XMI adapters. It should also contain
other adapters such as Dot/GraphViz, Dia, etc. It should also define
its own libuml XMI with XSD. It should also include OCL parsing. It
could share code with umbrello.
</p></li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/catedrasaes-umu/emf4cpp">EMF4CPP</a> (see also <a href="https://github.com/mdoerfel/emf4cpp/tree/v2">https://github.com/mdoerfel/emf4cpp/tree/v2</a>)</li>
<li><a href="https://github.com/MDE4CPP">MDE4CPP</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dd465146.aspx">Standard stereotypes for UML models</a></li>
<li><a href="https://www.omg.org/spec/XMI/20131001/XMI.xsd">XMI XSD v2.5.1</a></li>
<li><a href="http://www.omg.org/spec/xmi/2.5.1/">XMI specification v2.5.1</a></li>
</ul>

<p>
<b>Previous Understanding</b>
</p>

<p>
It would be nice to be able to read an eCore model and generate code
from it. This would be particularly useful if we could generate java
code. We would require a mapping layer of eCore types into LAM.
</p>

<ul class="org-ul">
<li><a href="http://eclipsesource.com/blogs/tutorials/emf-tutorial/">What every Eclipse developer should know about EMF</a></li>
</ul>
</div>
</div>

<div id="outline-container-org50f7da2" class="outline-4">
<h4 id="org50f7da2"><span class="section-number-4">5.8.110</span> Reducing the overhead of other facets in types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-110">
<p>
Note: This story is a bit far-fetched at the moment, but it is a place
to collect ideas on this space.
</p>

<p>
There is a tricky problem with io and inheritance: when using a facet,
a user should only pay the cost of that facet and nothing else;
however, we could not find any efficient ways of type dispatching
across models for io. This meant that we ended up adding a
<code>to_stream</code> method to types that are part of an inheritance
relationship. The downside of this approach is that even if one does
not use io, one ends up paying the cost of carrying this method
around.
</p>

<p>
No good alternatives have been found:
</p>

<ul class="org-ul">
<li>its not possible to use visitors because we now allow cross-model
inheritance; thus we do not know what visitor to use.</li>
<li>one could register types against a base streamer for an inheritance
tree; the downside of this approach is efficiency. We'd have to do a
map look-up to find the correct streamer. Its possible but not
entirely trivial to use a vector as we only know the size of the
inheritance tree at run-time and so we'd have to assign positions in
the vector as types register. This means we'd have to have some kind
of static member variable on each type to remember their index, and
this would be populated as a result of registration. This also means
we'd still be impacting types with the static index. This is akin to
a vtable but with a twist. Whereas the vtable is associated with an
object, we'd have a vtable per inheritance tree; the index for each
object is in each class (but it must be populated at run time). The
size of the vtable must also be determined once all types have
registered (or we can continue to grow it during the registration
phase; a one-off cost).</li>
</ul>

<p>
Actually this seems to be a common problem; we did the same for
visitors. It would be nice to only pay visitor costs when one intends
to use it. The current implementation menas we are carrying a vtable
just because of this (and of <code>to_stream</code>). In an ideal scenario,
visitor would itself carry the vtable.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/">12.5  The virtual table</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgaab22ea" class="outline-4">
<h4 id="orgaab22ea"><span class="section-number-4">5.8.111</span> Model anonymiser and slicer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-111">
<p>
A user may create a model which triggers a problem in dogen. For
example it may cause it to abort code generation, or generate invalid
code, etc. The user may not have the desire to spend time creating a
small test model that reproduces the bug and they may not be able to
send us the full model (or models, if there are references). One way
in which we could make this use case simpler is to generate an
anonymized version of the model.
</p>

<p>
The anonymizer takes an intermediate model and maps every element to a
generated name such as <code>object_0</code>, <code>object_1</code> and so forth. We should
only do this for non-system types (non-proxy models).
</p>

<p>
For extra bonus points, the anonymizer should use a hash of the
element id such that an element always maps to the same anonymized
element. Actually if we generalise this slightly: we could create a
class that given a map of element ids (old to new), produces a new
model by replacing those elements. This means if we give it first map
A it will convert model a into a'. If we then give it A<sup>-1</sup>, it will
reverse the transformation converting a' back into a. Making it
generic may have other uses such as renaming.
</p>

<p>
In addition, the user may not want to send us an entire model. It is
likely the problem is contained with one or a few elements. We could
have an additional tool that takes a model and a set of element ids
and generates a second model with just that element and all of its
dependencies. For extra bonus points we should be able to give it a
property id and only that property is preserved. It could also
collapse all references of external models (non-proxy) into the same
model.
</p>

<p>
Users could run the slicer first and then the anonymizer.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/TonicAI/masquerade">masquerade:</a> real time data annonymiser. See this <a href="https://www.tonic.ai/post/masquerade-a-postgres-proxy/">blog post</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcd1ec5b" class="outline-4">
<h4 id="orgcd1ec5b"><span class="section-number-4">5.8.112</span> Consider adding support for the <code>fmt</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-112">
<p>
It would be interesting to benchmark dogen using iostreams vs dogen
using the <code>fmt</code> library. It would also be nice to have a IO based on
<code>fmt</code>.
</p>

<p>
We should also consider replacing iostreams in M2T with <code>fmt</code>. We need
to find a way to benchmark both approaches.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/fmtlib/fmt">GH fmt</a></li>
<li><a href="https://github.com/fmtlib/fmt/issues/122">#122: Can't write into a pre-existing buffer?</a> It seems we can
pre-allocate the string for the buffer.</li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Add support for the fmt library</b>
</p>

<p>
We could add a facet for fmt that acts like the iostreams
facet.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://accu.org/index.php/journals/2509">https://accu.org/index.php/journals/2509</a></li>
<li><a href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></li>
</ul>
</div>
</div>

<div id="outline-container-org316e223" class="outline-4">
<h4 id="org316e223"><span class="section-number-4">5.8.113</span> Consider adding support for the <code>fast_io</code> library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-113">
<p>
Yet another library for formatting:
</p>

<div class="epigraph"><blockquote>
<p>
fast<sub>io</sub> is a new C++20 library for extremely fast input/output and
aims to replace iostream and cstdio. It is header-only (module only in
the future) for easy inclusion in your project. It requires a capable
C++20 compiler supporting concepts.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/expnkx/fast_io">GH fast<sub>io</sub></a></li>
</ul>
</div>
</div>

<div id="outline-container-orga9df34c" class="outline-4">
<h4 id="orga9df34c"><span class="section-number-4">5.8.114</span> Determine types that are no longer used&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-114">
<p>
One of the problems of code generation is that we may end up producing
a lot code generated types, and its hard to figure out what is being
used. We could either rely on a clang tool for this, and treat
generated code exactly the same way as non generated code. Or we could
try to provide helpers for this.
</p>

<p>
If we do provide helpers, we could supply a list of all of the "root
types" for the generated types (e.g. root nodes of a graph of
types). Then, for all models that reference a model, we could
determine if a root type is used in non-generated code. Because we
have a list of all files that are not code-generated, we could simply
grep that list. The objective of this tool is:
</p>

<ul class="org-ul">
<li>load all models in a product.</li>
<li>for each model, extract all the root types.</li>
<li>then, for each model, get a list of all non-generated files. Search
for each root type on the non-generated files. The search could be a
clang search or if not available a more basic grep. Then, if the
type is found, exclude the type from the list.</li>
<li>then, go through all models that have a reference to that model and
do the same thing. At the end, produce a list of types that are not
referenced any where.</li>
</ul>

<p>
For extra bonus points, it would be even more useful if we could mark
types as internal and external so that we could exclude external
types. However, here there are two notions of external: Intra-product
external (e.g. other models use it, but not the outside world) and
inter-product external (e.g. other products use it). Its not clear how
this would work.
</p>

<p>
Interestingly, we could use this to produce a weighted list of usages
(heat map?). This would allow us to understand how used a type is, so
that if we are trying to remove it we can figure out how used the type
is and where.
</p>

<p>
See also the story about language attributes: <a href="#org17f4ba4">Consider adding C#/C++
attributes</a>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/llvm-mirror/clang-tools-extra">clang tools extra</a>: including clangd, a LSP-based code indexer.</li>
</ul>
</div>
</div>

<div id="outline-container-orgae5ccdc" class="outline-4">
<h4 id="orgae5ccdc"><span class="section-number-4">5.8.115</span> Overuse of <code>std::set</code>, <code>std::map</code>, etc&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-115">
<p>
According to this paper by Matt Austern we should see if we really
need sets/etc or if there are other alternatives:
</p>

<p>
<a href="http://lafstern.org/matt/col1.pdf">Why you shouldn't use set (and what you should use instead)</a>
</p>

<p>
In cases where we know upfront the number of elements we require and
we already have them sorted, we may not need a set.
</p>
</div>
</div>

<div id="outline-container-orgbda7b3a" class="outline-4">
<h4 id="orgbda7b3a"><span class="section-number-4">5.8.116</span> Add support for multiple kernels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-116">
<div class="epigraph"><blockquote>
<p>
This story is a very vague story that keeps track of ideas on making
dogen useful for code generators of other kinds.
</p>

</blockquote></div>

<p>
One of the stories in the backlog covers other targets of code
generation:
</p>

<p>
<a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#add-support-for-thrift-and-protocol-buffers">Add support for thrift and protocol buffers</a>
</p>

<p>
Originally we thought about adding support for these within a model;
that is to say, one would have additional serialisation "kinds"
available with a given dogen model. However, there is another way to
look at this; one could make other kinds of code generators using the
dogen infrastructure.
</p>

<p>
That is, contrary to it's name, dogen isn't necessarily just for
"domain model generation". Nothing stops one from building a protocol
buffers or thrift compiler using dogen infrastructure that outputs
<b>exactly</b> the same code as the original tools. All that would be
required to do so is:
</p>

<ul class="org-ul">
<li>create a frontend that reads in their specification;</li>
<li>to ensure yarn is expressive enough to cover all of the aspects of
the code that needs to be generated;</li>
<li>to create the formatters.</li>
</ul>

<p>
However we can't just add this formatters to <code>quilt</code>. Quilt is a
single-purpose backend (as all backends should be): to generate domain
objects for different languages. All kernels in <code>quilt</code> are aligned
with this vision.
</p>

<p>
But we could introduce additional backends. As as example of an
additional backend, we have eCore. We already have a story for
supporting eCore as a frontend, but there the idea is simply that we
read the XML, convert it into yarn (as we do with any other frontend)
and then generate "native types". But an alternative dimension to this
is to provide a eCore backend which generates a completely different
kind of types, which look like a cross-platform version of eCore:
</p>

<ul class="org-ul">
<li>provide inheritance from an <code>EObject</code> supertype</li>
<li>provide cross-language reflection</li>
</ul>

<p>
And so forth. This is very different from <code>quilt</code>. this <code>ecore</code>
backend would have a dependency on the <code>yarn.ecore</code> frontend and we'd
have to probably extend <code>yarn</code> to cope with all the nitty-gritty
detail of eCore.
</p>

<p>
Other examples:
</p>

<ul class="org-ul">
<li>a <code>protobuf</code> tool that generates code identical to the <code>protobuf</code>
compiler and reads its input from the IDL;</li>
<li>a database mapping tool like <code>odb</code>; one can conceive a clang
front-end that reads in source code and generates an yarn model
(<a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#consider-c-itself-as-a-front-end">already in backlog</a>); this model then can be used to generate C++
code that is identical to the code produced by ODB (again assuming
that yarn is extended to be expressive enough to represent all the
constructs required by ODB).</li>
<li>an <code>xsd</code> tool.</li>
</ul>

<p>
In this world we'd somehow start creating a bit of binding between the
frontend and the backend because each model most likely will only support
a backend: either protobuf, or xsd, etc.
</p>

<p>
This approach is compelling proposition because it means people who
want to create code generators don't have to worry about a lot of the
boilerplate code. However, the biggest problem is that we'd be
imposing a large and complex "framework" on them with all the evilness
that that entails.
</p>

<p>
In the light of this story, a better name for dogen would be <code>codegen</code>
(or <code>cogen</code> to make it a bit more unique in google). The tag line is
then The Generic Code Generator. Unfortunately there are already a few
projects with the name <code>cogen</code> so we may need to find a better
name. Alternatively we can maintain the name dogen, but take away its
meaning (i.e. no longer "The Domain Generator").
</p>
</div>
</div>

<div id="outline-container-orgc7fa2d2" class="outline-4">
<h4 id="orgc7fa2d2"><span class="section-number-4">5.8.117</span> Consider adding support for OCL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-117">
<p>
UML supports adding constraints via <a href="http://www.omg.org/spec/OCL/2.4/">OCL</a>, the Object Constraint
Language. We could generate code from it.
</p>
</div>
</div>

<div id="outline-container-org4255479" class="outline-4">
<h4 id="org4255479"><span class="section-number-4">5.8.118</span> Code generation and system configuration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-118">
<p>
This is a very sketchy story. We probably should look into any
relationships between system configuration and code generation. A
starting point on this are these papers:
</p>

<ul class="org-ul">
<li><a href="http://www.infosun.fim.uni-passau.de/publications/docs/PTD%2B14.pdf">Coevolution of Variability Models and Related Software Artifacts</a></li>
<li><a href="http://homepages.dcc.ufmg.br/~mtov/pub/2015_modularity.pdf">Feature Scattering in the Large: A Longitudinal Study of Linux
Kernel Device Drivers</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc178f98" class="outline-4">
<h4 id="orgc178f98"><span class="section-number-4">5.8.119</span> Supporting user defined generic types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-119">
<p>
At present we have done a bit of a hack to support templates. However,
all that is required to allow users to create their own template types
is:
</p>

<ul class="org-ul">
<li>parse dia information for type arguments;</li>
<li>change object to have type arguments;</li>
<li>change merger to allow variables of the type of the type argument;</li>
<li>change view model to propagate type arguments;</li>
<li>change formatter to create template class if type arguments are
present.</li>
</ul>

<p>
However this would then mean that IO and serialisation would fail
since they are implemented on the cpp. As there is no need for
template types, this seems like an ok limitation.
</p>
</div>
</div>

<div id="outline-container-org3a091ba" class="outline-4">
<h4 id="org3a091ba"><span class="section-number-4">5.8.120</span> Visitor adaptor for usage in ranges&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-120">
<p>
It would be great if we automatically generated an adaptor to visitors
which could be plugged into a range. Internally the adaptor would
perform the accept on its <code>operator()</code>. We could also have an adaptor
for a <code>std::pair</code> which would be templatised on the first member of
the pair. Or should one just use a keys or values range iterator.
</p>
</div>
</div>

<div id="outline-container-org48f72f4" class="outline-4">
<h4 id="org48f72f4"><span class="section-number-4">5.8.121</span> Visitor with <code>std::function</code> for each <code>visit</code> method&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-121">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want an extensible visitor so that I don't
have to manually generate one.
</p>

</blockquote></div>

<p>
It would be nice if the code generator created a visitor which has as
its properties a set of <code>std::function</code> which match the signature of
the visit functions; then the visit functions would just check that
the functions have been assigned and call them. If not, throw.
</p>
</div>
</div>

<div id="outline-container-orga6d5e12" class="outline-4">
<h4 id="orga6d5e12"><span class="section-number-4">5.8.122</span> Create a visitor interface with multiple implementations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-122">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I need multiple visitor interfaces so that I
can decide which one is best for my requirements.
</p>

</blockquote></div>

<p>
We decided to use a base class for visitor; it would have been better
to create an interface, with multiple implementations:
</p>

<ul class="org-ul">
<li>"negative" visitor: any unimplemented methods throw;</li>
<li>default visitor: all methods do nothing;</li>
<li>std::function visitor: usr supplies lambdas to visitor.</li>
</ul>

<p>
Users can then inherit from these visitors where appropriate
(e.g. negative and default visitors). Each of these would have their
own formatter.
</p>

<p>
Actually we don't necessarily need visitor interfaces, but we need
some knobs to control the kind of visitor we generate. We should also
have a way to control the number of visitable methods generated (const
visitor, mutable visitor etc).
</p>
</div>
</div>

<div id="outline-container-org3b2b6bf" class="outline-4">
<h4 id="org3b2b6bf"><span class="section-number-4">5.8.123</span> Add targets to output manual in downloadable formats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-123">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like to read the manual offline and
have the ability to print them.
</p>

</blockquote></div>

<p>
We should build HTML and PDF representations of the manual. When we
start using worktrees we could also have a simple script that copies
across these into the website. This can be done manually for now at
the end of each script (running the script).
</p>

<p>
The manual needs to be moved over to org-mode format. However, this
story still applies. We just need to figure out how to use emacs in
batch process to generate all of the targets.
</p>
</div>
</div>

<div id="outline-container-org40dfea7" class="outline-4">
<h4 id="org40dfea7"><span class="section-number-4">5.8.124</span> Investigate the possibility of creating a mock facet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-124">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to code-generate mocks for interfaces
so that I don't have to generate this code manually.
</p>

</blockquote></div>

<p>
This is straight out of left-field (pardon the pun), but may actually
be a good idea. One annoying thing with mocking frameworks such as
<a href="http://turtle.sourceforge.net/index.html">turtle</a> is the amount of macros. However, <code>dogen</code> already has all the
required information needed to create an expectation based mock - the
meta-model. We could mimic the turtle API with a mock facet that is
made up of real C++ objects. When a class is marked as an interface,
we could automatically generate its mock in a mock facet and allow
users to supply lambdas for the expectations.
</p>

<p>
This will require proper operations support.
</p>

<p>
Actually this may not be so easy because mock frameworks have so much
functionality. An easy way is simply to have a <code>mock</code> facet that
instantiates the mocks using the macros. It would be easy to code
generate this code.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/rollbear/trompeloeil">trompeloeil</a>: Header only C++14 mocking framework</li>
<li><a href="http://turtle.sourceforge.net/index.html">Turtle</a>: A C++ mock object library for Boost</li>
<li><a href="https://enterprisecraftsmanship.com/posts/when-to-mock/">Article: When to mock</a></li>
<li><a href="https://github.com/Moq/moq4">GH Moq</a></li>
<li><a href="https://github.com/moq/Moq.AutoMocker">GH Moq.AutoMocker</a></li>
<li><a href="https://github.com/Guardsquare/mocxx">GH mocxx</a>, article: <a href="https://tech.guardsquare.com/posts/mocxx-the-mocking-tool/">The C++ Mocking Tool</a>, <a href="https://www.reddit.com/r/cpp/comments/k0atyi/mocxx_a_versatile_c_function_mocking_framework/">reddit</a>.</li>
<li><a href="https://github.com/Smertig/rcmp">GH rcmp</a></li>
<li><a href="http://blog.zhangliaoyuan.com/blog/2015/05/15/thy-ways-to-break-the-dependency-during-unit-testing-in-c_c++-programming/">The Ways to Break the Dependency During Unit Testing in C/C++ Programming</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1af58d3" class="outline-4">
<h4 id="org1af58d3"><span class="section-number-4">5.8.125</span> Investigate ribosome for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-125">
<p>
Ribosome seems like a templating tool with a simple syntax. May have
some ideas useful for stitch.
</p>

<div class="epigraph"><blockquote>
<p>
In 50 words
</p>

<ol class="org-ol">
<li>You write standard JavaScript, Ruby or Python scripts.</li>
<li>However, lines starting with a dot (.) go straight to the output.</li>
<li>To expand JavaScript/Ruby/Python expressions within dotted lines
use @{expr} construct.</li>
</ol>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://sustrik.github.io/ribosome/">http://sustrik.github.io/ribosome/</a>: website</li>
<li><a href="https://github.com/sustrik/ribosome">GitHub project</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4fc1b53" class="outline-4">
<h4 id="org4fc1b53"><span class="section-number-4">5.8.126</span> Add support for languages available in Dia2Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-126">
<p>
Dia already has a default code generator: <a href="http://dia2code.sourceforge.net/">Dia2Code</a>. At present it
supports the following outputs (as per <a href="http://dia2code.sourceforge.net/features.html">features</a> page):
</p>

<ul class="org-ul">
<li>Ada, C, C++, C#, CORBA IDL, Java, PHP, PHP5, Python, Ruby,
shapefile, and SQL.</li>
</ul>

<p>
We could probably add support for these by creating a test Dia
diagram, running it through Dia2Code an then making sure we get a
binary identical output. This would be a good way to bootstrap
multi-language support.
</p>

<p>
We couldn't find simple test diagrams in Dia2Code so perhaps we could
also contribute these to the project. It does have a set of <a href="http://dia2code.sourceforge.net/examples.html">examples</a>,
which could be used as a starting point for the tests. They are a bit
complex though.
</p>

<p>
They also appear to have support for functions etc. We should see what
they've done as this would also be a good way to evolve Dogen.
</p>
</div>
</div>

<div id="outline-container-org5200592" class="outline-4">
<h4 id="org5200592"><span class="section-number-4">5.8.127</span> Generate model from database tables&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-127">
<p>
Insane idea: one could point knit to a database from a supported
vendor and generate the C++ code needed to represent those
tables. This could be filtered by the user. Idea came from here:
</p>

<ul class="org-ul">
<li><a href="https://msdn.microsoft.com/en-us/data/gg558520.aspx">T4 Templates and the Entity Framework</a></li>
</ul>

<p>
All we need is a "database frontend" responsible for connecting to the
database and performing the mapping between the database types and the
language specific types. The model would then have ODB support to read
and write these tables.
</p>

<p>
We should have a specific tool to do this. Ideally the tool itself
should use ODB or at least the ODB database specific libraries to
access the DML. We should also investigate existing ODB support for
this.
</p>

<p>
If we think about this in more generic terms, what we need is
something like a LSP for SQL, built using ODB libraries (or some other
libraries that support multiple databases). The entire database schema
is loaded into memory into a database agnostic representation. That
could then be useful for things such as answering LSP queries and also
converting this information into a generatable dogen model. There are
a lot of similarities between these two problems.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/emacs-lsp/lsp-mssql">https://github.com/emacs-lsp/lsp-mssql</a></li>
<li><a href="https://github.com/microsoft/sqltoolsservice">https://github.com/microsoft/sqltoolsservice</a></li>
<li><a href="https://github.com/kristiandupont/kanel">kanel</a>: Generate Typescript types from Postgres</li>
</ul>
</div>
</div>

<div id="outline-container-org4fc6946" class="outline-4">
<h4 id="org4fc6946"><span class="section-number-4">5.8.128</span> Generate model from CSV files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-128">
<p>
Following on from the idea of using database tables, another
interesting use case are CSV files. It is common that one has a number
of CSV files that one needs to process - for example, import to a
database to perform further comparisons. It would be great if one
could just point knitter at a set of CSV files with headers and have
it:
</p>

<ul class="org-ul">
<li>create a class for each file type.</li>
<li>given the data in the file, find the most appropriate type for the
field. Note when there are more than one file of the same type, and
instead of generating multiple classes, just use the data for type
inference.</li>
<li>generate ODB support if requested by the user. If more than one file
have the same field with the same type, create foreign keys.</li>
</ul>

<p>
With <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#add-support-for-csv-serialisation">support for CSV serialisation</a>, this means one could build a CSV
importer and processor very quickly. With support for diffs, this
would mean one could create a CSV file differ easily.
</p>

<p>
We should probably add this to the same tool that supports JSON/XML
imports.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>we could make a CSV injector for this. It could have a few
additional parameters such as first line contains field names,
delimiter, etc (check Excel/Calc import dialogs). It would then
guess the field types using some simple heuristics (regex for
numeric, regex for float and so forth until last option is string).</li>
<li>actually maybe a two step process. First we'd have the "model
generator", which parses the CSV file and creates a JSON model. Then
we can use the regular JSON model. We could, of course, just plug it
in so that we guess the JSON model and then generate it, but if
users want to fiddle with the model it would be nice to have the
option.</li>
</ul>
</div>
</div>

<div id="outline-container-orge6df8dd" class="outline-4">
<h4 id="orge6df8dd"><span class="section-number-4">5.8.129</span> Generate model from Excel files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-129">
<p>
Similar to CSV files, it may be nice to be able to point Dogen to a
spreadsheet and generate a model from it that is able to at least read
data from the spreadsheet. With this we can then easily convert the
data from this format to any other supported formats.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/troldal/OpenXLSX">OpenXLSX GitHub</a>: "OpenXLSX is a C++ library for reading, writing,
creating and modifying Microsoft Excel files, with the .xlsx
format."</li>
<li><a href="https://sourceforge.net/projects/libxls/">libxls GitHub</a>: "The libxls library is a C library for reading
files in the legacy Excel file format, .xls. It cannot be used for
writing or modifying Excel files."</li>
<li><a href="https://sourceforge.net/projects/xlslib/">xlslib GitHub</a>: "The xlslib library is a C/C++ library for creating
files in the legacy Excel file format, .xls. It cannot be used for
reading or modifying Excel files."</li>
<li><a href="https://libxlsxwriter.github.io">libxlsxwriter GitHub</a>: "The libxlsxwriter library is a C library
for creating .xlsx files. It cannot be used for reading or modifying
Excel files."</li>
<li><a href="http://www.libxl.com">LibXL GitHub</a>: "The LibXL library can read, write, create and
modify Excel files, in both the .xls and .xlsx formats. It is the
most feature complete library available and has interfaces for C,
C++, C# and Delphi. It is only available for purchase, however.</li>
<li><a href="https://github.com/dbzhang800/QtXlsxWriter">QtXlsx GitHub</a>: Of the open source libraries, the QtXlsx library
is the most feature complete. It is, however, based on the Qt
framework. While I'm a big fan of Qt for application programming
purposes, I don't believe it is the best option for lower-level
libraries.</li>
<li><a href="https://github.com/tfussell/xlnt">XLNT GitHub</a>: Recently, I found the XLNT library on GitHub. It was
not available when I began developing OpenXLSX.</li>
</ul>
</div>
</div>

<div id="outline-container-org1630244" class="outline-4">
<h4 id="org1630244"><span class="section-number-4">5.8.130</span> Add serialisation support to and from spreadsheets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-130">
<p>
This is probably mainly useful for reading, though it may also be
useful for writing if we want to say generate graphs. It would be nice
if we could dump a list of objects into a spreadsheet.
</p>

<p>
See also <a href="#orge6df8dd">Generate model from Excel files</a>.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/2876720/c-library-to-load-excel-xls-files">C++ library to load Excel (.xls) files</a></li>
<li><a href="https://www.codeproject.com/Articles/42504/ExcelFormat-Library">ExcelFormat Library</a></li>
<li><a href="https://github.com/tfussell/xlnt">xlnt</a>: Cross-platform user-friendly xlsx library for C++14</li>
<li><a href="https://sourceforge.net/projects/xlsxio/">xlsxio</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgccca3bf" class="outline-4">
<h4 id="orgccca3bf"><span class="section-number-4">5.8.131</span> Generate model from JSON or XML instance files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-131">
<p>
It would be great if one could point dogen at a given JSON or XML file
and have it infer the model. For XML, if the schema is available, one
should just use the XSD tool of course. This approach is just for
quick and dirty modeling where one needs to build a tool to process a
set of existing documents.
</p>

<p>
We would have to have the ability to use more than one "source
document" and to "merge" properties across these. For example, if 3
JSON documents are supplied, we should be able to create a type that
is the superset of these.
</p>

<p>
To be clear, this story is not about using a JSON or XML schema to
generate a yarn model, but to use instances of a given schema in JSON
or XML to infer a possible yarn model that could read that instance
document. This is useful for example to consume a web service from
C++.
</p>

<p>
We should have a separate tool to do this work.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://blog.quicktype.io/debut/">quicktype's big debut</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3e53306" class="outline-4">
<h4 id="org3e53306"><span class="section-number-4">5.8.132</span> Investigate GDB visualisers for generated models&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-132">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I would like pretty-printing for my types in
GDB so that I debug more easily programs using dogen models.
</p>

</blockquote></div>

<p>
It would be great if the code generator created GDB visualisers for
the types in a generated models such that one could inspect values of
STL containers with types of that model. It should hook into the
pretty-printing facet.
</p>

<ul class="org-ul">
<li><a href="http://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html">Pretty printing</a></li>
<li><a href="https://github.com/ruediger/Boost-Pretty-Printer">Boost pretty printer</a></li>
<li><a href="https://groups.google.com/group/boost-list/browse_thread/thread/ff232ac626bf41cf/18fbf516ceb091da?pli%3D1">Example for multi-index</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf1fa70" class="outline-4">
<h4 id="orgdf1fa70"><span class="section-number-4">5.8.133</span> Add memory measurements support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-133">
<p>
Firefox has an interesting approach to estimating memory usage:
</p>

<ul class="org-ul">
<li><a href="http://njn.valgrind.org/measuring.html">Measuring data structures: Firefox (C++) vs. Servo (Rust)</a></li>
</ul>

<p>
The gist of it is to add code like this:
</p>

<pre class="example">
struct CookieDomainTuple
{
  nsCookieKey key;
  nsRefPtr&lt;nsCookie&gt; cookie;

  size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
};
</pre>


<p>
Where:
</p>

<pre class="example">
size_t
CookieDomainTuple::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
{
  size_t amount = 0;
  amount += key.SizeOfExcludingThis(aMallocSizeOf);
  amount += cookie-&gt;SizeOfIncludingThis(aMallocSizeOf);
  return amount;
}
</pre>


<p>
We could add something similar to Dogen. This should be an optional
aspect.
</p>

<p>
Once we got the size information, the next thing should be a way to
dump a size report and make it visualisable in a tool such as baobab
(or in a manner similar to baobab) so that users can, at any time, get
a break down of where the objects are. Of course this would imply we
need a top-level object that contains all objects or some kind of way
of registering sizes. This could be done on construction and
destruction perhaps.
</p>
</div>
</div>

<div id="outline-container-org5d1ebfb" class="outline-4">
<h4 id="org5d1ebfb"><span class="section-number-4">5.8.134</span> Add cling support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-134">
<p>
One thing that would be really cool is if one could use generated code
from <a href="https://github.com/vgvassilev/cling">cling</a>. For each project we generate, we could also generate a
"setup cling script" as described <a href="https://github.com/vgvassilev/cling/issues/67#issuecomment-107004157">here</a>.
</p>

<p>
The script simply loads up the SO/static library and all of the
includes of the SO. It also loads up all of the scripts of its
dependencies.
</p>

<p>
We need to generate SOs for models first.
</p>
</div>
</div>

<div id="outline-container-orgd58876d" class="outline-4">
<h4 id="orgd58876d"><span class="section-number-4">5.8.135</span> Consider adding support for spelling on comments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-135">
<p>
It would be nice if we could spell-check comments on models. This
could come up as warnings once we have warning/error support.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nuspell/nuspell">nuspell</a>: Free and open source C++ spell checking library
<a href="https://nuspell.github.io">https://nuspell.github.io</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc2904b8" class="outline-4">
<h4 id="orgc2904b8"><span class="section-number-4">5.8.136</span> Consider offering identifier suggestions for misspelling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-136">
<p>
We just bumped into an error where a type was not spelled correctly:
</p>

<pre class="example">
Error: Object has property with undefined type: &lt;cpp&gt;&lt;expansion&gt;&lt;inlcusion_directives_repository&gt;
</pre>


<p>
We meant to say <code>inclusion</code> rather than <code>inlcusion</code>. We should
investigate if the clang "misspell" matching is available to use from
the outside word; it would be useful in cases such as this. We should
be able to just push all of the available qnames in yarn and then,
given a name, see if it matches.
</p>

<p>
See Spell Checker section of <a href="http://blog.llvm.org/2010/04/amazing-feats-of-clang-error-recovery.html">this</a> post.
</p>

<p>
Seems like the name of the algorithm used is <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein
distance</a>. Still haven't found clang's API for this but there are
several implementations available.
</p>

<ul class="org-ul">
<li><a href="https://github.com/cdmh/algorithms">https://github.com/cdmh/algorithms</a></li>
<li><a href="https://github.com/Martinsos/edlib">https://github.com/Martinsos/edlib</a></li>
</ul>

<p>
We could compute the Levenshtein distance as part of resolution, in
cases where we fail to resolve - e.g. second pass after all has
failed.
</p>

<p>
We should also do this for command line options.
</p>
</div>
</div>

<div id="outline-container-orge739c0d" class="outline-4">
<h4 id="orge739c0d"><span class="section-number-4">5.8.137</span> Add support for type "labels" or "tags"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-137">
<p>
It may be useful to "tag" a number of types with a "label", and to
allow users to access these at run time. This only makes sense in the
context of reflection. This story needs a bit more fleshing out. We
don't yet have a use case for this.
</p>

<p>
This would allow for example to list all objects with a given tag.
</p>
</div>
</div>

<div id="outline-container-org0b9eca3" class="outline-4">
<h4 id="org0b9eca3"><span class="section-number-4">5.8.138</span> Add support for plugins&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-138">
<p>
An interesting idea is to generate a model that contains formatters,
create a dynamic library and then have some kind of loading mechanism
in Dogen. The interesting thing is that with static factories, dogen
could make use of this without any code changes at all (e.g. loading
the library into the process is sufficient to trigger registration,
and then its up to the dynamic extensions to decide whether to use the
formatters or not). So a user could create a model with formatters,
add its own text templates, compile and link it and then add it to
Dogen and then make use of the new formatters. The usual constraints
apply such as ABI (ensure one is using the same compiler as used to
compile Dogen, flags, etc).
</p>

<p>
This may also make sense for the front-end, but less so. At present we
already have support for registering both frontends and backends so
this should work out of the box. We just need a way to load DLLs. For
this we can use  <a href="http://apolukhin.github.io/Boost.DLL/index.html">Boost.DLL</a>. We can add an additional command line
argument so that the user can supply the plugins; before doing
anything we must load all DLLs.
</p>

<p>
An interesting logical conclusion for this would be that - if stitch
was able to generate all of the infrastructure required to create a
new formatter - we should have a tool that creates all of the
infrastructure to build the stitch template into a shared object. This
would mean generating CMakeLists with right targets, conan file to
pull in dogen dependencies, etc and possibly even having a target to
call dogen loading the SO. In terms of conan - since we need to have
the dogen package installed, we probably should just require users to
install the dev package too. Or perhaps dogen as a tool (e.g. the
EXEs) could also be provided via conan? If we go for packages, we
should generate an "install script" to install all the required
dependencies, including compiler and so on.
</p>

<p>
We can either extend dogen or create a new utility for this.
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li><a href="https://github.com/GNOME/libpeas">libpeas GitHub</a>: gnome extensibility library. We should mine it for
ideas.</li>
</ul>
</div>
</div>

<div id="outline-container-org5e631be" class="outline-4">
<h4 id="org5e631be"><span class="section-number-4">5.8.139</span> Improving test data generation via "reflection"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-139">
<p>
A really random but perhaps implementable idea: to create a
description of test data as JSON objects. For example, one could
supply a "yarn instantiation description language" (YIDL?) for a user
model, such as:
</p>

<pre class="example">
{
   "__type__" : {
       "model_name": "my_model",
       "external_module_path": []
       "module_path": [],
       "simple_name": "my_type"
   },
   "property_0" : true
}
</pre>


<p>
Where <code>__type__</code> is the "meta-type" for the object we want to
instantiate, allowing us to locate it in the yarn model, and the
remaining properties are as per user yarn model. Once the type is
located, one could then iterate through the properties in yarn and
locate their instance values in the JSON.
</p>

<p>
With this JSON and an yarn instance of <code>my_model</code> we could generate
code that looks like so:
</p>

<pre class="example">
my_model m;
m.property_0(true);
</pre>


<p>
This would allow users to provide JSON descriptions of the test data
factories. If we took this approach we should consider renaming test
data to something a bit better (sample data?).
</p>

<p>
In this light, the current test data is akin to a "generic
instantiation language" in that all strings are instantiated with the
same values (or algorithm of value generation), all ints etc.
</p>

<p>
This is almost like reflection, in that if one had a strongly typed
model for the instantiation description language, it would look like a
reflected yarn model. The problem, of course, is that we do not code
generate yarn; we code generate in language specific models such as
<code>cpp</code>, etc. We would also have to have some kind of reflection support
for these models, and a transformation layer between the yarn
reflection and the implementation model. This is what the formatter
would then use to output.
</p>

<p>
Actually, this is more like compile-time reflection. We do not need to
know at run time what the model looks like, we just need to code
generate instantiations of the objects at compile time. So in theory,
loading yarn into memory is sufficient for this. In addition, we could
simplify "YIDL" by using yarn qualified names. This can be done for
both types and properties:
</p>

<pre class="example">
{
   "type_id" : "&lt;my_model&gt;&lt;my_type&gt;",
   "&lt;my_model&gt;&lt;my_type&gt;&lt;property_0&gt;" : true
}
</pre>


<p>
This is sufficient to resolve this to a specific yarn type and its
property. The syntax would get a bit more complicated in the presence
of composition, arrays etc but its more or less usable. One could even
conceivably extend it to collections by supporting some additional
properties (collection size for example) and allowing users to assume
the existence of counters (special values for strings perhaps such as
<code>%count%</code>?).
</p>

<p>
<b>Notes</b>
</p>

<ul class="org-ul">
<li>see also <a href="https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#make-test-data-generator-more-configurable">Make test data generator more configurable</a></li>
<li>this idea stems from the need to generate <a href="http://www.neuron.yale.edu/neuron/static/docs/refman/hoc.html">Hoc</a> files from a neuron
model described yarn. For that particular use case we would have a
language model (<code>hoc</code>) that uses the instantiation description
language to generate hoc files. Actually this is really not an
appropriate solution for this use case; it would be far too limited
to deal with this problem in general. We need to find a use case for
this other than just generalising test data.</li>
<li>we need a better name than YIDL ("yarn instantiation description
language"). Perhaps something that reflects the nature of this being
a test data templating engine.</li>
<li>this is really complicated. The fountains approach gives us many of
the benefits and it is much simpler.</li>
</ul>
</div>
</div>

<div id="outline-container-org4abe9e4" class="outline-4">
<h4 id="org4abe9e4"><span class="section-number-4">5.8.140</span> Consider using bounded integers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-140">
<p>
This library seems to improve static error checking with integers,
etc:
</p>

<ul class="org-ul">
<li><a href="https://bitbucket.org/davidstone/bounded_integer">https://bitbucket.org/davidstone/bounded_integer</a></li>
</ul>

<p>
However, off the top of my head, there are no cases for bounded
integers in dogen yet.
</p>
</div>
</div>

<div id="outline-container-org3d1dbb2" class="outline-4">
<h4 id="org3d1dbb2"><span class="section-number-4">5.8.141</span> Investigate ModelQ for ideas&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-141">
<p>
We need to mine this project for potential ideas - see how their
approach compares to ours, see if we can learn any lessons from it:
</p>

<p>
<b>ModelQ</b>: ModelQ is a code generator for creating Golang codes/models
to access RDBMS database/tables (only MySQL supported for now).
</p>

<p>
ModelQ: <a href="https://github.com/mijia/modelq">https://github.com/mijia/modelq</a>
</p>
</div>
</div>

<div id="outline-container-org7c17542" class="outline-4">
<h4 id="org7c17542"><span class="section-number-4">5.8.142</span> Use <code>observer_ptr</code> in factory methods&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-142">
<p>
We should not return <code>shared_ptr</code> etc from factory methods; this
forces the client to use a specific type of pointer. Instead we should
return raw pointers and let the client handle RAII. A slightly better
option may be to use the new observer pointer.
</p>

<p>
We need to add this type to dogen.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://en.cppreference.com/w/cpp/experimental/observer_ptr">observer<sub>ptr</sub></a></li>
</ul>
</div>
</div>

<div id="outline-container-org42dc6f1" class="outline-4">
<h4 id="org42dc6f1"><span class="section-number-4">5.8.143</span> Consider adding XML schema as a front-end&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-143">
<p>
Tools like <code>Xsd</code> and <code>ejc</code> use the XML schema to provide the input to
the code generator. There is a simple mapping between the XML schema
and the language. <a href="http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">JAXB</a> is a good example of this. As we already have a
dependency on libxml, we can load XML schemas without any additional
dependencies.
</p>

<p>
Note though that the idea is not to generate another xsd tool since we
already have a good <a href="http://www.codesynthesis.com/products/xsd/">C++ xsd tool</a>. The point is to figure out if a XML
schema based front-end to Dogen is more convenient than Dia XML or
JSON. This may be appealing for a certain class of users: those using
the XSD tool or JAXB to generate POJOs or their C# equivalent.
</p>

<p>
It may also be worth looking at the <a href="https://jaxb.java.net/2.2.4/docs/xjc.html">xjc</a> command line tool interface to
pick up ideas for Dogen.
</p>

<p>
We should also support the annotations used by JAXB such as
inheritance, etc.
</p>
</div>
</div>

<div id="outline-container-orgf51bb80" class="outline-4">
<h4 id="orgf51bb80"><span class="section-number-4">5.8.144</span> XML serialisation for interoperability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-144">
<p>
A very good point raised by Boris on his <a href="https://www.youtube.com/watch?v%3DAuamDUrG5ZU">XML talk</a> is that XML is
useful as an interchange format, mainly for interoperability and
future-proofing. It would be nice if we could use dogen to generate a
"controlled" XML, using a well defined schema (also
code-generated). This would be a stable format that could allow
third-parties to hook into the serialisation - as opposed to boost
serialisation's XML.
</p>
</div>
</div>

<div id="outline-container-orge1feb99" class="outline-4">
<h4 id="orge1feb99"><span class="section-number-4">5.8.145</span> Add support for CSV serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-145">
<p>
It would be nice to be able to serialise some simpler types into CSV
files, and to be able to read them from CSV files. We should use a
third-party library to perform the serialisation. We should check that
the types only have simple types. We should also provide some dynamic
extensions for options such as "use quoted strings", etc.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/vincentlaucsb/csv-parser">csv-parser</a>: very promising CSV parsing library, with read and write
support.</li>
<li><a href="https://github.com/shaovoon/minicsv">minicsv</a>: Minimalistic CSV Streams.</li>
<li><a href="https://github.com/shaovoon/csv_stream">csv<sub>stream</sub></a>: C++14 CSV Stream based on C API.</li>
<li><a href="https://github.com/p-ranav/csv">CSV</a>: CSV for Modern C++ (C++ 17).</li>
<li><a href="https://github.com/shaovoon/minicsv_benchmark">benchmark of CSV libaries</a></li>
<li><a href="https://github.com/ashtum/lazycsv">lazycsv GH</a>: lazycsv is a c++17, posix-compliant, single-header
library for reading and parsing csv files.</li>
<li><a href="https://github.com/JamesBoer/Tbl">Tbl GH</a>: Tbl is a lightweight CSV (comma separated value) and
tab-delimited table reader.</li>
<li><a href="https://github.com/antonmks/nvParse">nvParse GH</a>: Parsing CSV files with GPU</li>
</ul>
</div>
</div>

<div id="outline-container-org9a2a2b2" class="outline-4">
<h4 id="org9a2a2b2"><span class="section-number-4">5.8.146</span> Consider generation of validators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-146">
<p>
It would be nice if we could constraint the domain of a type via some
kind of rules; for example, provide a regular expression or an EBNF
definition with a string that tells dogen how to validate it. We could
then construct simple validators. As usual these expressions can be
supplied via dynamic extensions.
</p>

<p>
This is in effect an attempt to add OCL (object constraint language)
support. This would be extremely difficult, but we capture the story
nonetheless.
</p>
</div>
</div>

<div id="outline-container-orgdadb391" class="outline-4">
<h4 id="orgdadb391"><span class="section-number-4">5.8.147</span> Providing view model hints&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-147">
<p>
Once we start supporting view models, it would be nice to be able to
take an inheritance tree of objects and collapse it into a list view,
handling all of the use cases (reorder columns, remove columns, add
columns, updating rows, etc). All of this code can be inferred from
the type hierarchy.
</p>
</div>
</div>

<div id="outline-container-org364b975" class="outline-4">
<h4 id="org364b975"><span class="section-number-4">5.8.148</span> Consider adding SWIG and Boost.Python support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-148">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to expose models to other languages
so that I can make use of them from there.
</p>

</blockquote></div>

<p>
We could generate the code required to expose the C++ types into ruby
or python by creating a formatter for it. Boost.Python would be more
straightforward as it is plain C++ code; SWIG would require generating
an interface file (IDL-like) and as such is closer to adding support
for thrift and protocol buffers.
</p>

<p>
When generating code for SWIG we must also take into account that SWIG
will generate the type definitions for all other languages, and as
such we cross-language support will not be compatible with it. For
example, if a user wants C# interoperability, it will not be possible
to also generate C# code from Dogen as the types will clash. In
addition, it should be possible to add Dogen level overrides for SWIG,
e.g.:
</p>

<pre class="example">
%typemap(csattributes) AClass          "[ThreadSafe]"
%csattributes AClass::AClass(double d) "[ThreadSafe(false)]"
%csattributes AClass::AMethod()        "[ThreadSafe(true)]"

%inline %{
class AClass {
public:
 AClass(double a) {}
 void AMethod() {}
};
%}
</pre>


<p>
The typemap attributes must be supplied as meta-data in the class and
attributes. They must also be assigned to a language, e.g.:
</p>

<pre class="example">
swig.attribute.csharp=[ThreadSafe]"
</pre>


<p>
and in the attribute:
</p>

<pre class="example">
swig.attribute.csharp=[ThreadSafe(false)]"
</pre>


<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://www.softwariness.com/articles/api-design-for-swig/">C++ API Design for SWIG</a></li>
<li><a href="https://github.com/pybind/pybind11">pybind11</a>: Seamless operability between C++11 and Python</li>
<li><a href="https://blog.esciencecenter.nl/irregular-data-in-pandas-using-c-88ce311cb9ef">50 times faster data loading for Pandas: no problem</a>: talks about
integration of c++ with python (cookie cutterk).</li>
</ul>
</div>
</div>

<div id="outline-container-orgc499d6d" class="outline-4">
<h4 id="orgc499d6d"><span class="section-number-4">5.8.149</span> Add yuml markup language support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-149">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to generate diagrams using yuml so
that I don't have to install Dia.
</p>

</blockquote></div>

<p>
It should be fairly straightforward to add a yuml front end that reads
a file using their markup language and generates an yarn model from it.
</p>
</div>
</div>

<div id="outline-container-org71e5b5a" class="outline-4">
<h4 id="org71e5b5a"><span class="section-number-4">5.8.150</span> Automatic generation of C interfaces for C++ code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-150">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to make use of c++ models from C so
that I can create "bridge" APIs.
</p>

</blockquote></div>

<p>
Once we have proper C support, it should be doable to have a C++ facet
that automatically exposes a C interface.
</p>
</div>
</div>

<div id="outline-container-org05b561a" class="outline-4">
<h4 id="org05b561a"><span class="section-number-4">5.8.151</span> Improvements to Dogen's dia model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-151">
<p>
Assorted notes on cleaning-up the dia model:
</p>

<ul class="org-ul">
<li>create a base class such as <code>value</code> and make all values inherit from
it instead of using boost variant.</li>
<li>according to DTD, a composite can be made up of either composites or
attributes. We incorrectly modeled it as having just one inner
composite.</li>
<li>perhaps this is better thought of slightly differently: an attribute
has child nodes. The child nodes can either be leaf nodes, in which
case they are values, or non-leaf nodes in which case they are
composite nodes. Composite nodes themselves can have child nodes. If
they are leaf nodes they are values; if they are non-leaf nodes they
are either attributes or composites.</li>
<li>note that we do not need to use shared pointers in composite: we
could simply have an attribute by value. However, we still need to
handle the case where the children are either composite or
attributes. So if we somehow could get composite and attribute to
have a common base class, we could have a container of that base
class in composite. For this we would need a shared pointer.</li>
<li>consider adding the postfix <code>node</code> to class names and make it a real
tree, as per dia's implementation.</li>
<li>covert all vectors to lists since we do not know their sizes on
construction.</li>
<li>one thing to bear in mind is that if we fix the tree structure, we
will break the XML parsing code in hydrator, which took quite a
while to get right (and has hacks such as "inner composite").</li>
<li>its not obvious why we need to treat <code>dia::string</code> in a different
way from all other attribute values (except for <code>dia::font</code>).</li>
<li>alternative: create an XML schema from the DTD and use it with the
XSD tool to create the model.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfd8d371" class="outline-4">
<h4 id="orgfd8d371"><span class="section-number-4">5.8.152</span> Add support for XSD tool&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-152">
<p>
Similar to what we've done with ODB, it would be nice to be able to
integrate the XSD tool with dogen:
</p>

<ul class="org-ul">
<li>have a meta-model element for XSD schemas. We should also have a
part called <code>xsd</code> to store the XSD schemas. In this part we should
be able to have packages (e.g. <code>xsd::confirmation</code>). The meta-model
element must support all of the configuration options used by XSD
tool:</li>
</ul>

<pre class="example">
xsdcxx cxx-tree --generate-polymorphic --generate-serialization --cxx-suffix .cpp --hxx-suffix .hpp
--namespace-map http://www.fpml.org/FpML-5/confirmation=fpml511
--namespace-map http://www.w3.org/XML/1998/namespace=xml_ns
--namespace-map http://www.w3.org/2000/09/xmldsig#=xmldsig_nsdone
--polymorphic-type Product --polymorphic-type DirectionalLeg
--polymorphic-type PricingStructure --polymorphic-type
Rate --polymorphic-type PricingStructureValuation $b
</pre>


<p>
These should be in meta-data so that we can inherit them as
profiles.
</p>
<ul class="org-ul">
<li>we should handle decorations via prologue/epilogue.</li>
<li>useful options: <code>--std version</code>, <code>--guard-prefix</code>, etc. See man page
for details.</li>
<li>generate CMake targets that execute the XSD tool and place the
output in appropriate locations.</li>
<li>we should also support a <code>data</code> part with XML data files as
examples. Ideally these should then be used by generated tests to do
round-trip tests.</li>
<li>generated code should conform as much as possible to the dogen
structure (<code>include</code>, <code>src</code> folders, etc).</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://manpages.debian.org/jessie/xsdcxx/xsdcxx.1">xsdcxx man page</a></li>
<li><a href="https://www.codesynthesis.com/products/xsd/">XSD: XML Data Binding for C++</a></li>
<li><a href="https://www.codesynthesis.com/pipermail/xsd-users/2013-July/003990.html">[xsd-users] schema to c++ namespace mapping problem</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgef66a80" class="outline-4">
<h4 id="orgef66a80"><span class="section-number-4">5.8.153</span> Harmful workload generator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-153">
<p>
Noisia is a "Harmful workload generator for PostgreSQL." We could try
to extract some of these ideas and place them into generated code.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/lesovsky/noisia">https://github.com/lesovsky/noisia</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3b8f2d2" class="outline-4">
<h4 id="org3b8f2d2"><span class="section-number-4">5.8.154</span> Add Coherence POF serialisation support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-154">
<p>
If coherence has open source C++ libraries, we should add support for
serialisation to and from POF.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://docs.oracle.com/cd/E24290_01/coh.371/e22839/cpp_api.htm">Understanding the Coherence for C++ API</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga49dfb2" class="outline-4">
<h4 id="orga49dfb2"><span class="section-number-4">5.8.155</span> Generate Visual Studio solutions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-155">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to use visual studio solutions
directly so that I don't have to rely on CMake.
</p>

</blockquote></div>

<p>
At present we rely on CMake as the C++ meta-build system. There is
nothing stopping us from supporting more native build systems such as
Visual Studio. Consider adding direct support for Visual Studio.
</p>
</div>
</div>

<div id="outline-container-org4ef967a" class="outline-4">
<h4 id="org4ef967a"><span class="section-number-4">5.8.156</span> Consider adding YQL support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-156">
<p>
YQL offers a REST based API with lots of interesting information; an
example of the information provided is available <a href="https://github.com/yql/yql-tables/blob/master/yahoo/finance/yahoo.finance.quant.xml">here</a>. There should be
somewhere a matching XML schema for each of these queries, at least
for the end points that return XML. It would be great if one could
take one of those schemas and generate an yarn representation for them.
</p>

<p>
More generally, it would be great if dogen was able to create a domain
model off of an XML schema. However, we already have the Code
Synthesis <a href="http://www.codesynthesis.com/products/xsd/">XSD tool</a> for that, so maybe this is just scope creep.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://yuilibrary.com/yui/docs/yql/">https://yuilibrary.com/yui/docs/yql/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Yahoo!_Query_Language">Wikipedia: Yahoo! Query Language</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3b80b26" class="outline-4">
<h4 id="org3b80b26"><span class="section-number-4">5.8.157</span> Generate state diagrams&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-157">
<p>
There is nothing stopping us from reading the UML State Chart objects
in Dia and generating an FSM off of it, using boost's state
machines. The state machine could be drawn in the same diagram as the
classes; users could create a state machine associated with a class
somehow. The states would refer to the methods which the user would
manually implement. The system would spit out a state machine for the
target class.
</p>

<p>
These seem to be vaguely related to workflows. Some interesting posts
in dia mailinglist:
</p>

<ul class="org-ul">
<li><a href="https://mail.gnome.org/archives/dia-list/2015-June/msg00013.html">https://mail.gnome.org/archives/dia-list/2015-June/msg00013.html</a></li>
<li><a href="https://mail.gnome.org/archives/dia-list/2015-June/msg00014.html">https://mail.gnome.org/archives/dia-list/2015-June/msg00014.html</a></li>
</ul>

<p>
Now that we moved over to PlantUML it makes more sense to add parsing
support for Plant UML.
</p>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="http://blog.qt.io/blog/2017/01/23/qt-scxml-state-chart-support-qt-creator/">Qt SCXML and State Chart Support in Qt Creator</a></li>
<li><a href="https://en.wikipedia.org/wiki/SCXML">SCXML (wikipedia)</a></li>
<li><a href="https://www.w3.org/TR/scxml/">State Chart XML (SCXML): State Machine Notation for Control Abstraction</a></li>
<li><a href="https://github.com/tklab-tud/uscxml">uscxml</a></li>
<li>There are two possible implementations in boost: <a href="https://www.boost.org/doc/libs/1_67_0/libs/msm/doc/HTML/index.html">MSM</a> and <a href="https://www.boost.org/doc/libs/1_67_0/libs/statechart/doc/index.html">StateChart</a>.</li>
<li>See ragel as well: <a href="http://www.colm.net/open-source/ragel/">http://www.colm.net/open-source/ragel/</a></li>
<li><a href="https://github.com/josteink/wsd-mode">Web Sequence Diagrams emacs mode</a>: not exactly directly related.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfd9169f" class="outline-4">
<h4 id="orgfd9169f"><span class="section-number-4">5.8.158</span> Add reflection support by using model and type enums&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-158">
<div class="epigraph"><blockquote>
<p>
<b>Story</b>: As a dogen user, I want to use reflection on generated models
so that I can do run-time introspection.
</p>

</blockquote></div>

<p>
It may be useful to create enumerations for models, types and
properties within objects. This would in the future form the basis of
reflection. One could use implementation specific properties to set
the model ID and objects IDs.
</p>

<p>
A more advanced version would allow you to invoke methods via
reflection. However, since some languages support this natively, and
since it may even be part of C++ in the future, we probably should not
spend a huge amount of effort on this.
</p>

<p>
Use cases:
</p>

<ul class="org-ul">
<li>diff support</li>
</ul>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/billyquith/ponder">Ponder</a> a c++ reflection library.</li>
<li><a href="https://github.com/cginternals/cppexpose">cppexpose</a>: library for type introspection, reflection, and scripting
interface.</li>
<li><a href="https://github.com/Manu343726/siplasplas">siplasplas</a></li>
<li><a href="https://github.com/rttrorg/rttr">RTTR</a></li>
<li><a href="https://github.com/hugoam/mud">mud</a></li>
</ul>

<p>
Merged stories:
</p>

<p>
<b>Consider adding support for RTTR</b>
</p>

<p>
Instead of creating our own reflection, we could just add the code
necessary to register types and use a third party library such as
RTTR. It would be most useful if the models contained operations.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/rttrorg/rttr">GitHub Page</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2b3ef75" class="outline-4">
<h4 id="org2b3ef75"><span class="section-number-4">5.8.159</span> Add model diff support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-159">
<p>
One very useful feature we need to implement is the ability to compare
objects (even composite objects such as an entire model) and to obtain
a list of differences. This has several use cases:
</p>

<ul class="org-ul">
<li>when something breaks we want to know the before and after (or the
actual and expected) but we also want to know why they are
different, in particular for complex object graphs. This is the case
with unit tests and with changes to code when we have A/B paths.</li>
<li>in general, users of a system want to explain differences. For
example, if we had a report that was generating one set of numbers S
but is now generating another set of numbers S' we need to know
what contributes to this change.</li>
<li>for efficiency purposes, we may want to only send the differences
between two very large objects over the wire rather than the
entirety of the new version.</li>
</ul>

<p>
In theory nothing stops us from code generating all of the required
classes needed to diff objects in a model. There are two possible
approaches:
</p>

<p>
<b>Simple approach</b>:
</p>

<p>
Just create a new facet call diff and make these classes generate a
simple textual representation of differences, inspired in
<code>diff</code>. Where the object is an entity provide its ID. In general just
provide some "path" to the difference, e.g. model/object/member
variable/etc.
</p>

<p>
This is mainly useful for the first use case and it is simpler to
implement.
</p>

<p>
<b>Complex Approach</b>:
</p>

<p>
Models can have a <code>diff</code> option. When switched on, knit generates a
set of <code>diff</code> classes. These are system types like keys and live in a
sub-folder of <code>types</code>. They have full serialisation, hashing etc
support like any other model type. The generated classes are:
</p>

<ul class="org-ul">
<li><code>differ</code>: for each model type a differ gets generated. this is a
top-level class that diffs two objects of the same type.</li>
<li><code>changeset</code>: for each model type a changeset gets generated. it has
a variant called <code>changeset_types</code>, made up of all the types of all
properties in the model. if a model property has a model type then
it uses the changeset for that type rather than the type itself; for
all other cases, including containers, it uses the type itself.</li>
</ul>

<p>
In addition, we need set of enumerations in <code>reflection</code>. To start off
with, all it contains is a list of classes in the model and a list of
fields in each class.
</p>

<p>
The <code>changeset</code> then has a container of <code>changeset_types</code> against a
reflection class and field.
</p>

<p>
Diff support is injected into the model just like keys. It also
requires that basic reflection support gets injected too.
</p>

<p>
With this approach we can satisfy all use cases.
</p>

<p>
It seems this is known in the literature as a "difference model". Once
we have a difference model, we can apply it to the modeling metamodel
itself. This is useful when we change the metamodel and want to tell
users what chances to make to their templates. Some people advocate
automating the changes to the templates (paper below) but this seems
like quite a hard thing to implement. However, it is conceivable that
we could end up with a fixed set of commands to apply (e.g. rename
class, rename method, etc). these could be thought of as clang
transformations. of course, stitch template are not visible to clang
transformations so they would have to be updated by some other
means. on top of that, its not clear that you can apply the clang
transforms when the code does not compile, so the transforms would
have to be applied prior to running dogen; the actual metamodel code
would be first updated by the transform and then regenerated.
</p>

<p>
in order for the stitch templates refactoring to work, we'd need some
kind of way of relating the sources back to the templates, much like
protected regions; then we would have to generate a graph
representation in memory of the generated code that resembles the
fragments of the template, and update the template from the generated
code.
</p>

<p>
this whole problem can be seen as a variation of the "rename problem",
which we captured elsewhere: if a model element is renamed, how do we
propagate that change to all of the dependent code? one possibility is
to split it into several steps:
</p>

<ul class="org-ul">
<li>change the model. users should only do one change at a time to make
the process less brittle.</li>
<li>run dogen with git awareness (see rename story) so that we can see
both the old and the new model.</li>
<li>compute the diffs between the two and come up with a set of
diffs.</li>
<li>convert the diffs into clang refactor commands. apply those commands
to the <b>entire</b> code base.</li>
<li>perform reverse mapping to the stitch templates, and update them.</li>
<li>user then inspects the diffs to make sure it looks above board and
signs them off. code generator is rebuilt and all models are
regenerated.</li>
</ul>

<p>
its not clear if this kind of work (diffs, etc) is not more suitable
to domodl, with an ecore based metamodel.
</p>

<p>
links:
</p>

<ul class="org-ul">
<li><a href="http://www.academia.edu/download/41278180/dealing_with_the_coupled_evolution_of_me20160116-11059-1d1j84g.pdf">dealing with the coupled evolution of metamodels and model-to-text
transforms</a>.</li>
<li><a href="https://dl.acm.org/citation.cfm?id=2523603">bridging state-based differencing and co-evolution</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/4634773/">automating co-evolution in model-driven engineering</a></li>
<li><a href="https://s3.amazonaws.com/academia.edu.documents/30769313/paper9.pdf?awsaccesskeyid=akiaiwowyygz2y53ul3a&amp;expires=1526902206&amp;signature=huqoussmbwz%252fylfquvumqmz66nc%253d&amp;response-content-disposition=inline%253b%2520filename%253da_metamodel_independent_approach_to_diff.pdf">a metamodel independent approach to difference representation</a></li>
<li><a href="https://www.eclipse.org/emf/compare/">emf compare</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga151e81" class="outline-4">
<h4 id="orga151e81"><span class="section-number-4">5.8.160</span> Add sql support to dogen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="epic">epic</span></span></h4>
<div class="outline-text-4" id="text-5-8-160">
<p>
it would be nice to generate all of the tables required to store a
model as well as the stored procs to read and write instances of the
model.
</p>

<p>
notes:
</p>

<ul class="org-ul">
<li>use an attribute with the type to determine if we want only the id
of the foreign key in c++ code or if we want a whole type.</li>
<li>file names are: "qualified name-entity", e.g. model<sub>type</sub>.</li>
<li>drop/create statements: schema, table, load, save, erase, test data
generators, test.</li>
<li>ability to drop/create all: table, procs, etc.</li>
<li>cmake deployment support: targets such as deploy<sub>database</sub>,
undeploy<sub>database</sub></li>
<li>testing/ci: target that deploys all the sql to a clean database,
runs all sql tests and un-deploys all the sql.</li>
<li>database connection settings: use pgpass.</li>
<li>must cope with the test/development database separation. at present
there is a massive hack required to populate both databases
(changing makefile manually and then reverting the change).</li>
<li>there should be a way of passing in the database name as an
environment variable into the cmake</li>
<li>note that the objective is not to make something like odb. the sql
is generated specifically for dogen types, not general purpose.</li>
</ul>
</div>
</div>

<div id="outline-container-org965ba64" class="outline-4">
<h4 id="org965ba64"><span class="section-number-4">5.8.161</span> Consider adding support for <code>sandbox-api</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-161">
<p>
From their site:
</p>

<div class="epigraph"><blockquote>
<p>
What is Sandboxed API?
</p>

<p>
The Sandboxed API project (SAPI) aims to make sandboxing of C/C++
libraries less burdensome: after initial setup of security policies
and generation of library interfaces, an almost-identical stub API is
generated, transparently forwarding calls using a custom RPC layer to
the real library running inside a sandboxed environment.
</p>

<p>
Additionally, each SAPI library utilizes a tightly defined security
policy, in contrast to the typical sandboxed project, where security
policies must cover the total syscall/resource footprint of all
utilized libraries.
</p>

</blockquote></div>

<p>
It is not entirely clear how this works or how it would be integrated
with Dogen, but it would be nice to have a top-level flag that would
generate the glue code for sandbox-api.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/google/sandboxed-api">GitHub repo</a>: Sandboxed API automatically generates sandboxes for
C/C++ libraries</li>
</ul>
</div>
</div>

<div id="outline-container-orgcbf94c4" class="outline-4">
<h4 id="orgcbf94c4"><span class="section-number-4">5.8.162</span> Consider adding support for draw.io&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-162">
<p>
As pointed out by Klemens Morgenstern, this is a web-based diagramming
tool:
</p>

<ul class="org-ul">
<li><a href="https://draw.io">https://draw.io</a></li>
</ul>

<p>
It can export into XML, but the XML seems to be at a very low-level:
</p>

<pre class="example">
&lt;mxCell id="5d2195bd80daf111-8" value="&amp;amp;laquo;interface&amp;amp;raquo;&amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Name&amp;lt;/b&amp;gt;" style="html=1;rounded=0;shadow=0;comic=0;labelBackgroundColor=none;strokeColor=#000000;strokeWidth=1;fillColor=#ffffff;fontFamily=Verdana;fontSize=10;fontColor=#000000;align=center;" parent="1" vertex="1"&gt;
  &lt;mxGeometry x="490" y="1004" width="110" height="50" as="geometry"/&gt;
&lt;/mxCell&gt;
</pre>


<p>
In order to use this format, the injector would have to have a lot of
cleverness to assemble the objects into UML elements.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://about.draw.io/features/import-export/">https://about.draw.io/features/import-export/</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6d2dbca" class="outline-4">
<h4 id="org6d2dbca"><span class="section-number-4">5.8.163</span> Consider adding "sidecar" service functionality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-163">
<p>
A new trend emerging for HTTP based services is to have "sidecars"
that run next to the application providing common
functionality. Examples are envoy, kong. The idea of sidecars is that
most of the functionality is kept separate from the application
itself, making application code simpler. Upgrading the sidecar can now
be done transparently without impacting the application (in theory at
least). However, another way to look at this is to consider this
functionality to be facets of the product which can be code generated
on demand.
</p>

<p>
The easiest thing is to add the config file to our meta-model so that
we can generate it.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://medium.com/@far3ns/kong-the-microservice-api-gateway-526c4ca0cfa6">KONG - The Microservice API Gateway</a></li>
<li><a href="https://docs.konghq.com/hub/kong-inc/oauth2/">kong oauth2 plugin</a></li>
<li><a href="https://docs.konghq.com/hub/kong-inc/jwt/">kong jwt plugin</a></li>
<li><a href="https://github.com/envoyproxy/envoy">envoy GitHub</a></li>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/intro/life_of_a_request">envoy: Life of a Request</a></li>
</ul>
</div>
</div>

<div id="outline-container-org96fb431" class="outline-4">
<h4 id="org96fb431"><span class="section-number-4">5.8.164</span> Consider generating code for RAII wrapper&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-164">
<p>
It would be nice to be able to automatically generate a RAII wrapper
for a type. Once we have operations this may be doable. However, it is
not clear how we would know what methods to call on construction and
destruction. We could perhaps have some meta-data that annotates
operations as "start RAII" and "end RAII". Then we'd generate a class
with a constructor that matches the signature of these operations, and
constructs an instance of the owning class.
</p>

<p>
Actually this is very similar to make shared. We need to see what
approach they have taken on the constructor of this function. Example
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.0/libstdc++/api/a01033_source.html">for GCC</a>:
</p>

<pre class="code"><code><span style="color: #777778;">/**</span>
<span style="color: #777778;"> *  </span><span style="color: #339CDB;">@brief</span><span style="color: #777778;">  Create an object that is owned by a shared_ptr.</span>
<span style="color: #777778;"> *  </span><span style="color: #339CDB;">@param</span><span style="color: #777778;">  __args  Arguments for the </span><span style="color: #339CDB;">@a</span><span style="color: #777778;"> _Tp object's constructor.</span>
<span style="color: #777778;"> *  </span><span style="color: #339CDB;">@return</span><span style="color: #777778;"> A shared_ptr that owns the newly created object.</span>
<span style="color: #777778;"> *  </span><span style="color: #339CDB;">@throw</span><span style="color: #777778;">  std::bad_alloc, or an exception thrown from the</span>
<span style="color: #777778;"> *          constructor of </span><span style="color: #339CDB;">@a</span><span style="color: #777778;"> _Tp.</span>
<span style="color: #777778;"> */</span>
<span style="color: #339CDB; font-weight: bold;">template</span><span style="color: #C586C0;">&lt;</span><span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #35CDAF;">_Tp</span>, <span style="color: #339CDB; font-weight: bold;">typename</span>... <span style="color: #35CDAF;">_Args</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #339CDB; font-weight: bold;">inline</span> <span style="color: #35CDAF;">shared_ptr</span><span style="color: #C586C0;">&lt;</span><span style="color: #35CDAF;">_Tp</span><span style="color: #C586C0;">&gt;</span>
<span style="color: #D9DAA2;">make_shared</span><span style="color: #C586C0;">(</span><span style="color: #35CDAF;">_Args</span>&amp;&amp;... <span style="color: #85DDFF;">__args</span><span style="color: #C586C0;">)</span>
<span style="color: #C586C0;">{</span>
    <span style="color: #339CDB; font-weight: bold;">typedef</span> <span style="color: #339CDB; font-weight: bold;">typename</span> <span style="color: #339CDB;">std</span>::<span style="color: #339CDB;">remove_const</span><span style="color: #DB8E73;">&lt;</span><span style="color: #35CDAF;">_Tp</span><span style="color: #DB8E73;">&gt;</span>::<span style="color: #35CDAF;">type</span> <span style="color: #35CDAF;">_Tp_nc</span>;
    <span style="color: #339CDB; font-weight: bold;">return</span> allocate_shared<span style="color: #DB8E73;">&lt;</span><span style="color: #35CDAF;">_Tp</span><span style="color: #DB8E73;">&gt;(</span><span style="color: #339CDB;">std</span>::allocator<span style="color: #579C4C;">&lt;</span><span style="color: #35CDAF;">_Tp_nc</span><span style="color: #579C4C;">&gt;()</span>,
        <span style="color: #339CDB;">std</span>::forward<span style="color: #579C4C;">&lt;</span><span style="color: #35CDAF;">_Args</span><span style="color: #579C4C;">&gt;(</span>__args<span style="color: #579C4C;">)</span>...<span style="color: #DB8E73;">)</span>;
<span style="color: #C586C0;">}</span>
</code></pre>
</div>
</div>

<div id="outline-container-org5ce8386" class="outline-4">
<h4 id="org5ce8386"><span class="section-number-4">5.8.165</span> Add jailer like functionality to ORM support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-165">
<p>
Jailer is a Java tool that allows exporting subsets of a relational
database ("Database Subsetting Tool"). This is useful for example for
creating test databases. We could support jailer directly from
Dogen. However, we probably need to have built-in SQL support
first. This story also intersects other stories such as data
anonymisation.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://jailer.sourceforge.net/exporting-data.htm">jailer tutorial</a></li>
<li><a href="http://jailer.sourceforge.net/">jailer</a></li>
<li><a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database Design</a>: Fowler article talking about how
jailer is used with Agile.</li>
<li><a href="https://github.com/TonicAI/condenser">condenser</a>: Condenser is a config-driven database subsetting
tool. Seems similar to jailer.</li>
</ul>
</div>
</div>

<div id="outline-container-org8a05c58" class="outline-4">
<h4 id="org8a05c58"><span class="section-number-4">5.8.166</span> Add support for portable services&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-166">
<p>
It seems we just need to generate a small number of files in order to
support portable services. We could add these to our product model.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="http://0pointer.net/blog/walkthrough-for-portable-services-in-go.html">Portable Services Walkthrough (Go Edition)</a></li>
<li><a href="http://0pointer.net/blog/walkthrough-for-portable-services.html">Portable Services with systemd v239</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0a95bde" class="outline-4">
<h4 id="org0a95bde"><span class="section-number-4">5.8.167</span> Add support for the sobjectizer actor framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-167">
<div class="epigraph"><blockquote>
<p>
SObjectizer is one of a few cross-platform and OpenSource "actor
frameworks" for C++. But SObjectizer supports not only Actor Model,
but also Publish-Subscribe Model and CSP-like channels. The goal of
SObjectizer is significant simplification of development of concurrent
and multithreaded applications in C++.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/Stiffstream/sobjectizer">GH</a></li>
</ul>
</div>
</div>

<div id="outline-container-org804862d" class="outline-4">
<h4 id="org804862d"><span class="section-number-4">5.8.168</span> Add support for the rotor actor framework&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-168">
<div class="epigraph"><blockquote>
<p>
rotor is a non-intrusive event loop friendly C++ actor micro
framework, similar to its elder brothers like caf and sobjectizer. The
new release came out under the flag of pluginization, which affects
the entire lifetime of an actor.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/basiliscos/cpp-rotor">GH</a></li>
<li><a href="https://habr.com/ru/company/crazypanda/blog/522588/">What's new in rotor v0.09</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2848264" class="outline-4">
<h4 id="org2848264"><span class="section-number-4">5.8.169</span> Add support for CAF serialisation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-169">
<p>
The C++ Actor Framework is a C++ library implementing the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor
Model</a>. It requires serialisation support. This could be implemented as
a facet.
</p>

<p>
We may also be able to add simple actors, but this will probably
require some experience with the framework.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://actor-framework.readthedocs.io/en/latest/TypeInspection.html">Type Inspection (Serialization and String Conversion)</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgea016c2" class="outline-4">
<h4 id="orgea016c2"><span class="section-number-4">5.8.170</span> Add sonar cloud checks to project&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-170">
<p>
Sonar cloud seems to provide a set of security etc checks for open
source projects. A project was created but we still need CI integration.
</p>

<p>
Links
</p>

<ul class="org-ul">
<li><a href="https://github.com/arvidn/libtorrent">libtorrent</a>: example project using sonar cloud with badges. Their
<a href="https://sonarcloud.io/dashboard?id=libtorrent">project page</a>.</li>
<li><a href="https://sonarcloud.io/dashboard?id=MASD-Project_dogen">MASD-Project<sub>dogen</sub></a></li>
<li><a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner">Analyzing with SonarQube Scanner</a></li>
</ul>
</div>
</div>

<div id="outline-container-org45da88a" class="outline-4">
<h4 id="org45da88a"><span class="section-number-4">5.8.171</span> Consider adding weaving support as a command&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-171">
<p>
With the refactorings, we removed top-level weaving support in sprint
16 (around <a href="https://github.com/MASD-Project/dogen/commits/master?after=28ea047b0ee64e00f8d0f9df817194e83422419b+139">Apr 27 2019</a>). Weaving made sense originally because stitch
was responsible for processing a stitch template and had all the
information required to convert a sttich template into a compilable
C++ file. This was because stitch had its own annotations and access
to the profiling system. However, with the integration of variability
into the meta-model, sadly it no longer made sense to have a
self-contained template because the variability elements had to come
from a model. In order to have a self-contained template we need to:
</p>

<ul class="org-ul">
<li>process an associated model (or set of models, via references);</li>
<li>build all of the variability structures;</li>
<li>supply them into the stitch template workflow.</li>
</ul>

<p>
This means that its almost as hard as code-generating the entire model
in the first place. It may still make sense to create some transform
chains to execute this use case, but we do not have any use cases for
it at present and it is non-trivial to implement this.
</p>

<p>
A second, related, approach is to allow the mere "template
instantiation". In this case, you can generate stitch templates but
these have no knowledge of the model. You could use stitch outside of
dogen for whatever use case you may have (e.g. as a stand-alone T4
like language) but you have no access to any of the model machinery
(at least to start off with). Similarly, with wale (and inja, in the
future), you could expand templates etc but without connection to a
model. Again, we don't really have concrete use cases for these as of
yet so we haven't decided on implementation details, but this story
will be used to capture ideas in this space.
</p>
</div>
</div>

<div id="outline-container-orgeb1ba96" class="outline-4">
<h4 id="orgeb1ba96"><span class="section-number-4">5.8.172</span> Consider creating textual UML injectors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-172">
<p>
We could create a frontend that reads TextUML files:
</p>

<ul class="org-ul">
<li><a href="https://github.com/abstratt/textuml">https://github.com/abstratt/textuml</a></li>
<li><a href="http://abstratt.github.io/textuml/readme">http://abstratt.github.io/textuml/readme</a></li>
</ul>

<p>
Example (copied from the <a href="http://abstratt.github.io/textuml/docs/tutorial.html">tutorial</a>):
</p>

<pre class="example" id="orgd599ed7">
package payment;

class PaymentMethod
end;

class Cheque specializes PaymentMethod
end;
</pre>

<p>
Now that we are thinking about moving to XMI, this may make slightly
less sense, but nevertheless, its worth capturing the idea. Actually
there are many different languages that implement textual UML:
</p>

<ul class="org-ul">
<li><a href="https://blog.abstratt.com/2007/11/01/uml-101-the-templates-package/">UML 101 with TextUML: the Templates package</a></li>
<li><a href="http://abstratt.github.io/textuml/docs/structure.html">Modeling structure</a>: note that they do not use standard UML - there
are a number of extensions.</li>
<li>list of textual UML tools: <a href="https://modeling-languages.com/text-uml-tools-complete-list/">Text to UML tools  Fastest way to create
your models</a></li>
<li><a href="https://modeling-languages.com/umple-language-model-oriented-programming/">UMPLE</a></li>
<li>OMG created <a href="https://www.omg.org/spec/HUTN/About-HUTN/">HUTN</a> (human-usable textual notation specification).</li>
<li><a href="https://www.eclipse.org/epsilon/doc/articles/hutn-basic/">Using the Human-Usable Textual Notation (HUTN) in Epsilon</a></li>
<li><a href="https://www.cooperate-project.de/images/publications/MODELSWARD2016.pdf">Survey on Textual Notations for the Unified Modeling Language</a>:
academic paper.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfec9e4d" class="outline-4">
<h4 id="orgfec9e4d"><span class="section-number-4">5.8.173</span> Consider implementing a "mock server" for HTTP&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-173">
<p>
This project looks very interesting: <a href="https://www.mock-server.com/">MockServer</a>.
</p>

<p>
From the docs:
</p>

<div class="epigraph"><blockquote>
<p>
For any system you integrate with via HTTP or HTTPS MockServer can be
used as:
</p>

<ul class="org-ul">
<li>a mock configured to return specific responses for different
requests</li>
<li>a proxy recording and optionally modifying requests and responses</li>
<li>both a proxy for some requests and a mock for other requests at the
same time</li>
</ul>

<p>
When MockServer receives a request it matches the request against
active expectations that have been configured, if no matches are found
it proxies the request if appropriate otherwise a 404 is returned.
</p>

<p>
For each request received the following steps happen:
</p>

<ul class="org-ul">
<li>find matching expectation and perform action</li>
<li>if no matching expectation proxy request</li>
<li>if not a proxy request return 404</li>
</ul>

<p>
An expectation defines the action that is taken, for example, a
response could be returned.
</p>

</blockquote></div>

<p>
It seems we could generate a "mock server" facet for models with HTTP
support.
</p>
</div>
</div>

<div id="outline-container-orga462196" class="outline-4">
<h4 id="orga462196"><span class="section-number-4">5.8.174</span> Consider adding metrics support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-174">
<p>
All services should have support for metrics. Dogen should implement
this directly in the meta-model and then code-generate it using a PDM.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/jupp0r/prometheus-cpp">prometheus-cpp</a>: This library aims to enable Metrics-Driven
Development for C++ services. It implements the Prometheus Data
Model, a powerful abstraction on which to collect and expose
metrics. We offer the possibility for metrics to be collected by
Prometheus, but other push/pull collections can be added as plugins.</li>
<li><a href="https://github.com/ultradns/cppmetrics">cppmetrics</a>: C++ port of the codahale/dropwizard metrics library. See
also <a href="https://github.com/konstan/cppmetrics">this fork</a>.</li>
<li><a href="https://github.com/orca-zhang/influxdb-cpp">GH influxdb-cpp</a>: influxdb is used as a timeseries DB for metrics.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbbc5a14" class="outline-4">
<h4 id="orgbbc5a14"><span class="section-number-4">5.8.175</span> Consider adding support for RAFT protocol&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-175">
<p>
It may be useful to add RAFT as a meta-model concept. From wikipedia:
</p>

<div class="epigraph"><blockquote>
<p>
Raft is a consensus algorithm designed as an alternative to the Paxos
family of algorithms. It was meant to be more understandable than
Paxos by means of separation of logic, but it is also formally proven
safe and offers some additional features.
</p>

</blockquote></div>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Raft_(computer_science)">Wikipedia: Raft</a></li>
<li><a href="https://github.com/eBay/NuRaft">NuRaft GitHub</a>: Raft implementation derived from the cornerstone
project, which is a very lightweight C++ implementation with minimum
dependencies, originally written by Andy Chen.</li>
<li><a href="https://github.com/datatechnology/cornerstone">cornerstone GitHub</a>: A very lightweight but complete Raft Consensus
C++ implementation, the original implementation was published by
Andy Chen.</li>
<li><a href="https://github.com/typesense/braft">brcp GH</a>: "An industrial-grade C++ implementation of RAFT consensus
algorithm and replicated state machine based on brpc. braft is
designed and implemented for scenarios demanding for high workload
and low overhead of latency, with the consideration for
easy-to-understand concepts so that engineers inside Baidu can build
their own distributed systems individually and correctly."</li>
</ul>
</div>
</div>

<div id="outline-container-org8397003" class="outline-4">
<h4 id="org8397003"><span class="section-number-4">5.8.176</span> Consider adding support for static site generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-176">
<p>
Its not entirely clear how this would work, but it may be interesting
to describe a site at the meta-model level and then use an existing
generator to output the code as a cartridge. This could also be an
interesting way to document an API a-la OpenAPI.
</p>

<p>
The second link here is org-mode. If we had a library that could
convert org-mode documents into static HTML, then this would be a
natural thing to do. For good measure, if models were themselves
org-mode documents we could then generate the documentation for a
model in this way. We could also augment it via images (UML diagrams,
etc). For extra bonus points, we could integrate the documentation
generator for the source code; for example, it would be nice to have
links from a given model element to all the files it generates and all
of the associated documentation. We could use standardese for this as
a library.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://github.com/nifty-site-manager/nsm">Nift</a>: Nift is a cross-platform open source framework for managing
and generating websites. See also <a href="https://www.nift.cc/index.html">homepage</a>.</li>
<li><a href="https://github.com/standardese/standardese">standardese GitHub</a>: Standardese aims to be a nextgen Doxygen. It
consists of two parts: a library and a command line tool.</li>
</ul>
</div>
</div>

<div id="outline-container-org0a3d4cf" class="outline-4">
<h4 id="org0a3d4cf"><span class="section-number-4">5.8.177</span> Consider adding support for Boost.Pool&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-177">
<p>
The basic idea is to integrate Boost.Pool with the generated code such
that we could generate objects that are instantiated inside a pool or
an arena. This will be helpful when we finally move to a data driven
approach.
</p>

<p>
Links:
</p>

<ul class="org-ul">
<li><a href="https://theboostcpplibraries.com/boost.pool">Chapter 4. Boost.Pool</a></li>
</ul>
</div>
</div>

<div id="outline-container-org16cb2d6" class="outline-4">
<h4 id="org16cb2d6"><span class="section-number-4">5.8.178</span> Unmaintained emblem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="story">story</span></span></h4>
<div class="outline-text-4" id="text-5-8-178">
<p>
If we ever reach a point where Dogen is complete according to the
vision, we should add this emblem:
</p>

<p>
<a href="http://unmaintained.tech/">http://unmaintained.tech/</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-02-26 Fri 18:20</p>
</div>
</body>
</html>
