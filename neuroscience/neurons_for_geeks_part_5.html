<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-10 Sat 16:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neurons for Computer Geeks - Part V: Yet More Theory</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/tufte.css" type="text/css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Neurons for Computer Geeks - Part V: Yet More Theory</h1>
<p>
<a href="index.html">Back to chapter index.</a>
</p>

<p>
Monday, September 07, 2015
</p>

<p>
Welcome to part V of a multi-part series on modeling neurons. In <a href="neurons_for_geeks_part_4.html">part
IV</a> we introduced the RC Circuit by making use of the foundations we
painstakingly laid in previous posts. In truth, we could now move on
to code and start looking at the Leaky Integrate-and-Fire (LIF) model,
since we've already covered most required concepts. However, we are
going to do just a little bit more theory before we get to that.
</p>

<p>
The main reason for this detour is that I do not want to give you the
impression neurons are easy; if there is one thing that they are not
is easy. So we're going to resume our morphological and electrical
exploits to try to provide a better account of the complexity inside
the neuron, hopefully supplying enough context to appreciate the
simplifications done in LIF.
</p>

<p>
The content of this post is highly inspired from <a href="http://www.cambridge.org/us/academic/subjects/life-sciences/neuroscience/principles-computational-modelling-neuroscience">Principles of
Computational Modelling in Neuroscience</a>, a book that is a must read
introduction if you decide to become serious on this subject. If so,
you may also want to check the Gerstner videos: <a href="http://klewel.com/conferences/epfl-neural-networks/index.php?talkID=1">Neural networks and
biological modeling</a>.
</p>

<p>
But you need not worry, casual reader. Our feet are firmly set in
layman's land and we'll remain so until the end of the series.
</p>

<div id="outline-container-orgc9c66b8" class="outline-2">
<h2 id="orgc9c66b8">Brief Context on Modeling</h2>
<div class="outline-text-2" id="text-orgc9c66b8">
<p>
Before we get into the subject matter proper, I'd like us to ponder a
few "meta-questions" in terms of modeling.
</p>
</div>

<div id="outline-container-org1a9bd9b" class="outline-3">
<h3 id="org1a9bd9b">Why Model?</h3>
<div class="outline-text-3" id="text-org1a9bd9b">
<p>
A layperson may think that we model neurons because we want to build a
"computer brain": one that is similar to a real brain, with its
amazing ability to learn, and one which at some point may even think
and be conscious. Hopefully, after you finish this series of posts,
you will appreciate the difficulty of the problem and see that it's
not very likely we'll be able to make a "realistic" "computer brain"
any time soon - for sensible values of "realistic", "computer brain"
and "any time soon".
</p>

<p>
Whilst we have good models that explain part of the behaviour of the
neuron and good models for neural networks too, it is not the case
that we can put all of these together to form some kind of "unified
neuron model", multiply it by 80 billion, add a few quadrillion
synapses and away we go: artificial consciousness. Given what we know
at the moment, this approach is far too computationally demanding to
be feasible. Things would change if there was a massive leap in
computational power, of course, but not if they stay at present
projections - even with <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore's Law</a>.
</p>

<p>
So if we are not just trying to build a computer brain, then why
bother? Well, if you set your sights a little lower, computational
models are actually amazingly useful:
</p>

<ul class="org-ul">
<li>one can use code to explore a small portion of the problem domain,
making and validating predictions using computer models, and then
test those predictions in the lab with real wetware. The iterative
process is orders of magnitude faster.</li>
<li>computer models are now becoming quite sophisticated, so in some
cases they are good representations of biological processes. This
tends to be the case for small things such as individual cells or
smaller. As computers get faster and faster according to Moore's
Law, the power and scope of these models grows too.</li>
<li>distributing work with Free and Open Source Software licences means
it is much easier for researchers to reproduce each others work, as
well as for them to explore avenues not taken by those who did the
work originally, speeding things up considerably. Standing on the
shoulders of giants and all that.</li>
</ul>
</div>
</div>

<div id="outline-container-org30001b3" class="outline-3">
<h3 id="org30001b3">What Tools Do We Model With?</h3>
<div class="outline-text-3" id="text-org30001b3">
<p>
The focus of these posts is on writing models from scratch, but that's
not how most research is conducted. In the real world, people try
their best to reuse existing infrastructure - of which there is
plenty. For example there is <a href="https://www.neuron.yale.edu/neuron/">NEURON</a>, <a href="http://neuralensemble.org/PyNN/">PyNN</a>, <a href="http://briansimulator.org/">Brian</a> and much more. Tools
and processes have evolved around these ecosystems, and there is a
push to try to standardise around the more successful frameworks.
</p>

<p>
There is also a push to find some kind of standard "language" to
describe models so that we can all share information freely without
having to learn the particulars of each others representations. The
world is not quite there yet, but initiatives such as <a href="https://www.neuroml.org/">NeuroML</a> are
making inroads in this direction.
</p>

<p>
However, the purpose of our this series is simplification, so we will
swerve around all of this. Perhaps material for another series.
</p>
</div>
</div>

<div id="outline-container-orgf72c8b0" class="outline-3">
<h3 id="orgf72c8b0">At What Level Should One Model?</h3>
<div class="outline-text-3" id="text-orgf72c8b0">
<p>
A related question to the previous ones - and one that is not normally
raised in traditional software engineering, but is very relevant in
biology - is the level of detail at which one should model.
</p>

<p>
Software Engineers tend to believe there is a model for a problem, and
once you understand enough about the problem domain you will come up
with it and all will be light. Agile and sprints are just a way to
converge to it, to the perfection that exists somewhere in the
platonic cloud. Eric Evans with <a href="https://domainlanguage.com/ddd/">DDD</a> started to challenge that
assumption somewhat by making us reflect on just what it is that we
mean by "model" and "modeling", but, in general, we have such an
ingrained belief in this idea that is very hard to shake it off or to
even realise the belief is there in the first place. Most of us still
think of the code representation of the domain model as the model -
rather than accept it is one of a multitude of possible
representations, each suitable for a given purpose.
</p>

<p>
Alas, all of this becomes incredibly obvious when you are faced with a
problem like modeling a neuron or a network of neurons. Here, there is
just no such thing as the "right model"; only a set of models at a
different perspectives, each with a different set of trade-offs, and
any of them only make sense in the context of what one is trying to
study. It may make sense to model neurons like networks, ignoring the
finer details of each one and looking at their behaviour as a group,
or it may make sense to model individual bits of the neuron as an
entity. What makes it "right" or "wrong" is what it is that we are
using the model for and how much computational power one has at one's
disposal.
</p>

<p>
Having said all of that, lets resume our morphology adventures.
</p>
</div>
</div>
</div>

<div id="outline-container-org2c1f4cd" class="outline-2">
<h2 id="org2c1f4cd">Electricity and Neurons</h2>
<div class="outline-text-2" id="text-org2c1f4cd">
<p>
We started off with <a href="neurons_for_geeks_part_1.html">an overview of the neuron</a> and then moved over to
<a href="neurons_for_geeks_part_2.html">lots</a> and <a href="neurons_for_geeks_part_4.html">lots</a> of electricity; now it's time to see how those two fit
together.
</p>

<p>
As we explained in <a href="neurons_for_geeks_part_1.html">part I</a>, there is a electric potential difference
between the inside of the cell and the outside, called the membrane
potential. The convention to compute this potential is to subtract the
potential inside the cell to the potential outside the cell; current
is positive when there is a flow of positive charge from the inside to
the outside and negative otherwise. Taken into account these
definitions, one should be able to make sense of the resting membrane
potential: it is around -65mv. But how does this potential change?
</p>
</div>

<div id="outline-container-orgfc5ede7" class="outline-3">
<h3 id="orgfc5ede7">Ion Channels</h3>
<div class="outline-text-3" id="text-orgfc5ede7">
<p>
<a href="neurons_for_geeks_part_2.html">Earlier</a>, we spoke about ions - atoms that either lost or gained
electrons and so are positively or negatively charged. We also said
that, in general, the cell's membrane is impermeable, but there are
tiny gaps in the membrane which allow things in and out of the
cell. Now we can expand a bit further. Ion channels are one such gap,
and they have that name because they let ions through. There are many
kinds of ion channels. One way of naming them is to use the ion they
are most permeable to - but of course, this being biology, the ion
channels don't necessarily always have a major ion they are permeable
to.
</p>

<p>
Another useful categorisation distinguishes between passive and active
ion channels. Active channels are those that change their permeability
depending on external factors such as the membrane potential, the
concentration of certain ions, and so on. For certain values they are
open - i.e. permeable - whereas for other values they are closed, not
allowing any ions through. Passive channels are simpler, they just
have a fixed permeability behaviour.
</p>

<p>
There are also ionic pumps. These are called pumps because they take
one kind of ion out, exchanging it for another kind. For instance, the
sodium-potassium pump pushes potassium into the cell and expels sodium
out. A pump has a stoichiometry, which is a fancy word to describe the
ratio of ions being pumped in and out.
</p>
</div>
</div>

<div id="outline-container-org11673cc" class="outline-3">
<h3 id="org11673cc">Complexity Starts To Emerge</h3>
<div class="outline-text-3" id="text-org11673cc">
<p>
As you can imagine, the key to understating electric behaviour is
understanding how these pesky ions move around. Very simplistically,
ions tend to move for two reasons: because there is a potential
difference between the inside and the outside of the cell, or because
of the concentration gradient of said ion. The concentration gradient
just means that, left to their own devices, concentration becomes
uniform over time. For example, if you drop some ink in a glass of
water, you will start by seeing the ink quite clearly; given enough
time, the ink will diffuse in the water, making it all uniformly
coloured. The same principle applies to ions - they want to be
uniformly concentrated.
</p>

<p>
It should be fairly straightforward to work out that a phenomenal
number of permutations is possible here. Not only do we have a great
number of channels, all with different properties - some switching on
and off as properties change around the cell - but we also have the
natural flow of ions being affected by the membrane's potential and
the concentration gradient, all of which are changing over time. To
make matters worse, factors interact with each other such that even if
you have simple models to explain each aspect individually, the
overall behaviour is still incredibly complex.
</p>

<p>
Now imagine more than <a href="http://pubs.acs.org/doi/abs/10.1021/jp0120662">50 thousand</a> such ion channels - of over one
hundred (known) types - in just a single neuron and you are starting
to get an idea of the magnitude of the task.
</p>
</div>
</div>

<div id="outline-container-orgdf1ad30" class="outline-3">
<h3 id="orgdf1ad30">Equivalent Circuit for a Patch of Membrane</h3>
<div class="outline-text-3" id="text-orgdf1ad30">
<p>
But lets return to simplicity. The very clever people determined that
it is possible to model the behaviour of ions and its electric effects
by thinking of it as an electric circuit. Taking a patch of membrane
as an example, it can be visualised as an electric circuit like so:
</p>


<div id="org43a330c" class="figure">
<p><img src="./Cell_membrane_equivalent_circuit.png" alt="Cell_membrane_equivalent_circuit.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Source: Wikipedia, Membrane Potential</p>
</div>

<p>
What this diagram tells us is that the membrane itself acts as a
capacitor, with its capacitance determined by the properties of the
lipid bilayer. We didn't really discuss the lipid bilayer before so
perhaps a short introduction is in order. The membrane is made up of
two sheets of lipids (think fatty acids), which when layered so, have
interesting properties: the outside of the sheets are impermeable to
most things such as water molecules and ions. The membrane itself is
pretty thin, at around 5nm.
</p>

<p>
The membrane capacitance is considered constant. We then have a series
of ion channels: sodium, potassium, chlorine, calcium. Each of these
can be thought of as a pairing of a resistor with variable conductance
coupled with a battery. Note that the resistor and the battery are in
series, but the ion channels themselves form a parallel circuit. The
voltages for each pathway are determined by the different
concentrations of the ion inside and outside the cell.
</p>

<p>
If we further assume fixed ion concentrations and passive ion
channels, we can perform an additional simplification on the circuit
above and we finally end up with an RC Circuit:
</p>


<div id="org8a874ce" class="figure">
<p><img src="./Cell_membrane_reduced_circuit.png" alt="Cell_membrane_reduced_circuit.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Source: Wikipedia, Membrane Potential</p>
</div>

<p>
The circuit now has one resistance, which we call the membrane
resistance, and a membrane battery.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd750076" class="outline-2">
<h2 id="orgd750076">What next?</h2>
<div class="outline-text-2" id="text-orgd750076">
<p>
Hopefully you can start to see both the complexity around modeling
neurons and the necessity to create simpler models to make them
computationally feasible - just look at the amount of simplification
that was required for us to get to an RC Circuit!
</p>

<p>
But at least we can now look forward to implementing LIF.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="neurons_for_geeks_part_4.html">Back to previous chapter</a></td>
<td class="org-left"><a href="index.html">Back to chapter index.</a></td>
<td class="org-left"><a href="neurons_for_geeks_part_6.html">Forward to next chapter</a></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-04-10 Sat 16:40</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
